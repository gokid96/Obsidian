## 요약
- 로직 수행 전 락 획득 및 접근 제어
- 동시 접근을 사전에 차단
- 충돌 발생 가능성을 사전에 방지
- 성능 오버헤드가 높을 수 있음
- 쓰기 작업이 빈번하고 충돌 가능성이 높은 시스템에 적합

## 비관적 락 개요

비관적 락은 데이터 동시성 제어를 위한 메커니즘으로, 동시 접근으로 인한 데이터 충돌이 반드시 발생할 것이라고 '비관적으로' 가정하는 동시성 제어 방식

### 핵심 개념

- 데이터 수정 시 충돌 가능성을 높게 보고 사전에 락 획득
- 데이터베이스 수준의 락 메커니즘 사용
- 트랜잭션 간 데이터 격리 보장

## JPA에서의 비관적 락 사용

### 기본 비관적 락 사용

```java
@Service
public class ProductService {
    @PersistenceContext
    private EntityManager entityManager;

    public Product findWithPessimisticLock(Long productId) {
        // 공유 락 (읽기 락)
        return entityManager.find(
            Product.class, 
            productId, 
            LockModeType.PESSIMISTIC_READ
        );
    }

    @Transactional
    public void updateProductWithLock(Long productId, BigDecimal newPrice) {
        // 배타적 락 (쓰기 락)
        Product product = entityManager.find(
            Product.class, 
            productId, 
            LockModeType.PESSIMISTIC_WRITE
        );
        
        product.setPrice(newPrice);
    }
}
```

## 비관적 락 모드 상세

### 1. PESSIMISTIC_READ

- 공유 락(Shared Lock)
- 읽기 작업 동안 다른 트랜잭션의 쓰기 방지
- 여러 트랜잭션 동시 읽기 허용

### 2. PESSIMISTIC_WRITE

- 배타적 락(Exclusive Lock)
- 읽기 및 쓰기 모두 차단
- 가장 엄격한 동시성 제어

### 3. PESSIMISTIC_FORCE_INCREMENT

- 엔티티 읽기 시 버전 강제 증가
- 추가적인 버전 관리 메커니즘

## 복잡한 시나리오 처리

### 재고 관리 예시

```java
@Service
public class StockService {
    @PersistenceContext
    private EntityManager entityManager;

    @Transactional
    public void decreaseStock(Long productId, int quantity) {
        // 비관적 쓰기 락으로 동시성 제어
        Product product = entityManager.find(
            Product.class, 
            productId, 
            LockModeType.PESSIMISTIC_WRITE
        );

        if (product.getStockQuantity() >= quantity) {
            product.decreaseStock(quantity);
        } else {
            throw new InsufficientStockException("재고 부족");
        }
    }
}
```

### JPQL에서의 비관적 락

```java
public List<Product> findLowStockProducts() {
    return entityManager.createQuery(
        "SELECT p FROM Product p WHERE p.stockQuantity < :threshold", Product.class)
        .setParameter("threshold", 10)
        .setLockMode(LockModeType.PESSIMISTIC_WRITE)
        .getResultList();
}
```

## 타임아웃 및 고급 락 옵션

### 락 타임아웃 설정

```java
@Transactional
public void updateWithTimeout(Long productId, BigDecimal newPrice) {
    Map<String, Object> properties = new HashMap<>();
    properties.put("javax.persistence.lock.timeout", 3000); // 3초 타임아웃

    Product product = entityManager.find(
        Product.class, 
        productId, 
        LockModeType.PESSIMISTIC_WRITE,
        properties
    );

    try {
        product.setPrice(newPrice);
    } catch (PessimisticLockException e) {
        // 락 획득 실패 처리
        throw new ConcurrentModificationException("동시성 충돌");
    }
}
```

## 비관적 락의 장단점

### 장점

- 데이터 일관성 강력 보장
- 동시성 충돌 사전 방지
- 복잡한 트랜잭션 시나리오 처리에 적합

### 단점

- 성능 오버헤드 발생
- 데이터베이스 리소스 점유 시간 증가
- 데드락 가능성

## 데드락 방지 전략

### 1. 일관된 락 획득 순서

```java
@Transactional
public void transferFunds(Long fromAccountId, Long toAccountId, BigDecimal amount) {
    // 항상 ID 순서대로 락 획득
    Account fromAccount = entityManager.find(
        Account.class, 
        Math.min(fromAccountId, toAccountId), 
        LockModeType.PESSIMISTIC_WRITE
    );
    
    Account toAccount = entityManager.find(
        Account.class, 
        Math.max(fromAccountId, toAccountId), 
        LockModeType.PESSIMISTIC_WRITE
    );

    fromAccount.withdraw(amount);
    toAccount.deposit(amount);
}
```

### 2. 타임아웃 및 재시도 메커니즘

```java
@Service
public class ConcurrentService {
    @Transactional
    public void performConcurrentOperation(Long resourceId) {
        int maxRetries = 3;
        for (int attempt = 0; attempt < maxRetries; attempt++) {
            try {
                performOperationWithLock(resourceId);
                return; // 성공 시 종료
            } catch (PessimisticLockException e) {
                if (attempt == maxRetries - 1) {
                    throw new ConcurrentModificationException("작업 실패");
                }
                
                // 점진적 대기 시간
                try {
                    Thread.sleep(100L * (attempt + 1));
                } catch (InterruptedException ie) {
                    Thread.currentThread().interrupt();
                    throw new RuntimeException("인터럽트 발생", ie);
                }
            }
        }
    }

    private void performOperationWithLock(Long resourceId) {
        Resource resource = entityManager.find(
            Resource.class, 
            resourceId, 
            LockModeType.PESSIMISTIC_WRITE
        );
        
        // 실제 비즈니스 로직 수행
        resource.performAction();
    }
}
```

## 주의사항

### 성능 고려사항

- 비관적 락은 성능에 영향을 미침
- 매우 빈번한 동시 접근이 예상되는 리소스에 신중히 적용
- 가능한 한 락 영역을 최소화

### 데이터베이스 특성 고려

- 각 데이터베이스의 락 구현 방식 차이 인지
- 데이터베이스 트랜잭션 격리 수준과 연계 고려

## 결론

비관적 락은 높은 동시성 제어와 데이터 일관성이 요구되는 시스템에서 효과적인 동시성 관리 메커니즘입니다. 하지만 성능과 데드락 가능성을 항상 고려해야 하며, 시스템의 특성에 맞게 신중하게 적용해야 합니다.