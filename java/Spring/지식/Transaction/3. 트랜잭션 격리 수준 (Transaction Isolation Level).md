
## 격리 수준 개요

트랜잭션 격리 수준은 동시에 여러 트랜잭션이 실행될 때 데이터의 일관성과 동시성을 제어하는 메커니즘입니다.

### 주요 목적

- 동시 트랜잭션 간 데이터 접근 제어
- 데이터 일관성 유지
- 성능과 데이터 무결성 사이의 균형 조정

## 격리 수준의 종류

### 1. READ UNCOMMITTED (가장 낮은 격리 수준)

```java
@Transactional(isolation = Isolation.READ_UNCOMMITTED)
public void readUncommittedMethod() {
    // 다른 트랜잭션의 커밋되지 않은 변경 내용 읽기 가능
    // 데이터 부정합 위험 높음
}
```

#### 특징

- 커밋되지 않은 데이터 읽기 허용 (Dirty Read)
- 가장 낮은 수준의 격리
- 성능은 가장 좋지만 데이터 정합성 보장 최악

### 2. READ COMMITTED (기본 격리 수준)

```java
@Transactional(isolation = Isolation.READ_COMMITTED)
public void readCommittedMethod() {
    // 커밋된 데이터만 읽기 허용
    // 대부분의 데이터베이스 기본 격리 수준
}
```

#### 특징

- 커밋된 데이터만 읽기 가능
- Dirty Read 방지
- 트랜잭션 중 데이터 변경 시 이전 값 반환 (Non-Repeatable Read 가능)

### 3. REPEATABLE READ

```java
@Transactional(isolation = Isolation.REPEATABLE_READ)
public void repeatableReadMethod() {
    // 트랜잭션 내에서 동일 데이터 반복 읽기 일관성 보장
    // 트랜잭션 시작 시점의 데이터 유지
}
```

#### 특징

- 트랜잭션 시작 시점의 데이터 일관성 보장
- Non-Repeatable Read 방지
- 팬텀 리드(Phantom Read) 가능성 존재

### 4. SERIALIZABLE (가장 높은 격리 수준)

```java
@Transactional(isolation = Isolation.SERIALIZABLE)
public void serializableMethod() {
    // 완전한 격리 - 동시 트랜잭션 간 완전 직렬화
    // 가장 엄격한 격리 수준
}
```

#### 특징

- 동시 트랜잭션 완전 직렬화
- 팬텀 리드 방지
- 동시성 성능 가장 낮음
- 데이터 일관성 최고 수준

## 동시성 문제 유형

### 1. Dirty Read

- 트랜잭션 A가 데이터 변경 중인 상태를 트랜잭션 B가 읽음
- 변경 내용이 롤백될 수 있음

### 2. Non-Repeatable Read

- 트랜잭션 내에서 같은 데이터를 여러 번 읽을 때 값이 달라짐

### 3. Phantom Read

- 트랜잭션 실행 중 새로운 레코드가 추가되거나 삭제됨

## 격리 수준 선택 예시

```java
@Service
public class AccountService {
    @Transactional(isolation = Isolation.READ_COMMITTED)
    public void transferMoney(Long fromAccountId, Long toAccountId, BigDecimal amount) {
        // 금전 거래와 같은 중요한 작업에는 
        // 기본적으로 READ COMMITTED 사용
    }
    
    @Transactional(isolation = Isolation.REPEATABLE_READ)
    public void generateFinancialReport() {
        // 보고서 생성과 같은 일관성이 중요한 작업에는 
        // REPEATABLE READ 사용
    }
}
```

## 성능 및 동시성 비교

|격리 수준|Dirty Read|Non-Repeatable Read|Phantom Read|성능|
|---|---|---|---|---|
|READ UNCOMMITTED|O|O|O|높음|
|READ COMMITTED|X|O|O|높음|
|REPEATABLE READ|X|X|O|중간|
|SERIALIZABLE|X|X|X|낮음|

## 주의사항

### 성능 고려

- 격리 수준이 높아질수록 성능 저하
- 비즈니스 요구사항과 성능 사이 균형 필요

### 데이터베이스별 차이

- 각 데이터베이스마다 격리 수준 구현 방식 다름
- 데이터베이스 특성 고려 필요

## 결론

적절한 트랜잭션 격리 수준 선택은 데이터 일관성과 성능 사이의 균형을 맞추는 중요한 결정입니다. 비즈니스 요구사항과 시스템 특성을 고려하여 신중하게 선택해야 합니다.