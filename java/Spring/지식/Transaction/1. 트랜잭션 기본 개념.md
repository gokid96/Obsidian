
## 트랜잭션이란?

트랜잭션은 데이터베이스에서 데이터를 다루는 논리적인 작업의 단위로, 여러 개의 작업을 하나의 단위로 묶어 데이터의 일관성과 안전성을 보장합니다.

### 트랜잭션의 주요 목적

- 데이터 일관성 유지
- 데이터 무결성 보장
- 동시성 제어
- 오류 발생 시 롤백 기능 제공

## ACID 원칙

트랜잭션은 4가지 핵심 특성(ACID)을 따릅니다:

### 1. 원자성 (Atomicity)

- 트랜잭션의 모든 작업은 전체가 성공하거나 전체가 실패해야 함
- 일부만 성공하는 것을 허용하지 않음

### 2. 일관성 (Consistency)

- 트랜잭션 실행 전후 데이터베이스의 일관된 상태 유지
- 미리 정의된 규칙을 항상 만족해야 함

### 3. 고립성 (Isolation)

- 동시에 실행되는 트랜잭션들이 서로 영향을 미치지 않음
- 한 트랜잭션의 중간 상태를 다른 트랜잭션이 볼 수 없음

### 4. 지속성 (Durability)

- 트랜잭션 완료 후 그 결과가 영구적으로 보장됨
- 시스템 장애 발생해도 커밋된 데이터는 유지됨

## 트랜잭션 사용 예시

### 기본적인 트랜잭션 사용

```java
@Service
public class AccountService {
    @PersistenceContext
    private EntityManager entityManager;

    @Transactional
    public void transferMoney(Long fromAccountId, Long toAccountId, BigDecimal amount) {
        try {
            // 1. 출금 계좌 조회
            Account fromAccount = entityManager.find(Account.class, fromAccountId);
            
            // 2. 입금 계좌 조회
            Account toAccount = entityManager.find(Account.class, toAccountId);
            
            // 3. 계좌 이체 로직
            fromAccount.withdraw(amount);
            toAccount.deposit(amount);
            
            // 트랜잭션 종료 시 자동 커밋
            // 중간에 예외 발생하면 자동 롤백
        } catch (InsufficientBalanceException e) {
            // 명시적 롤백 또는 예외 처리
            throw new RuntimeException("이체 실패", e);
        }
    }
}
```

### 수동 트랜잭션 관리

```java
public void manualTransactionManagement() {
    EntityTransaction transaction = entityManager.getTransaction();
    
    try {
        // 트랜잭션 시작
        transaction.begin();
        
        // 데이터베이스 작업 수행
        Member member = new Member();
        member.setName("홍길동");
        entityManager.persist(member);
        
        // 트랜잭션 커밋
        transaction.commit();
    } catch (Exception e) {
        // 예외 발생 시 롤백
        if (transaction.isActive()) {
            transaction.rollback();
        }
        throw new RuntimeException("작업 중 오류 발생", e);
    }
}
```

## 트랜잭션 전파 옵션

### @Transactional 옵션

```java
@Transactional(propagation = Propagation.REQUIRED)
public void requiredTransaction() {
    // 기존 트랜잭션이 있으면 그 트랜잭션에 참여
    // 없으면 새로운 트랜잭션 시작
}

@Transactional(propagation = Propagation.REQUIRES_NEW)
public void requiresNewTransaction() {
    // 항상 새로운 트랜잭션 시작
    // 기존 트랜잭션 있으면 일시 중단
}
```

## 격리 수준 설정

```java
@Transactional(isolation = Isolation.READ_COMMITTED)
public void readCommittedMethod() {
    // 커밋된 데이터만 읽기 허용
}
```

## 트랜잭션 롤백 조건

```java
@Transactional(
    rollbackFor = {SQLException.class, RuntimeException.class},
    noRollbackFor = {BusinessException.class}
)
public void complexTransactionalMethod() {
    // 특정 예외에 대해 롤백 여부 세부 설정
}
```

## 주의사항

### 성능 고려사항

- 트랜잭션 범위를 최소한으로 유지
- 불필요하게 긴 트랜잭션은 데이터베이스 성능 저하 가능

### 일반적인 실수

- 너무 큰 단위의 트랜잭션
- 트랜잭션 내 과도한 로직 포함
- 예외 처리 미흡

## 결론

트랜잭션은 데이터베이스 작업의 신뢰성과 일관성을 보장하는 핵심 메커니즘입니다. 적절히 설계하고 관리함으로써 안정적인 데이터 처리를 할 수 있습니다.