## 기본 사용 예시

```java
@Service
@Transactional
public class UserService {
    @Autowired
    private UserRepository userRepository;

    public void updateUserName(Long userId, String newName) {
        // 엔티티 조회
        User user = userRepository.findById(userId)
            .orElseThrow(() -> new EntityNotFoundException("사용자를 찾을 수 없습니다."));
        
        // 엔티티 상태 변경
        user.setName(newName);
        // dirty checking으로 인해 자동 업데이트
    }
}
```

## 복합 필드 변경 예시
```java
@Entity
public class Member {
    @Id
    private Long id;
    private String name;
    private int age;
    private String email;

    // getter, setter 생략
}

@Service
@Transactional
public class MemberService {
    @Autowired
    private MemberRepository memberRepository;

    public void updateMemberInfo(Long memberId, String newName, int newAge) {
        Member member = memberRepository.findById(memberId)
            .orElseThrow(() -> new EntityNotFoundException("회원을 찾을 수 없습니다."));
        
        // 여러 필드 동시 변경 가능
        member.setName(newName);
        member.setAge(newAge);
        // 두 필드 모두 자동으로 UPDATE 쿼리 생성
    }
}
```

## 연관관계 엔티티 변경 예시
```java
@Entity
public class Order {
    @Id
    private Long id;
    
    @ManyToOne
    private Member member;
    
    private String status;

    // getter, setter 생략
}

@Service
@Transactional
public class OrderService {
    @Autowired
    private OrderRepository orderRepository;
    @Autowired
    private MemberRepository memberRepository;

    public void changeOrderMember(Long orderId, Long newMemberId) {
        Order order = orderRepository.findById(orderId)
            .orElseThrow(() -> new EntityNotFoundException("주문을 찾을 수 없습니다."));
        
        Member newMember = memberRepository.findById(newMemberId)
            .orElseThrow(() -> new EntityNotFoundException("회원을 찾을 수 없습니다."));
        
        // 연관관계 엔티티 변경
        order.setMember(newMember);
        // 연관관계 변경도 dirty checking으로 자동 반영
    }
}
```

## 주의할 점

- `@Transactional` 어노테이션 내에서만 Dirty Checking이 작동합니다.
- 영속성 컨텍스트에서 관리되는 엔티티에 대해서만 적용됩니다.
- 너무 많은 필드 변경은 성능에 영향을 줄 수 있으므로 주의가 필요합니다.

## 성능 최적화 팁

- 불필요한 setter 호출을 최소화하세요.
- 가능한 한 엔티티의 상태 변경을 최소화하세요.
- 대량의 데이터 업데이트 시에는 벌크 연산을 고려하세요.