## Dirty Checking이란?

Dirty Checking(더티 체킹)은 JPA(Java Persistence API)에서 엔티티의 상태 변경을 자동으로 감지하고 데이터베이스에 반영하는 메커니즘입니다. 이는 JPA의 핵심 기능 중 하나로, 개발자가 명시적으로 update 쿼리를 작성하지 않아도 엔티티의 변경 사항을 데이터베이스에 자동으로 동기화합니다.

## 작동 원리

1. **엔티티 상태 추적**
    - JPA는 영속성 컨텍스트에서 엔티티의 초기 상태를 스냅샷으로 저장합니다.
    - 트랜잭션 커밋 시점에 현재 엔티티 상태와 최초 상태를 비교합니다.
2. **변경 감지**
    - 엔티티의 필드 값이 최초 상태와 다르면 해당 엔티티는 "더티(Dirty)" 상태로 간주됩니다.
    - 변경된 필드에 대해 자동으로 UPDATE 쿼리를 생성합니다.

## 주요 특징

- **자동성**: 개발자의 명시적 update 호출 없이 상태 변경을 감지합니다.
- **효율성**: 변경된 필드만 선택적으로 업데이트합니다.
- **트랜잭션 커밋 시점**: 실제 데이터베이스 업데이트는 트랜잭션이 커밋되는 시점에 발생합니다.

## 예시 코드
```java
@Transactional
public void updateUser() {
    User user = entityManager.find(User.class, 1L);
    // 이 시점에 user 객체의 상태 변경을 JPA가 자동으로 감지
    user.setName("변경된 이름");
    // 메서드 종료 시 트랜잭션 커밋, 자동으로 UPDATE 쿼리 실행
}
```

## 장점

- 코드의 간결성
- 반복적인 update 로직 작성 불필요
- 데이터베이스 업데이트의 자동화

## 더티체킹을 주로 사용하는 경우

1. 필드 수가 적은 엔티티
2. 읽기 작업이 많은 시스템
3. 부분 업데이트가 필요한 상황
4. 간단한 CRUD 연산
5. 트랜잭션 내 단일 엔티티 수정

핵심은 성능과 코드 간결성 사이의 균형

## 더티체킹을 사용하지 않는 경우

1. 대량의 필드 업데이트
2. 대량 데이터 처리
3. 복잡한 비즈니스 로직이 필요한 업데이트
4. 성능에 민감한 대규모 시스템
5. 벌크 업데이트가 필요한 경우
6. 복합 엔티티 수정
7. 성능 최적화가 중요한 시스템
#### 주요 대안

- 벌크 업데이트 쿼리
- 명시적 save() 호출
- 동적 업데이트 메서드