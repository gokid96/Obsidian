# 스프링 프레임워크 흐름과 예제

## 스프링 MVC 기본 흐름

**1. 클라이언트 요청**

- 사용자가 웹 브라우저에서 URL을 통해 요청을 보냄

```
GET /users/list
```

**2. DispatcherServlet**

- 모든 요청을 받는 프론트 컨트롤러 역할
- 요청을 적절한 컨트롤러로 분배

```xml
<servlet>
    <servlet-name>dispatcher</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
</servlet>
```

**3. HandlerMapping**

- URL과 컨트롤러 메서드를 매핑
- 어떤 컨트롤러가 요청을 처리할지 결정

```java
@RequestMapping("/users/list")
```

**4. Controller**

- 비즈니스 로직을 처리하는 컨트롤러
- 요청을 받아 Service 계층으로 전달

### 전통적인 MVC 방식 (HTTP 메서드 지정 안 함)

```java
@Controller
public class UserController {
    @Autowired
    private UserService userService;
    
    // HTTP 메서드 지정 안 함 - 모든 메서드를 허용
    @RequestMapping("/users/list")
    public String getUserList(Model model) {
        List<User> users = userService.getAllUsers();
        model.addAttribute("users", users);
        return "userList";
    }
}
```
- `@RequestMapping`에서 `method`를 지정하지 않으면 모든 HTTP 메서드를 허용한다.
- 예전에는 이게 일반적이라 "전통적 방식"이라고 불린다.
- 요즘은 `@GetMapping`, `@PostMapping` 등 명확히 HTTP 메서드를 지정하는 방식이 권장된다.

### 현대적인 MVC 방식 (HTTP 메서드 지정)

```java
@Controller
@RequestMapping("/users")  // 클래스 레벨
public class UserController {

    @Autowired
    private UserService userService;
    
    @GetMapping("/list")     // GET /users/list (신식)
    public String getUserList(Model model) {
        List<User> users = userService.getAllUsers();
        model.addAttribute("users", users);
        return "userList";
    }
    
    @GetMapping("/new")      // 등록 폼 보여주기
    public String newUserForm(Model model) {
        model.addAttribute("user", new User());
        return "userForm";
    }
    
    @PostMapping           // POST /users (등록 처리)
    public String createUser(@ModelAttribute User user) {
        userService.createUser(user);
        return "redirect:/users/list";
    }
    
    @GetMapping("/{id}")     // GET /users/1 (상세 조회)
    public String getUserDetail(@PathVariable Long id, Model model) {
        User user = userService.getUserById(id);
        model.addAttribute("user", user);
        return "userDetail";
    }
}
```

### HTTP 메서드를 지정하는 이유

- **전통적인 방식**: URL로만 구분 (`/users/create`, `/users/update`, `/users/delete`)
- **REST 방식**: HTTP 메서드로 구분하여 URL을 간결하게 유지
    - `GET /users` - 목록 조회
    - `POST /users` - 생성
    - `GET /users/{id}` - 상세 조회
    - `PUT /users/{id}` - 수정
    - `DELETE /users/{id}` - 삭제

**5. Service**
- 비즈니스 로직을 구현하는 서비스 계층
- 트랜잭션 관리와 복잡한 비즈니스 규칙 처리

```java
@Service
public class UserService {
    @Autowired
    private UserDAO userDAO;
    
    @Transactional
    public List<User> getAllUsers() {
        return userDAO.selectAllUsers();
    }
    
    @Transactional
    public void createUser(User user) {
        userDAO.insertUser(user);
    }
    
    public User getUserById(Long id) {
        return userDAO.selectUserById(id);
    }
}
```

**6. DAO (Data Access Object)**
- 데이터베이스 접근을 담당하는 계층
- CRUD 작업을 수행

```java
@Repository
public class UserDAO {
    @Autowired
    private SqlSession sqlSession;
    
    public List<User> selectAllUsers() {
        return sqlSession.selectList("user.selectAllUsers");
    }
    
    public void insertUser(User user) {
        sqlSession.insert("user.insertUser", user);
    }
    
    public User selectUserById(Long id) {
        return sqlSession.selectOne("user.selectUserById", id);
    }
}
```

**7. Database**

- 실제 데이터가 저장되는 데이터베이스
- DAO를 통해 데이터 조회/수정

```sql
SELECT * FROM users ORDER BY name;
INSERT INTO users (name, email) VALUES (?, ?);
SELECT * FROM users WHERE id = ?;
```

**8. Model**

- 처리된 데이터를 담는 객체
- View에 전달될 데이터를 포함

```java
public class User {
    private Long id;
    private String name;
    private String email;
    
    // 생성자, getter, setter
    public User() {}
    
    public User(String name, String email) {
        this.name = name;
        this.email = email;
    }
    
    // getter, setter 메서드들...
}
```

**9. ViewResolver**

- 컨트롤러가 반환한 뷰 이름을 실제 뷰 파일과 매핑

```java
@Bean
public InternalResourceViewResolver viewResolver() {
    InternalResourceViewResolver resolver = new InternalResourceViewResolver();
    resolver.setPrefix("/WEB-INF/views/");
    resolver.setSuffix(".jsp");
    return resolver;
}
// "userList" → "/WEB-INF/views/userList.jsp"
```

**10. View**

- 사용자에게 보여질 화면을 생성 (JSP, Thymeleaf 등)

```jsp
<%@ page contentType="text/html;charset=UTF-8" %>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<html>
<body>
    <h1>사용자 목록</h1>
    <c:forEach items="${users}" var="user">
        <p>${user.name} - ${user.email}</p>
    </c:forEach>
    <a href="/users/new">새 사용자 등록</a>
</body>
</html>
```

**11. 응답 반환**

- 최종적으로 생성된 HTML이 클라이언트에게 전송

```html
<html>
<body>
    <h1>사용자 목록</h1>
    <p>김철수 - kim@example.com</p>
    <p>이영희 - lee@example.com</p>
    <a href="/users/new">새 사용자 등록</a>
</body>
</html>
```

## 스프링 REST API 흐름 (JSON 응답)

**1. 클라이언트 요청**

- REST 클라이언트(앱, AJAX, Postman 등)에서 HTTP 요청

```javascript
// GET 요청
fetch('/api/users')
    .then(response => response.json())
    .then(data => console.log(data));

// POST 요청
fetch('/api/users', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ name: '김철수', email: 'kim@example.com' })
});
```

**2. DispatcherServlet**

- 모든 요청을 받는 프론트 컨트롤러

```
GET /api/users
Accept: application/json
Content-Type: application/json
```

**3. HandlerMapping**

- URL과 REST 컨트롤러 매핑

```java
@RequestMapping("/api/users")
// 또는 신식
@GetMapping("/api/users")
@PostMapping("/api/users")
```

**4. RestController (@RestController)**

- `@RestController` 또는 `@Controller + @ResponseBody`
- HTTP 요청을 받아 처리

### 구식 방식 (거의 사용 안 함)

```java
@RestController
@RequestMapping("/api")
public class UserRestController {
    @Autowired
    private UserService userService;
    
    // 구식 - 길고 복잡 (5% 미만 사용)
    @RequestMapping(value = "/users", method = RequestMethod.GET)
    public ResponseEntity<List<UserDTO>> getUsersOld() {
        List<UserDTO> users = userService.getAllUsersAsDTO();
        return ResponseEntity.ok(users);
    }
    
    @RequestMapping(value = "/users", method = RequestMethod.POST)
    public ResponseEntity<UserDTO> createUserOld(@RequestBody UserDTO userDTO) {
        UserDTO createdUser = userService.createUser(userDTO);
        return ResponseEntity.status(HttpStatus.CREATED).body(createdUser);
    }
}
```

### 신식 방식 (현재 표준 - 95% 이상 사용)

```java
@RestController
@RequestMapping("/api")
public class UserRestController {
    @Autowired
    private UserService userService;
    
    // 신식 - 짧고 명확
    @GetMapping("/users")
    public ResponseEntity<List<UserDTO>> getUsers() {
        List<UserDTO> users = userService.getAllUsersAsDTO();
        return ResponseEntity.ok(users);
    }
    
    @PostMapping("/users")
    public ResponseEntity<UserDTO> createUser(@RequestBody UserDTO userDTO) {
        UserDTO createdUser = userService.createUser(userDTO);
        return ResponseEntity.status(HttpStatus.CREATED).body(createdUser);
    }
    
    @GetMapping("/users/{id}")
    public ResponseEntity<UserDTO> getUser(@PathVariable Long id) {
        UserDTO user = userService.getUserById(id);
        return ResponseEntity.ok(user);
    }
    
    @PutMapping("/users/{id}")
    public ResponseEntity<UserDTO> updateUser(@PathVariable Long id, @RequestBody UserDTO userDTO) {
        UserDTO updatedUser = userService.updateUser(id, userDTO);
        return ResponseEntity.ok(updatedUser);
    }
    
    @DeleteMapping("/users/{id}")
    public ResponseEntity<Void> deleteUser(@PathVariable Long id) {
        userService.deleteUser(id);
        return ResponseEntity.noContent().build();
    }
}
```

### @RestController vs @Controller + @ResponseBody

```java
// 방법 1: @RestController (권장)
@RestController
public class UserRestController {
    @GetMapping("/api/users")
    public List<User> getUsers() {
        return userService.getAllUsers();  // 자동으로 JSON 변환
    }
}

// 방법 2: @Controller + @ResponseBody (같은 효과)
@Controller
public class UserController {
    @GetMapping("/api/users")
    @ResponseBody  // 이 어노테이션이 있으면 JSON 변환
    public List<User> getUsers() {
        return userService.getAllUsers();
    }
}
```

**5. Service**

- 비즈니스 로직 처리
- 트랜잭션 관리

```java
@Service
public class UserService {
    @Autowired
    private UserRepository userRepository;
    
    public List<UserDTO> getAllUsersAsDTO() {
        List<User> users = userRepository.findAll();
        return users.stream()
                   .map(this::convertToDTO)
                   .collect(Collectors.toList());
    }
    
    public UserDTO createUser(UserDTO userDTO) {
        User user = convertToEntity(userDTO);
        User savedUser = userRepository.save(user);
        return convertToDTO(savedUser);
    }
    
    private UserDTO convertToDTO(User user) {
        UserDTO dto = new UserDTO();
        dto.setId(user.getId());
        dto.setName(user.getName());
        dto.setEmail(user.getEmail());
        return dto;
    }
    
    private User convertToEntity(UserDTO dto) {
        User user = new User();
        user.setName(dto.getName());
        user.setEmail(dto.getEmail());
        return user;
    }
}
```

**6. DAO/Repository**

- 데이터베이스 접근
- JPA Repository, MyBatis 등 사용

```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    // 기본 CRUD 메서드 자동 제공: findAll(), save(), findById(), deleteById() 등
    
    // 커스텀 쿼리 메서드
    List<User> findByNameContaining(String name);
    List<User> findByEmail(String email);
    
    @Query("SELECT u FROM User u WHERE u.active = true")
    List<User> findActiveUsers();
    
    @Query("SELECT u FROM User u WHERE u.name LIKE %:name%")
    List<User> findByNameLike(@Param("name") String name);
}
```

**7. Database**
- 실제 데이터 저장소
```sql
-- JPA가 자동 생성하는 쿼리들
SELECT u.id, u.name, u.email FROM users u WHERE u.active = true;
INSERT INTO users (name, email, active) VALUES (?, ?, ?);
SELECT u.id, u.name, u.email FROM users u WHERE u.id = ?;
UPDATE users SET name = ?, email = ? WHERE id = ?;
DELETE FROM users WHERE id = ?;
```

**8. Entity/DTO**
- 데이터를 담는 객체
- 데이터베이스 엔티티 또는 데이터 전송 객체
```java
// Entity - 데이터베이스 테이블과 매핑
@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false)
    private String name;
    
    @Column(nullable = false, unique = true)
    private String email;
    
    @Column(name = "is_active")
    private boolean active = true;
    
    @CreationTimestamp
    private LocalDateTime createdAt;
    
    // 생성자, getter, setter...
}

// DTO - 데이터 전송용 객체 (민감한 정보 제외)
public class UserDTO {
    private Long id;
    private String name;
    private String email;
    // active, createdAt 등 내부 정보는 제외
    
    // 생성자, getter, setter...
}
```

**9. HttpMessageConverter**
- 객체를 JSON으로 자동 변환
- Jackson 라이브러리가 주로 사용됨
```java
// 스프링이 자동으로 설정하지만, 커스터마이징 가능
@Configuration
public class WebConfig implements WebMvcConfigurer {
    @Bean
    public MappingJackson2HttpMessageConverter jsonMessageConverter() {
        MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();
        
        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
        objectMapper.setPropertyNamingStrategy(PropertyNamingStrategies.SNAKE_CASE);
        converter.setObjectMapper(objectMapper);
        
        return converter;
    }
}
```

**10. JSON 응답**

- HTTP Response Body에 JSON 데이터 포함하여 클라이언트에 전송

```json
// GET /api/users 응답
{
  "status": 200,
  "data": [
    {
      "id": 1,
      "name": "김철수",
      "email": "kim@example.com"
    },
    {
      "id": 2,
      "name": "이영희", 
      "email": "lee@example.com"
    }
  ]
}

// POST /api/users 응답
{
  "status": 201,
  "data": {
    "id": 3,
    "name": "박민수",
    "email": "park@example.com"
  },
  "message": "사용자가 성공적으로 생성되었습니다."
}

// 에러 응답
{
  "status": 400,
  "error": "Bad Request",
  "message": "이메일 형식이 올바르지 않습니다.",
  "timestamp": "2025-09-12T10:30:00"
}
```

## 주요 차이점

### View vs JSON 응답
```java
// MVC - View 반환
@Controller
public class UserController {
    @GetMapping("/users")
    public String getUsers(Model model) {
        List<User> users = userService.getAllUsers();
        model.addAttribute("users", users);
        return "userList";  // userList.html 템플릿을 찾음
    }
}

// REST - 객체 반환 (자동으로 JSON 변환)
@RestController
public class UserRestController {
    @GetMapping("/api/users")
    public ResponseEntity<List<User>> getUsers() {
        List<User> users = userService.getAllUsers();
        return ResponseEntity.ok(users);  // JSON으로 자동 변환
    }
}ㅋ
```

### @ResponseBody의 역할
```java
@Controller
public class UserController {
    // @ResponseBody 없음 - 뷰 이름으로 해석
    @RequestMapping("/users")
    public String getUsers() {
        return "userList";  // templates/userList.html 파일을 찾음
    }
    
    // @ResponseBody 있음 - 문자열 직접 반환
    @RequestMapping("/api/users/count")
    @ResponseBody
    public String getUserCount() {
        return "총 사용자 수: 150명";  // 브라우저에 텍스트 직접 출력
    }
    
    // @ResponseBody + 객체 - JSON 반환
    @RequestMapping("/api/users")
    @ResponseBody
    public List<User> getUsersJson() {
        return userService.getAllUsers();  // JSON 배열로 변환
    }
}

// @RestController 사용 시 - 모든 메서드에 자동으로 @ResponseBody 적용
@RestController
public class UserRestController {
    @GetMapping("/api/users")
    public List<User> getUsers() {
        return userService.getAllUsers();  // 자동으로 JSON 변환
    }
}
```

### 자동 직렬화 예시

```java
// 이 객체가
User user = new User(1L, "김철수", "kim@example.com");
List<User> users = Arrays.asList(user, new User(2L, "이영희", "lee@example.com"));

// 자동으로 이렇게 변환됨
[
  {
    "id": 1,
    "name": "김철수",
    "email": "kim@example.com"
  },
  {
    "id": 2,
    "name": "이영희",
    "email": "lee@example.com"
  }
]
```

## HTTP 메서드 사용 패턴 변화

### 전통적인 MVC (예전 방식)

```java
@Controller
public class UserController {
    // HTTP 메서드 지정 안 함 - 간단한 웹사이트에서 주로 사용
    @RequestMapping("/users/list")        // 목록
    @RequestMapping("/users/create")      // 생성
    @RequestMapping("/users/update")      // 수정  
    @RequestMapping("/users/delete")      // 삭제
    
    // 장점: 간단함, 이해하기 쉬움
    // 단점: URL이 길어짐, REST 원칙에 어긋남
}
```

### 현대적인 방식 (현재 표준)

```java
@Controller // 또는 @RestController
@RequestMapping("/users")
public class UserController {
    // HTTP 메서드로 구분 - 현재 표준
    @GetMapping                    // GET /users (목록)
    @PostMapping                   // POST /users (생성)
    @GetMapping("/{id}")          // GET /users/1 (조회)
    @PutMapping("/{id}")          // PUT /users/1 (수정)
    @DeleteMapping("/{id}")       // DELETE /users/1 (삭제)
    
    // 장점: REST 원칙 준수, URL 간결, 국제 표준
    // 단점: 초기 학습 곡선 존재
}
```

### 현재 실무에서는?

- **MVC 프로젝트**: 두 방식 혼재 (기존 코드는 구식, 새 코드는 신식)
- **REST API**: 거의 100% 신식 방법 사용
- **신규 프로젝트**: 무조건 신식 방법 권장

