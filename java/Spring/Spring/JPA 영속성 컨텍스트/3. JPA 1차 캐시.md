## 1차 캐시의 개념

1차 캐시는 영속성 컨텍스트 내부에 존재하는 메모리 공간으로, JPA의 성능 최적화를 위한 중요한 메커니즘입니다.

### 주요 특징

- 엔티티를 메모리에 저장
- 데이터베이스 접근 횟수 최소화
- 트랜잭션 범위 내에서 유효

## 1차 캐시의 작동 원리

### 조회 과정

1. 엔티티 조회 요청
2. 1차 캐시에서 먼저 확인
3. 캐시에 없으면 데이터베이스 조회
4. 조회된 엔티티를 1차 캐시에 저장

```java
// 1차 캐시 조회 예시
@Transactional
public void firstLevelCacheDemo() {
    // 최초 조회 - 데이터베이스 쿼리 실행
    Member member1 = entityManager.find(Member.class, 1L);
    
    // 동일 엔티티 재조회 - 1차 캐시에서 조회
    Member member2 = entityManager.find(Member.class, 1L);
    
    // member1 == member2 (동일성 보장)
    System.out.println(member1 == member2); // true
}
```

### 캐시 구조

- 키: 엔티티의 식별자 (Primary Key)
- 값: 엔티티 객체 전체
- 엔티티 상태의 스냅샷도 함께 저장

## 1차 캐시의 주요 이점

### 성능 최적화

- 반복적인 데이터베이스 조회 방지
- 불필요한 데이터베이스 왕복 최소화

### 트랜잭션 일관성

- 동일 트랜잭션 내 동일 엔티티의 일관된 상태 보장
- 변경 감지(Dirty Checking) 기능 지원

## 1차 캐시 사용 예제

java

```java
@Service
public class MemberService {
    @PersistenceContext
    private EntityManager entityManager;

    @Transactional
    public void demonstrateCaching() {
        // 1. 최초 조회 - 데이터베이스 쿼리 실행
        Member member = entityManager.find(Member.class, 1L);
        
        // 2. 동일 엔티티 재조회 - 1차 캐시에서 즉시 반환
        Member cachedMember = entityManager.find(Member.class, 1L);
        
        // 3. 엔티티 상태 변경 - 1차 캐시 내 스냅샷과 비교
        member.setName("Updated Name");
        // 트랜잭션 커밋 시 변경 감지
    }
}
```

## 제한사항 및 주의사항

### 범위와 수명

- 트랜잭션 범위에서만 유효
- 트랜잭션 종료 시 1차 캐시도 함께 삭제

### 메모리 관리

- 과도한 엔티티 적재 시 메모리 부하 가능
- 대량 데이터 처리 시 `clear()` 메서드로 캐시 초기화 필요

### 캐시 무효화

java

```java
// 1차 캐시 초기화
entityManager.clear();

// 특정 엔티티만 캐시에서 제거
entityManager.detach(member);
```

## 성능 최적화 팁

### 배치 처리

java

```java
@Transactional
public void bulkInsert() {
    for (int i = 0; i < 100; i++) {
        Member member = new Member();
        entityManager.persist(member);
        
        // 일정 주기로 flush and clear
        if (i % 20 == 0) {
            entityManager.flush();
            entityManager.clear();
        }
    }
}
```

## 결론

1차 캐시는 JPA의 핵심 최적화 메커니즘으로, 적절히 활용하면 애플리케이션의 성능을 크게 향상시킬 수 있습니다. 하지만 무분별한 사용은 오히려 메모리 부하를 초래할 수 있으므로 신중하게 접근해야 합니다.