
## 요약
- 로직 수행 후 변경사항 확인
- 충돌 발생 가능성을 사후에 검증
- 동시성 처리에서 충돌 가능성이 낮다고 가정
- 성능 오버헤드가 낮음
- 읽기 작업이 많고 쓰기 작업이 적은 시스템에 적합

## 낙관적 락 개요

낙관적 락은 동시성 제어를 위한 메커니즘으로, 데이터 충돌이 거의 발생하지 않을 것이라고 
'낙관적으로' 가정하는 동시성 제어 방식

### 핵심 개념

- 데이터 수정 시 충돌 가능성을 최소화
- 충돌 발생 시 예외를 통해 처리
- 데이터베이스 락을 사용하지 않음

## JPA에서의 낙관적 락 구현

### 1. @Version 어노테이션 사용

```java
@Entity
public class Product {
    @Id
    private Long id;
    
    private String name;
    
    private BigDecimal price;
    
    // 버전 관리를 위한 필드
    @Version
    private Long version;
}
```

### 2. 낙관적 락 동작 원리

```java
@Service
public class ProductService {
    @PersistenceContext
    private EntityManager entityManager;

    @Transactional
    public void updateProductPrice(Long productId, BigDecimal newPrice) {
        Product product = entityManager.find(Product.class, productId);
        
        // 동시 수정 시도 시 예외 발생
        product.setPrice(newPrice);
        // 트랜잭션 커밋 시점에 버전 충돌 확인
    }
}
```

## 낙관적 락의 상세 동작 과정

### 조회 및 수정 시나리오

1. 사용자 A가 상품 조회 (version: 1)
2. 사용자 B도 같은 상품 조회 (version: 1)
3. 사용자 A가 가격 변경 (version: 2로 증가)
4. 사용자 B도 가격 변경 시도
    - 이미 version이 2로 변경됨
    - OptimisticLockException 발생

## JPA 락 모드 설정

### 락 모드 종류

```java
@Service
public class ProductService {
    @PersistenceContext
    private EntityManager entityManager;

    // 기본 낙관적 락
    public Product findWithOptimisticLock(Long id) {
        return entityManager.find(
            Product.class, 
            id, 
            LockModeType.OPTIMISTIC
        );
    }

    // 강력한 버전 확인
    public Product findWithOptimisticForceIncrement(Long id) {
        return entityManager.find(
            Product.class, 
            id, 
            LockModeType.OPTIMISTIC_FORCE_INCREMENT
        );
    }
}
```

## 복잡한 낙관적 락 사용 예시

### 동시성 제어를 포함한 서비스 로직

```java
@Service
public class StockService {
    @PersistenceContext
    private EntityManager entityManager;

    @Transactional
    public void decreaseStock(Long productId, int quantity) {
        Product product = entityManager.find(
            Product.class, 
            productId, 
            LockModeType.OPTIMISTIC
        );

        try {
            if (product.getStockQuantity() >= quantity) {
                product.decreaseStock(quantity);
            } else {
                throw new InsufficientStockException("재고 부족");
            }
        } catch (OptimisticLockException e) {
            // 동시성 충돌 처리
            throw new ConcurrentModificationException("재고 변경 중 충돌 발생");
        }
    }
}
```

## 낙관적 락의 장단점

### 장점

- 성능 오버헤드 최소화
- 데이터베이스 락 미사용
- 읽기 작업이 많은 시스템에 적합

### 단점

- 충돌 발생 시 재시도 로직 필요
- 동시성 충돌 빈번한 환경에서는 비효율적

## 재시도 메커니즘 구현

```java
@Service
public class RetryableStockService {
    @Transactional
    public void decreaseStockWithRetry(Long productId, int quantity) {
        int maxRetries = 3;
        
        for (int attempt = 0; attempt < maxRetries; attempt++) {
            try {
                decreaseStock(productId, quantity);
                return; // 성공 시 종료
            } catch (OptimisticLockException e) {
                if (attempt == maxRetries - 1) {
                    throw new ConcurrentModificationException("재고 변경 실패");
                }
                // 잠시 대기 후 재시도
                try {
                    Thread.sleep(100);
                } catch (InterruptedException ie) {
                    Thread.currentThread().interrupt();
                    throw new RuntimeException("재시도 중단", ie);
                }
            }
        }
    }
}
```

## 주의사항

### 성능 고려사항

- 과도한 낙관적 락 사용 주의
- 충돌 가능성 높은 엔티티에 선택적 적용

### 트랜잭션 설계

- 충돌 처리 전략 명확히 설계
- 재시도 로직의 적절한 구현

## 결론

낙관적 락은 동시성 제어를 위한 효과적인 메커니즘으로, 데이터 일관성을 유지하면서 성능을 최적화할 수 있음 시스템의 특성과 요구사항을 고려하여 신중하게 적용해야 함