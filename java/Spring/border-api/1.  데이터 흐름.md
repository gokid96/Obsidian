  
  
  **DB (테이블) 
	  ↕️ 
  Repository (항상 Entity로 통신) 
	  ↕️ 
  Service (Entity → DTO 변환)
	  ↕️ 
  Controller (DTO로 응답) 
	  ↕️ 
  Client (JSON)**
  
  
**왜 이렇게 설계?**
1. **Repository의 역할**: DB 데이터 ↔ Entity 매핑 (JPA/Hibernate가 처리)
2. **Entity의 역할**: DB 테이블과 1:1 매칭
3. **Service의 역할**: 비즈니스 로직 + Entity → DTO 변환
4. **DTO의 역할**: API 응답에 필요한 데이터만 담기

그래서 Repository에서 꺼낸 Entity를 Service 계층에서 DTO로 변환

**1. Repository → Entity만 사용하는 이유**
- JPA/Hibernate는 Entity 클래스를 통해 DB와 매핑
- Repository는 "DB 접근 계층"이므로 DB 구조(Entity)만 알아야 함
- DTO를 Repository에서 사용하면 DB 계층이 API 응답 형식까지 알게 되어 결합도 증가

**2. Service에서 Entity → DTO 변환하는 이유**
- **보안**: Entity의 모든 필드(비밀번호, 내부 ID 등)를 클라이언트에 노출하면 안 됨
- **유연성**: 같은 Entity라도 API마다 다른 형태로 응답 가능

```java
  // 목록 조회: 간단한 정보만
  UserListDTO 
  
  // 상세 조회: 모든 정보
  UserDetailDTO
```
- **변경 영향 최소화**: DB 테이블 변경해도 DTO만 조정하면 API는 그대로 유지 가능

**3. Controller → DTO만 사용하는 이유**
- Entity를 직접 반환하면:
  - 지연 로딩(Lazy Loading) 문제 발생 가능
  - 순환 참조 문제 (Entity 간 양방향 관계시)
  - 불필요한 데이터 노출

## 정리
```
DB 관심사 (Entity) ←→ 비즈니스 로직 (Service) ←→ API 관심사 (DTO)
````

```
1. Entity (DB 테이블 구조 이해)
		↓ 
2. Repository (데이터 접근 이해)
		↓ 
3. DTO (데이터 전송 객체 이해) 
		↓ 
4. Service (비즈니스 로직 이해)
		↓ 
5. Controller (API 완성)
```
1. **Entity**        = DB 테이블 구조 정의 (컬럼, 관계 등)
2. **Repository** = Entity로 DB에 CRUD 작업 정의 (JPA 메서드/쿼리)
3. **DTO**          = API 요청/응답에 필요한 필드-만 담는 객체
4. **Service**      = **비즈니스 로직 처리** + Entity ↔ DTO 변환
5. **Controller**  = HTTP 요청 받아서 Service에 위임하고 응답 반환

