###  초기 아키텍처

```
[사용자]
   ↓
[Route53 DNS]
   ↓
[EC2 단일 서버]
 ├─ Nginx (80/443 → 8080 프록시)
 ├─ Spring Boot (8080)
 └─ MySQL (3306)
```

###  단계별 진화 로드맵

**1단계: 단일 서버 + 기본 최적화**

- DB 인덱스 설계 (WHERE, JOIN 대상)
- N+1 쿼리 해결 (Fetch Join)
- Connection Pool 설정 (HikariCP)
- **병목 측정**: 느린 쿼리 로그, API 응답시간

**2단계: 정적 파일 분리 (S3 + CloudFront)**

- 이미지/CSS/JS를 S3로 이동
- CloudFront CDN 연결
- **효과**: 서버 대역폭 50% 이상 절감

**3단계: DB 분리**

- MySQL을 별도 EC2 또는 RDS로 이동
- VPC 내부 통신 설정
- **효과**: CPU/메모리 리소스 경합 해소

**4단계: 캐시 도입 (Redis)**

- 게시글 목록, 조회수/좋아요 캐싱
- Look-Aside 패턴 적용
- TTL 전략 수립
- **효과**: DB 쿼리 80% 감소
- -----
**5단계: Read Replica 추가**

- Master-Slave 복제 구성
- `@Transactional(readOnly=true)` 라우팅
- **효과**: 읽기 성능 분산

**6단계: 웹서버 Scale Out**

- Application Load Balancer 추가
- Spring Boot 서버 2대 이상
- 세션 문제 해결 (Redis Session or JWT)
- **효과**: 동시 처리량 2배 이상

**7단계: 고급 최적화 (선택)**

- 비동기 처리 (SQS, Kafka)
- DB 샤딩 (정말 필요시)

---

##  각 단계별 필수 문서 (통일된 포맷)
````markdown

### 1. 현재 상황 분석
- 아키텍처 다이어그램
- 모니터링 결과 (CPU, 메모리, 응답시간)
- 병목 지점 식별

### 2. 개선 방안 선택
- 왜 이 방법을 선택했는가?
- 다른 대안과 비교 (장단점)

### 3. 구현 과정
- 인프라 설정 (AWS 콘솔 or Terraform)
- 애플리케이션 코드 변경
- 설정 파일 (application.yml, nginx.conf 등)

### 4. 성능 비교
- Before/After 측정 결과
- 부하 테스트 결과 (JMeter/nGrinder)

### 5. 트레이드오프 & 배운 점
- 비용 증가는 얼마나?
- 복잡도 증가 vs 성능 개선
- 실무 적용 시 주의사항
```

---

##  전략 평가

**잘된 점:**
- 단계별 명확한 목적 있음
- 현실적인 순서 (CDN 먼저, 샤딩 나중)
- 각 단계마다 측정 지표 포함

**약간 조정하면 좋을 점:**

1. **1단계에 "기본 최적화"를 포함시킨 건 탁월!**
   - 인프라 확장 전에 코드 최적화 먼저 하는 게 맞아요

2. **2-4단계는 명확한데, 5-7단계는 선택적**
   - 포트폴리오에서 **1-4단계만 완벽하게** 해도 충분
   - 5단계(Read Replica)부터는 "실제 병목 발생 시" 가정으로

3. **문서 포맷 통일**
   - 제시한 6가지 항목을 모든 단계에 일관되게 적용

---

## 🎯 최종 추천
```
Core (필수): 1-4단계
├─ 완벽한 문서화
├─ 실제 부하테스트 결과
└─ GitHub README로 정리

Advanced (선택): 5-6단계
└─ 시간 여유 있을 때

Expert (참고만): 7단계
└─ 면접에서 "이런 것도 고려했어요" 정도
````