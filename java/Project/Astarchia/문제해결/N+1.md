### N+1 문제란?

1번의 쿼리를 실행한 후, 그 결과 N개를 처리하면서 **추가로 N번의 쿼리**가 발생하는 문제

```
총 쿼리 수 = 1 + N
```


### 발생 원인

JPA의 **Lazy Loading** 때문

```java
// 1번 쿼리: Member 목록 조회
List<Member> members = memberRepository.findAll();

// N번 쿼리: 각 Member의 Team 조회
for (Member member : members) {
    member.getTeam().getName();  // 여기서 쿼리 발생!
}
```

- `findAll()` 실행 → Member만 조회 (Team은 프록시 객체)
- `getTeam()` 접근 시 → 실제 DB 조회 발생
- Member가 100명이면 → Team 조회 100번 추가

### 왜 문제인가?

|상황|쿼리 수|DB 왕복|
|---|---|---|
|Member 10명|1 + 10 = 11번|11번|
|Member 100명|1 + 100 = 101번|101번|
|Member 1000명|1 + 1000 = 1001번|1001번|
- 쿼리 1번에 0.01초라면, 1001번 = **10초 이상**
- 동시 접속자 100명이면 → **10만 번 쿼리**
- DB 과부하 → 서비스 장애

### 해결 방법 3가지

#### 1. Fetch Join (가장 많이 사용)
```java
@Query("SELECT m FROM Member m JOIN FETCH m.team")
List<Member> findAllWithTeam();
```

|장점|단점|
|---|---|
|1번 쿼리로 해결|페이징 불가 (1:N 관계)|
|가장 직관적|2개 이상 컬렉션 동시 fetch 불가|

---

#### 2. @EntityGraph
```java
@EntityGraph(attributePaths = {"team"})
List<Member> findAll();
```

|장점|단점|
|---|---|
|코드가 간결|outer join만 가능|
|어노테이션으로 설정|중복 데이터 발생 가능|

---

#### 3. Batch Size
```yaml
# application.yml
spring:
  jpa:
    properties:
      hibernate:
        default_batch_fetch_size: 100
```

```java
// 또는 엔티티에 직접 설정
@BatchSize(size = 100)
@OneToMany(mappedBy = "member")
private List<Order> orders;
```

|장점|단점|
|---|---|
|페이징 가능|완전한 해결 아님 (N → N/size)|
|설정만 하면 됨|where in 쿼리로 변환|
|Lazy 유지 가능||

**동작 원리**:

```sql
-- 기존: 100번 쿼리
SELECT * FROM team WHERE id = 1;
SELECT * FROM team WHERE id = 2;
...

-- Batch Size 적용 후: 1번 쿼리
SELECT * FROM team WHERE id IN (1, 2, 3, ... 100);
```

---

### 실무 권장 조합

|상황|추천 방법|
|---|---|
|1:1, N:1 관계|Fetch Join|
|1:N 컬렉션 + 페이징 필요|Batch Size|
|간단한 조회|@EntityGraph|
|글로벌 기본 설정|default_batch_fetch_size|

---

### Fetch Join 주의사항

1. **페이징 불가** (1:N 관계)
    - 전체 데이터를 메모리에 올린 후 페이징 → OutOfMemory 위험
2. **2개 이상 컬렉션 동시 fetch 불가**
    - `MultipleBagFetchException` 발생
    - 해결: `List` → `Set`으로 변경 또는 Batch Size 사용
3. **카테시안 곱 발생**
    - 중복 데이터 발생 가능
    - 해결: `distinct` 사용
```java
@Query("SELECT DISTINCT m FROM Member m JOIN FETCH m.orders")
List<Member> findAllWithOrders();
```

---

### 예시 코드

**Before (N+1 발생)**:
```java
public List<WorkspaceResponse> getMyWorkspaces(Long userId) {
    List<WorkspaceMember> members = memberRepository.findAllByUser(user);
    // 1번 쿼리
    
    return members.stream()
        .map(m -> WorkspaceResponse.from(
            m.getWorkspace(),        // N번 쿼리
            m.getWorkspace().getMembers().size()  // N번 쿼리
        ))
        .toList();
}
// 총: 1 + N + N = 2N+1 쿼리
```

**After (Fetch Join)**:
```java
// Repository
@Query("SELECT m FROM WorkspaceMember m " +
       "JOIN FETCH m.workspace w " +
       "JOIN FETCH w.members " +
       "WHERE m.user = :user")
List<WorkspaceMember> findAllByUserWithWorkspaceAndMembers(@Param("user") Users user);

// Service
public List<WorkspaceResponse> getMyWorkspaces(Long userId) {
    List<WorkspaceMember> members = memberRepository.findAllByUserWithWorkspaceAndMembers(user);
    // 1번 쿼리로 전부 가져옴!
    
    return members.stream()
        .map(m -> WorkspaceResponse.from(m.getWorkspace(), m.getRole()))
        .toList();
}
// 총: 1 쿼리
```

---

### 확인 방법
```yaml
# application.yml
spring:
  jpa:
    show-sql: true
    properties:
      hibernate:
        format_sql: true
```

콘솔에서 실제 쿼리 횟수 확인