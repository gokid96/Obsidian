**캡슐화**: 데이터와 메서드를 하나로 묶고, 접근제어자로 외부의 직접 접근을 막는것. 예를들어 필드를 private으로 선언하고 게터/세터로만 접근 허용
```java
// 캡슐화
class Person {
    private String name;  // 직접 접근 불가
    private int age;
    
    public String getName() { return name; }  // getter로만 접근
    public void setName(String name) { this.name = name; }
}
```

**상속**: extends를 통해 부모 클래스의 필드와 메서드를 자식클래스에서 물려받아 재사용하는것
```java
// 상속
class Animal {
    String name;
    void eat() { System.out.println("먹는다"); }
}

class Dog extends Animal {  // Animal의 name, eat() 물려받음
    void bark() { System.out.println("멍멍"); }
}
```

**추상화**: abstract나 interface로 공통기능의 틀만 정의하고 구체적인 구현은 숨기는것. 예를들어 "동물은 소리낸다"만 정의하고 어떻게 소리내는지는 각 동물클래스에서 구현
```java
// 추상화
abstract class Shape {
    abstract double getArea();  // 구현 없이 틀만 정의
}

class Circle extends Shape {
    double radius;
    double getArea() { return 3.14 * radius * radius; }  // 구체적 구현
}
```

**다형성**: 하나의 타입이나 메서드가 여러 형태로 동작하는것. 예를들어 부모타입으로 선언하고 자식객체를 담아서 호출하면 각 자식의 오버라이드된 메서드가 실행됨 (Animal a = new Dog(); a.makeSound()하면 "멍멍")
```java
// 다형성
class Main {
    public static void main(String[] args) {
        Animal a = new Dog();  // 부모 타입으로 자식 객체
        a.eat();  // "먹는다" - Dog의 메서드 실행
        
        Shape s1 = new Circle();
        Shape s2 = new Rectangle();
        s1.getArea();  // 원 넓이
        s2.getArea();  // 사각형 넓이 - 같은 메서드, 다른 동작
    }
}
```





