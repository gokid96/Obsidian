# ê¸ˆìœµêµìœ¡ í”Œë«í¼ MSA + DDD ì•„í‚¤í…ì²˜ (ê°œì„ íŒ)

## ğŸ“Š ì „ì²´ ì•„í‚¤í…ì²˜ ê°œìš”

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Client Applications                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚   ìë…€ ì•±      â”‚              â”‚   ë¶€ëª¨ ì•±      â”‚            â”‚
â”‚  â”‚ (React Native)â”‚              â”‚ (React Native)â”‚            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              API Gateway (Kong / Spring Cloud Gateway)     â”‚
â”‚                    + BFF (Backend for Frontend)            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                 â”‚                 â”‚              â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”
â”‚   User      â”‚  â”‚    Game     â”‚  â”‚   Reward    â”‚  â”‚  Payment   â”‚
â”‚  Service    â”‚  â”‚  Service    â”‚  â”‚  Service    â”‚  â”‚  Service   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                                    â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”
                                                    â”‚   Report   â”‚
                                                    â”‚  Service   â”‚
                                                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ¯ í•µì‹¬ ë„ë©”ì¸ ì •ì˜ (5ê°œ ì„œë¹„ìŠ¤)

### ë„ë©”ì¸ ê²½ê³„ ë° ì±…ì„

|ì„œë¹„ìŠ¤|í•µì‹¬ ë„ë©”ì¸|ì£¼ìš” ì±…ì„|ë°ì´í„° ì†Œìœ |
|---|---|---|---|
|**User Service**|ì‚¬ìš©ì ê´€ë¦¬|íšŒì›ê°€ì…/ë¡œê·¸ì¸<br>ê°€ì¡± ê´€ê³„ ì„¤ì •<br>ê¶Œí•œ ê´€ë¦¬|users<br>families<br>auth_tokens|
|**Game Service**|íˆ¬ì ê²Œì„|ê²Œì„ë¨¸ë‹ˆ ê´€ë¦¬<br>í¬íŠ¸í´ë¦¬ì˜¤ êµ¬ì„±<br>ë§¤ë§¤ ì‹œë®¬ë ˆì´ì…˜|portfolios<br>holdings<br>trades|
|**Reward Service**|ì„±ê³¼/í™˜ì‚°|ìˆ˜ìµ ê³„ì‚°<br>í™˜ì‚° ë¡œì§<br>ìš©ëˆ ìš”ì²­ ìƒì„±|reward_requests<br>conversion_history|
|**Payment Service**|ìš©ëˆ ì§€ê¸‰|ì‹¤ì œ ìš©ëˆ ì†¡ê¸ˆ<br>ë¶€ëª¨ ìŠ¹ì¸ ì²˜ë¦¬<br>ì§€ê¸‰ ë‚´ì—­ ê´€ë¦¬|payments<br>approvals<br>transactions|
|**Report Service**|ë¦¬í¬íŠ¸/ë¶„ì„|ì„±ê³¼ ë¦¬í¬íŠ¸<br>í†µê³„ ë¶„ì„<br>êµìœ¡ íš¨ê³¼ ì¸¡ì •|reports<br>analytics<br>statistics|

---

## ğŸ”§ ê° ì„œë¹„ìŠ¤ ìƒì„¸ ì„¤ê³„ (DDD ì ìš©)

### 1ï¸âƒ£ User Service (ì‚¬ìš©ì ê´€ë¦¬)

#### ë„ë©”ì¸ ëª¨ë¸

```kotlin
// Domain Layer
@Entity
class User(
    val userId: UserId,
    val email: Email,
    val role: UserRole,  // PARENT, CHILD
    val familyId: FamilyId?
) {
    fun linkFamily(familyId: FamilyId): User {
        require(this.familyId == null) { "ì´ë¯¸ ê°€ì¡±ì´ ì—°ê²°ë˜ì–´ ìˆìŠµë‹ˆë‹¤" }
        return this.copy(familyId = familyId)
    }
    
    fun hasPermission(permission: Permission): Boolean {
        return role.permissions.contains(permission)
    }
}

@Entity
class Family(
    val familyId: FamilyId,
    val parentId: UserId,
    val childIds: MutableList<UserId>
) {
    fun addChild(childId: UserId) {
        require(childIds.size < 5) { "ìë…€ëŠ” ìµœëŒ€ 5ëª…ê¹Œì§€ ë“±ë¡ ê°€ëŠ¥í•©ë‹ˆë‹¤" }
        childIds.add(childId)
    }
}

// Value Object
data class Email(val value: String) {
    init {
        require(value.matches(Regex("^[A-Za-z0-9+_.-]+@(.+)$"))) { 
            "ì˜¬ë°”ë¥¸ ì´ë©”ì¼ í˜•ì‹ì´ ì•„ë‹™ë‹ˆë‹¤" 
        }
    }
}

enum class UserRole(val permissions: Set<Permission>) {
    PARENT(setOf(Permission.APPROVE_ALLOWANCE, Permission.VIEW_CHILD_PORTFOLIO)),
    CHILD(setOf(Permission.TRADE, Permission.REQUEST_ALLOWANCE))
}
```

#### ì„œë¹„ìŠ¤ ê³„ì¸µ
```kotlin
// Application Layer
@Service
class UserApplicationService(
    private val userRepository: UserRepository,
    private val familyRepository: FamilyRepository,
    private val eventPublisher: DomainEventPublisher
) {
    @Transactional
    fun registerFamily(
        parentEmail: String, 
        childEmail: String
    ): FamilyRegistrationResult {
        val parent = userRepository.findByEmail(Email(parentEmail))
            ?: throw UserNotFoundException()
        val child = userRepository.findByEmail(Email(childEmail))
            ?: throw UserNotFoundException()
        
        val family = Family(
            familyId = FamilyId.generate(),
            parentId = parent.userId,
            childIds = mutableListOf(child.userId)
        )
        
        familyRepository.save(family)
        
        // ë„ë©”ì¸ ì´ë²¤íŠ¸ ë°œí–‰
        eventPublisher.publish(FamilyLinkedEvent(family.familyId))
        
        return FamilyRegistrationResult(family)
    }
}
```

#### ì¸í”„ë¼ ê³„ì¸µ
```kotlin
// Infrastructure Layer
@Repository
interface UserRepository : JpaRepository<User, UserId> {
    fun findByEmail(email: Email): User?
}

@Component
class JwtTokenProvider {
    fun generateToken(user: User): String {
        return Jwts.builder()
            .setSubject(user.userId.value)
            .claim("role", user.role.name)
            .setExpiration(Date(System.currentTimeMillis() + 900000)) // 15ë¶„
            .signWith(SignatureAlgorithm.HS512, secretKey)
            .compact()
    }
}
```

#### API ì—”ë“œí¬ì¸íŠ¸
```yaml
POST   /api/users/register         # íšŒì›ê°€ì…
POST   /api/users/login            # ë¡œê·¸ì¸ (JWT í† í° ë°œê¸‰)
POST   /api/users/family/link      # ê°€ì¡± ì—°ê²°
GET    /api/users/{userId}         # ì‚¬ìš©ì ì •ë³´ ì¡°íšŒ
PUT    /api/users/{userId}/profile # í”„ë¡œí•„ ìˆ˜ì •
```

---

### 2ï¸âƒ£ Game Service (íˆ¬ì ê²Œì„)

#### ë„ë©”ì¸ ëª¨ë¸
```typescript
// Domain Layer (Node.js + TypeScript)
export class Portfolio {
  constructor(
    public readonly portfolioId: PortfolioId,
    public readonly userId: UserId,
    public gameBalance: Money,
    public holdings: Holding[]
  ) {}

  buyStock(stock: Stock, quantity: number, currentPrice: Money): Trade {
    const totalCost = currentPrice.multiply(quantity);
    
    if (this.gameBalance.isLessThan(totalCost)) {
      throw new InsufficientBalanceError();
    }

    // ì”ì•¡ ì°¨ê°
    this.gameBalance = this.gameBalance.subtract(totalCost);

    // ë³´ìœ  ì£¼ì‹ ì¶”ê°€ or ìˆ˜ëŸ‰ ì¦ê°€
    const existingHolding = this.holdings.find(h => h.stock.equals(stock));
    if (existingHolding) {
      existingHolding.increaseQuantity(quantity, currentPrice);
    } else {
      this.holdings.push(new Holding(stock, quantity, currentPrice));
    }

    return new Trade(
      TradeId.generate(),
      this.portfolioId,
      stock,
      'BUY',
      quantity,
      currentPrice,
      new Date()
    );
  }

  sellStock(stock: Stock, quantity: number, currentPrice: Money): Trade {
    const holding = this.holdings.find(h => h.stock.equals(stock));
    if (!holding || holding.quantity < quantity) {
      throw new InsufficientHoldingError();
    }

    const totalRevenue = currentPrice.multiply(quantity);
    this.gameBalance = this.gameBalance.add(totalRevenue);

    holding.decreaseQuantity(quantity);
    if (holding.quantity === 0) {
      this.holdings = this.holdings.filter(h => !h.stock.equals(stock));
    }

    return new Trade(
      TradeId.generate(),
      this.portfolioId,
      stock,
      'SELL',
      quantity,
      currentPrice,
      new Date()
    );
  }

  calculateTotalValue(currentPrices: Map<Stock, Money>): Money {
    let total = this.gameBalance;
    
    for (const holding of this.holdings) {
      const currentPrice = currentPrices.get(holding.stock);
      if (currentPrice) {
        total = total.add(currentPrice.multiply(holding.quantity));
      }
    }
    
    return total;
  }

  calculateReturns(currentPrices: Map<Stock, Money>): ReturnRate {
    const initialBalance = new Money(100000, 'GAME'); // ì´ˆê¸° 10ë§Œì›
    const currentValue = this.calculateTotalValue(currentPrices);
    
    return ReturnRate.from(initialBalance, currentValue);
  }
}

// Value Object
export class Money {
  constructor(
    public readonly amount: number,
    public readonly currency: 'GAME' | 'KRW'
  ) {
    if (amount < 0) throw new Error('ê¸ˆì•¡ì€ ìŒìˆ˜ì¼ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
  }

  add(other: Money): Money {
    this.assertSameCurrency(other);
    return new Money(this.amount + other.amount, this.currency);
  }

  subtract(other: Money): Money {
    this.assertSameCurrency(other);
    return new Money(this.amount - other.amount, this.currency);
  }

  multiply(factor: number): Money {
    return new Money(this.amount * factor, this.currency);
  }

  isLessThan(other: Money): boolean {
    this.assertSameCurrency(other);
    return this.amount < other.amount;
  }

  private assertSameCurrency(other: Money) {
    if (this.currency !== other.currency) {
      throw new Error('í†µí™”ê°€ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤');
    }
  }
}

// Entity
export class Holding {
  constructor(
    public readonly stock: Stock,
    public quantity: number,
    public avgPurchasePrice: Money
  ) {}

  increaseQuantity(additionalQuantity: number, purchasePrice: Money) {
    const totalCost = this.avgPurchasePrice.multiply(this.quantity)
      .add(purchasePrice.multiply(additionalQuantity));
    this.quantity += additionalQuantity;
    this.avgPurchasePrice = new Money(
      totalCost.amount / this.quantity,
      this.avgPurchasePrice.currency
    );
  }

  decreaseQuantity(soldQuantity: number) {
    if (this.quantity < soldQuantity) {
      throw new Error('ë³´ìœ  ìˆ˜ëŸ‰ì´ ë¶€ì¡±í•©ë‹ˆë‹¤');
    }
    this.quantity -= soldQuantity;
  }
}
```

#### ì„œë¹„ìŠ¤ ê³„ì¸µ
```typescript
// Application Layer
@Injectable()
export class GameApplicationService {
  constructor(
    private portfolioRepository: PortfolioRepository,
    private marketDataAdapter: MarketDataAdapter,
    private eventBus: EventBus
  ) {}

  async executeTrade(command: ExecuteTradeCommand): Promise<TradeResult> {
    // 1. í¬íŠ¸í´ë¦¬ì˜¤ ì¡°íšŒ
    const portfolio = await this.portfolioRepository.findById(command.portfolioId);
    if (!portfolio) throw new PortfolioNotFoundError();

    // 2. í˜„ì¬ ì£¼ê°€ ì¡°íšŒ (ì™¸ë¶€ API)
    const currentPrice = await this.marketDataAdapter.getCurrentPrice(command.stock);

    // 3. ë„ë©”ì¸ ë¡œì§ ì‹¤í–‰
    let trade: Trade;
    if (command.type === 'BUY') {
      trade = portfolio.buyStock(command.stock, command.quantity, currentPrice);
    } else {
      trade = portfolio.sellStock(command.stock, command.quantity, currentPrice);
    }

    // 4. ì €ì¥
    await this.portfolioRepository.save(portfolio);
    await this.tradeRepository.save(trade);

    // 5. ì´ë²¤íŠ¸ ë°œí–‰
    await this.eventBus.publish(new TradeExecutedEvent(trade));

    return TradeResult.from(trade, portfolio);
  }

  async getPortfolioPerformance(portfolioId: PortfolioId): Promise<PerformanceDto> {
    const portfolio = await this.portfolioRepository.findById(portfolioId);
    
    // ëª¨ë“  ë³´ìœ  ì¢…ëª©ì˜ í˜„ì¬ê°€ ì¡°íšŒ
    const currentPrices = await this.marketDataAdapter.getCurrentPrices(
      portfolio.holdings.map(h => h.stock)
    );

    const returnRate = portfolio.calculateReturns(currentPrices);
    const totalValue = portfolio.calculateTotalValue(currentPrices);

    return new PerformanceDto(returnRate, totalValue, portfolio.holdings);
  }
}
```

#### ì¸í”„ë¼ ê³„ì¸µ
```typescript
// Infrastructure Layer
@Injectable()
export class MarketDataAdapter {
  constructor(private httpClient: HttpClient) {}

  async getCurrentPrice(stock: Stock): Promise<Money> {
    // Alpha Vantage API í˜¸ì¶œ
    const response = await this.httpClient.get(
      `https://www.alphavantage.co/query`,
      {
        params: {
          function: 'GLOBAL_QUOTE',
          symbol: stock.symbol,
          apikey: process.env.ALPHA_VANTAGE_KEY
        }
      }
    );

    const price = response.data['Global Quote']['05. price'];
    return new Money(parseFloat(price), 'GAME');
  }

  async getCurrentPrices(stocks: Stock[]): Promise<Map<Stock, Money>> {
    // Redis ìºì‹œ ë¨¼ì € í™•ì¸
    const cachedPrices = await this.redisClient.mget(
      stocks.map(s => `price:${s.symbol}`)
    );

    const prices = new Map<Stock, Money>();
    const uncachedStocks: Stock[] = [];

    stocks.forEach((stock, index) => {
      if (cachedPrices[index]) {
        prices.set(stock, new Money(parseFloat(cachedPrices[index]), 'GAME'));
      } else {
        uncachedStocks.push(stock);
      }
    });

    // ìºì‹œ ë¯¸ìŠ¤ ì¢…ëª©ì€ API í˜¸ì¶œ
    if (uncachedStocks.length > 0) {
      const freshPrices = await this.fetchPricesFromAPI(uncachedStocks);
      freshPrices.forEach((price, stock) => {
        prices.set(stock, price);
        // 5ì´ˆ TTLë¡œ ìºì‹±
        this.redisClient.setex(`price:${stock.symbol}`, 5, price.amount.toString());
      });
    }

    return prices;
  }
}
```

#### API ì—”ë“œí¬ì¸íŠ¸

```yaml
GET    /api/game/portfolio/{userId}           # í¬íŠ¸í´ë¦¬ì˜¤ ì¡°íšŒ
POST   /api/game/portfolio/{userId}/init      # ì´ˆê¸° ê²Œì„ë¨¸ë‹ˆ ì§€ê¸‰
POST   /api/game/trade/buy                    # ì£¼ì‹ ë§¤ìˆ˜
POST   /api/game/trade/sell                   # ì£¼ì‹ ë§¤ë„
GET    /api/game/performance/{userId}         # ìˆ˜ìµë¥  ì¡°íšŒ
GET    /api/game/holdings/{userId}            # ë³´ìœ  ì¢…ëª© ì¡°íšŒ
```

---

### 3ï¸âƒ£ Reward Service (ì„±ê³¼/í™˜ì‚°)

#### ë„ë©”ì¸ ëª¨ë¸
```kotlin
// Domain Layer
@Entity
class RewardRequest(
    val requestId: RewardRequestId,
    val childId: UserId,
    val parentId: UserId,
    val gameProfit: Money,
    val convertedAmount: Money,
    var status: RewardStatus
) {
    companion object {
        fun create(
            childId: UserId,
            parentId: UserId,
            gameProfit: Money,
            policy: RewardPolicy
        ): RewardRequest {
            val convertedAmount = policy.convert(gameProfit)
            
            return RewardRequest(
                requestId = RewardRequestId.generate(),
                childId = childId,
                parentId = parentId,
                gameProfit = gameProfit,
                convertedAmount = convertedAmount,
                status = RewardStatus.PENDING
            )
        }
    }

    fun approve() {
        require(status == RewardStatus.PENDING) { "ëŒ€ê¸° ì¤‘ì¸ ìš”ì²­ë§Œ ìŠ¹ì¸ ê°€ëŠ¥í•©ë‹ˆë‹¤" }
        status = RewardStatus.APPROVED
    }

    fun reject(reason: String) {
        require(status == RewardStatus.PENDING) { "ëŒ€ê¸° ì¤‘ì¸ ìš”ì²­ë§Œ ê±°ì ˆ ê°€ëŠ¥í•©ë‹ˆë‹¤" }
        status = RewardStatus.REJECTED
    }
}

// Domain Service
@Component
class RewardPolicy(
    @Value("\${reward.conversion-rate}") private val conversionRate: Double = 0.1
) {
    fun convert(gameProfit: Money): Money {
        if (gameProfit.amount <= 0) {
            return Money(0, Currency.KRW)
        }
        
        // ê²Œì„ë¨¸ë‹ˆ / 10 = ì‹¤ì œ ìš©ëˆ
        val convertedAmount = (gameProfit.amount * conversionRate).toLong()
        
        return Money(convertedAmount, Currency.KRW)
    }

    fun validate(gameProfit: Money): ValidationResult {
        if (gameProfit.amount <= 0) {
            return ValidationResult.failure("ìˆ˜ìµì´ ì—†ì–´ ìš©ëˆì„ ìš”ì²­í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤")
        }
        
        if (gameProfit.amount > 1_000_000) {
            return ValidationResult.failure("í•œ ë²ˆì— í™˜ì‚° ê°€ëŠ¥í•œ ìµœëŒ€ ê¸ˆì•¡ì„ ì´ˆê³¼í–ˆìŠµë‹ˆë‹¤")
        }
        
        return ValidationResult.success()
    }
}

enum class RewardStatus {
    PENDING,    // ëŒ€ê¸°ì¤‘
    APPROVED,   // ìŠ¹ì¸ë¨
    REJECTED,   // ê±°ì ˆë¨
    PAID        // ì§€ê¸‰ ì™„ë£Œ
}
```

#### ì„œë¹„ìŠ¤ ê³„ì¸µ
```kotlin
// Application Layer
@Service
class RewardApplicationService(
    private val rewardRepository: RewardRequestRepository,
    private val gameServiceClient: GameServiceClient,  // ë‹¤ë¥¸ ì„œë¹„ìŠ¤ì™€ í†µì‹ 
    private val rewardPolicy: RewardPolicy,
    private val eventPublisher: DomainEventPublisher
) {
    @Transactional
    fun requestReward(command: RequestRewardCommand): RewardRequestResult {
        // 1. Game Serviceì—ì„œ í˜„ì¬ ìˆ˜ìµë¥  ì¡°íšŒ
        val performance = gameServiceClient.getPerformance(command.childId)
        val gameProfit = performance.profit

        // 2. ê²€ì¦
        val validation = rewardPolicy.validate(gameProfit)
        if (!validation.isValid) {
            throw InvalidRewardRequestException(validation.errorMessage)
        }

        // 3. í™˜ì‚° ë° ìš”ì²­ ìƒì„±
        val rewardRequest = RewardRequest.create(
            childId = command.childId,
            parentId = command.parentId,
            gameProfit = gameProfit,
            policy = rewardPolicy
        )

        // 4. ì €ì¥
        rewardRepository.save(rewardRequest)

        // 5. ë¶€ëª¨ì—ê²Œ ì•Œë¦¼ ì´ë²¤íŠ¸ ë°œí–‰
        eventPublisher.publish(
            RewardRequestedEvent(
                requestId = rewardRequest.requestId,
                parentId = rewardRequest.parentId,
                amount = rewardRequest.convertedAmount
            )
        )

        return RewardRequestResult(rewardRequest)
    }

    @Transactional
    fun approveReward(requestId: RewardRequestId, parentId: UserId) {
        val request = rewardRepository.findById(requestId)
            ?: throw RewardRequestNotFoundException()

        // ë¶€ëª¨ ê¶Œí•œ í™•ì¸
        if (request.parentId != parentId) {
            throw UnauthorizedException("í•´ë‹¹ ìš”ì²­ì„ ìŠ¹ì¸í•  ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤")
        }

        request.approve()
        rewardRepository.save(request)

        // Payment Serviceì— ì§€ê¸‰ ìš”ì²­ ì´ë²¤íŠ¸
        eventPublisher.publish(
            RewardApprovedEvent(
                requestId = request.requestId,
                childId = request.childId,
                amount = request.convertedAmount
            )
        )
    }
}
```

#### ì„œë¹„ìŠ¤ ê°„ í†µì‹ 
```kotlin
// Infrastructure Layer - Feign Client
@FeignClient(name = "game-service")
interface GameServiceClient {
    @GetMapping("/api/game/performance/{userId}")
    fun getPerformance(@PathVariable userId: UserId): PerformanceResponse
}

// ë˜ëŠ” ì´ë²¤íŠ¸ ê¸°ë°˜ í†µì‹ 
@Component
class RewardEventHandler(
    private val rewardApplicationService: RewardApplicationService
) {
    @EventListener
    fun handle(event: PortfolioUpdatedEvent) {
        // Game Serviceì—ì„œ í¬íŠ¸í´ë¦¬ì˜¤ ì—…ë°ì´íŠ¸ ì‹œ
        // ìë™ìœ¼ë¡œ ìš©ëˆ ìš”ì²­ ê°€ëŠ¥ ì—¬ë¶€ ì²´í¬
        if (event.profitRate >= 5.0) {
            // 5% ì´ìƒ ìˆ˜ìµ ì‹œ ë¶€ëª¨ì—ê²Œ ì•Œë¦¼
            notificationService.notifyParent(event.userId)
        }
    }
}
```

#### API ì—”ë“œí¬ì¸íŠ¸
```yaml
POST   /api/reward/request                  # ìš©ëˆ ìš”ì²­
PUT    /api/reward/{requestId}/approve      # ë¶€ëª¨ ìŠ¹ì¸
PUT    /api/reward/{requestId}/reject       # ë¶€ëª¨ ê±°ì ˆ
GET    /api/reward/history/{userId}         # ìš”ì²­ ë‚´ì—­
GET    /api/reward/pending/{parentId}       # ëŒ€ê¸°ì¤‘ì¸ ìš”ì²­ (ë¶€ëª¨ìš©)
```

---

### 4ï¸âƒ£ Payment Service (ìš©ëˆ ì§€ê¸‰)

#### ë„ë©”ì¸ ëª¨ë¸
```typescript
// Domain Layer
export class Payment {
  constructor(
    public readonly paymentId: PaymentId,
    public readonly rewardRequestId: RewardRequestId,
    public readonly amount: Money,
    public readonly recipientId: UserId,
    public status: PaymentStatus,
    public transactionId?: string
  ) {}

  static create(
    rewardRequestId: RewardRequestId,
    amount: Money,
    recipientId: UserId
  ): Payment {
    return new Payment(
      PaymentId.generate(),
      rewardRequestId,
      amount,
      recipientId,
      PaymentStatus.PENDING
    );
  }

  markAsProcessing(transactionId: string) {
    if (this.status !== PaymentStatus.PENDING) {
      throw new Error('ëŒ€ê¸° ì¤‘ì¸ ì§€ê¸‰ë§Œ ì²˜ë¦¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤');
    }
    this.status = PaymentStatus.PROCESSING;
    this.transactionId = transactionId;
  }

  markAsCompleted() {
    if (this.status !== PaymentStatus.PROCESSING) {
      throw new Error('ì²˜ë¦¬ ì¤‘ì¸ ì§€ê¸‰ë§Œ ì™„ë£Œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤');
    }
    this.status = PaymentStatus.COMPLETED;
  }

  markAsFailed(reason: string) {
    this.status = PaymentStatus.FAILED;
    // ì‹¤íŒ¨ ì´ìœ  ë¡œê¹…
  }
}

enum PaymentStatus {
  PENDING = 'PENDING',       // ëŒ€ê¸°
  PROCESSING = 'PROCESSING', // ì²˜ë¦¬ì¤‘
  COMPLETED = 'COMPLETED',   // ì™„ë£Œ
  FAILED = 'FAILED'          // ì‹¤íŒ¨
}
```

#### ì„œë¹„ìŠ¤ ê³„ì¸µ
```typescript
// Application Layer
@Injectable()
export class PaymentApplicationService {
  constructor(
    private paymentRepository: PaymentRepository,
    private paymentGateway: PaymentGateway,  // í† ìŠ¤í˜ì´ë¨¼ì¸  ë“±
    private eventBus: EventBus
  ) {}

  @Transactional()
  async processPayment(event: RewardApprovedEvent): Promise<void> {
    // 1. Payment ìƒì„±
    const payment = Payment.create(
      event.requestId,
      event.amount,
      event.childId
    );

    await this.paymentRepository.save(payment);

    try {
      // 2. ì‹¤ì œ ì†¡ê¸ˆ ì²˜ë¦¬
      const transactionId = await this.paymentGateway.transfer({
        recipientId: event.childId.value,
        amount: event.amount.amount,
        description: 'íˆ¬ì ì„±ê³¼ ìš©ëˆ'
      });

      payment.markAsProcessing(transactionId);
      await this.paymentRepository.save(payment);

      // 3. ì™„ë£Œ ì²˜ë¦¬
      payment.markAsCompleted();
      await this.paymentRepository.save(payment);

      // 4. ì™„ë£Œ ì´ë²¤íŠ¸
      await this.eventBus.publish(
        new PaymentCompletedEvent(payment.paymentId, event.childId)
      );

    } catch (error) {
      payment.markAsFailed(error.message);
      await this.paymentRepository.save(payment);
      
      // ì¬ì‹œë„ ì´ë²¤íŠ¸ ë°œí–‰
      await this.eventBus.publish(
        new PaymentFailedEvent(payment.paymentId, error.message)
      );
    }
  }
}
```

#### ì™¸ë¶€ ì—°ë™
```typescript
// Infrastructure Layer
@Injectable()
export class TossPaymentGateway implements PaymentGateway {
  async transfer(request: TransferRequest): Promise<string> {
    const response = await axios.post(
      'https://api.tosspayments.com/v1/transfers',
      {
        amount: request.amount,
        orderId: generateOrderId(),
        orderName: request.description,
        // ìë…€ ê³„ì¢Œ ì •ë³´
        bank: request.bankCode,
        accountNumber: request.accountNumber
      },
      {
        headers: {
          Authorization: `Basic ${this.getAuthToken()}`,
          'Content-Type': 'application/json'
        }
      }
    );

    return response.data.transactionKey;
  }
}
```

#### API ì—”ë“œí¬ì¸íŠ¸
```yaml
POST   /api/payment/process               # ì§€ê¸‰ ì²˜ë¦¬ (ë‚´ë¶€ í˜¸ì¶œ)
GET    /api/payment/{paymentId}           # ì§€ê¸‰ ìƒíƒœ ì¡°íšŒ
GET    /api/payment/history/{userId}      # ì§€ê¸‰ ë‚´ì—­
POST   /api/payment/retry/{paymentId}     # ì‹¤íŒ¨ ê±´ ì¬ì‹œë„
```

---

### 5ï¸âƒ£ Report Service (ë¦¬í¬íŠ¸/ë¶„ì„)

#### ë„ë©”ì¸ ëª¨ë¸
```kotlin
// Domain Layer
@Entity
class PerformanceReport(
    val reportId: ReportId,
    val userId: UserId,
    val period: Period,  // WEEKLY, MONTHLY
    val startDate: LocalDate,
    val endDate: LocalDate,
    val metrics: ReportMetrics,
    val generatedAt: LocalDateTime
) {
    companion object {
        fun generate(
            userId: UserId,
            period: Period,
            trades: List<Trade>,
            portfolioSnapshots: List<PortfolioSnapshot>
        ): PerformanceReport {
            val metrics = ReportMetrics.calculate(trades, portfolioSnapshots)
            
            return PerformanceReport(
                reportId = ReportId.generate(),
                userId = userId,
                period = period,
                startDate = period.startDate,
                endDate = period.endDate,
                metrics = metrics,
                generatedAt = LocalDateTime.now()
            )
        }
    }
}

// Value Object
data class ReportMetrics(
    val totalReturn: ReturnRate,
    val bestTrade: Trade?,
    val worstTrade: Trade?,
    val winRate: Double,
    val totalTrades: Int,
    val profitableTrades: Int
) {
    companion object {
        fun calculate(
            trades: List<Trade>,
            snapshots: List<PortfolioSnapshot>
        ): ReportMetrics {
            val firstSnapshot = snapshots.first()
            val lastSnapshot = snapshots.last()
            
            val totalReturn = ReturnRate.from(
                firstSnapshot.totalValue,
                lastSnapshot.totalValue
            )
            
            val profitableTrades = trades.count { it.profit > 0 }
            val winRate = profitableTrades.toDouble() / trades.size * 100
            
            return ReportMetrics(
                totalReturn = totalReturn,
                bestTrade = trades.maxByOrNull { it.profit },
                worstTrade = trades.minByOrNull { it.profit },
                winRate = winRate,
                totalTrades = trades.size,
                profitableTrades = profitableTrades
            )
        }
    }
}
```

#### ì„œë¹„ìŠ¤ ê³„ì¸µ
```kotlin
// Application Layer
@Service
class ReportApplicationService(
    private val reportRepository: ReportRepository,
    private val gameServiceClient: GameServiceClient,
    private val analyticsEngine: AnalyticsEngine
) {
    fun generateMonthlyReport(userId: UserId): MonthlyReportDto {
        val period = Period.currentMonth()
        
        // Game Serviceì—ì„œ ê±°ë˜ ë‚´ì—­ ì¡°íšŒ
        val trades = gameServiceClient.getTrades(userId, period)
        val snapshots = gameServiceClient.getPortfolioSnapshots(userId, period)
        
        // ë¦¬í¬íŠ¸ ìƒì„±
        val report = PerformanceReport.generate(
            userId = userId,
            period = Period.MONTHLY,
            trades = trades,
            portfolioSnapshots = snapshots
        )
        
        reportRepository.save(report)
        
        // êµìœ¡ íš¨ê³¼ ë¶„ì„
        val insights = analyticsEngine.analyzeEducationalImpact(report)
        
        return MonthlyReportDto(report, insights)
    }

    fun compareWithPeers(userId: UserId): ComparisonDto {
        val userReport = reportRepository.findLatest(userId)
        
        // ê°™ì€ ì—°ë ¹ëŒ€ í‰ê· ê³¼ ë¹„êµ 
        val peerAverages = analyticsEngine.calculatePeerAverages( userAge = getUserAge(userId), period = userReport.period ) return ComparisonDto(
        userPerformance = userReport.metrics,
        peerAverage = peerAverages,
        ranking = calculateRanking(userId, peerAverages)
    )
}

}

// Domain Service @Component class AnalyticsEngine { 
fun analyzeEducationalImpact(report: PerformanceReport): EducationalInsights { val insights = mutableListOf<Insight>()
// 1. ë¦¬ìŠ¤í¬ ê´€ë¦¬ í•™ìŠµ
    if (report.metrics.winRate >= 60) {
        insights.add(Insight(
            category = InsightCategory.RISK_MANAGEMENT,
            message = "í›Œë¥­í•´ìš”! 60% ì´ìƒì˜ ë†’ì€ ìŠ¹ë¥ ì„ ê¸°ë¡í–ˆì–´ìš”. ì‹ ì¤‘í•œ íˆ¬ì ìŠµê´€ì´ í˜•ì„±ë˜ê³  ìˆë„¤ìš”.",
            level = InsightLevel.EXCELLENT
        ))
    }
    
    // 2. ë¶„ì‚° íˆ¬ì ë¶„ì„
    val diversificationScore = calculateDiversification(report)
    if (diversificationScore >= 70) {
        insights.add(Insight(
            category = InsightCategory.DIVERSIFICATION,
            message = "ì—¬ëŸ¬ ì¢…ëª©ì— ë¶„ì‚° íˆ¬ìí•˜ê³  ìˆì–´ìš”. ë¦¬ìŠ¤í¬ë¥¼ ì˜ ê´€ë¦¬í•˜ê³  ìˆìŠµë‹ˆë‹¤!",
            level = InsightLevel.GOOD
        ))
    }
    
    // 3. ì†ì‹¤ ëŒ€ì‘ í•™ìŠµ
    if (report.metrics.worstTrade?.loss ?: 0 > 10000) {
        insights.add(Insight(
            category = InsightCategory.LOSS_MANAGEMENT,
            message = "í° ì†ì‹¤ì„ ê²½í—˜í–ˆë„¤ìš”. ì†ì ˆë§¤ íƒ€ì´ë°ì„ ê³µë¶€í•´ë³´ëŠ” ê±´ ì–´ë–¨ê¹Œìš”?",
            level = InsightLevel.WARNING
        ))
    }
    
    return EducationalInsights(insights)
}

private fun calculateDiversification(report: PerformanceReport): Int {
    // í¬íŠ¸í´ë¦¬ì˜¤ ë‚´ ì¢…ëª© ë‹¤ì–‘ì„± ì ìˆ˜ ê³„ì‚°
    // ...
    return 75
}

}



````
#### API ì—”ë“œí¬ì¸íŠ¸
```yaml
GET    /api/report/monthly/{userId}              # ì›”ê°„ ë¦¬í¬íŠ¸
GET    /api/report/weekly/{userId}               # ì£¼ê°„ ë¦¬í¬íŠ¸
GET    /api/report/compare/{userId}              # ë˜ë˜ ë¹„êµ
GET    /api/report/insights/{userId}             # êµìœ¡ ì¸ì‚¬ì´íŠ¸
GET    /api/report/history/{userId}              # ê³¼ê±° ë¦¬í¬íŠ¸ ëª©ë¡
POST   /api/report/generate/{userId}             # ë¦¬í¬íŠ¸ ìˆ˜ë™ ìƒì„±
---
```
```
```


## ğŸ”„ ì„œë¹„ìŠ¤ ê°„ í†µì‹  íŒ¨í„´

### 1ï¸âƒ£ ë™ê¸° í†µì‹  (REST/gRPC)

#### REST ì˜ˆì‹œ

```kotlin
// Reward Service â†’ Game Service
@FeignClient(name = "game-service", url = "\${game-service.url}")
interface GameServiceClient {
    @GetMapping("/api/game/performance/{userId}")
    fun getPerformance(@PathVariable userId: String): PerformanceResponse
}

// ì‚¬ìš©
val performance = gameServiceClient.getPerformance(userId.value)
```
#### gRPC ì˜ˆì‹œ (ê³ ì„±ëŠ¥ í†µì‹ )
```protobuf
// game_service.proto
service GameService {
  rpc GetPerformance (PerformanceRequest) returns (PerformanceResponse);
}

message PerformanceRequest {
  string user_id = 1;
}

message PerformanceResponse {
  double return_rate = 1;
  int64 profit_amount = 2;
  int64 total_value = 3;
}
```

### 2ï¸âƒ£ ë¹„ë™ê¸° í†µì‹  (Event-Driven)

#### ì´ë²¤íŠ¸ ì •ì˜
```kotlin
// Domain Events
sealed class DomainEvent {
    abstract val eventId: String
    abstract val occurredAt: LocalDateTime
}

data class FamilyLinkedEvent(
    override val eventId: String = UUID.randomUUID().toString(),
    override val occurredAt: LocalDateTime = LocalDateTime.now(),
    val familyId: String,
    val parentId: String,
    val childId: String
) : DomainEvent()

data class TradeExecutedEvent(
    override val eventId: String = UUID.randomUUID().toString(),
    override val occurredAt: LocalDateTime = LocalDateTime.now(),
    val tradeId: String,
    val userId: String,
    val type: String,  // BUY, SELL
    val stock: String,
    val quantity: Int,
    val price: Long
) : DomainEvent()

data class RewardRequestedEvent(
    override val eventId: String = UUID.randomUUID().toString(),
    override val occurredAt: LocalDateTime = LocalDateTime.now(),
    val requestId: String,
    val childId: String,
    val parentId: String,
    val amount: Long
) : DomainEvent()

data class RewardApprovedEvent(
    override val eventId: String = UUID.randomUUID().toString(),
    override val occurredAt: LocalDateTime = LocalDateTime.now(),
    val requestId: String,
    val childId: String,
    val amount: Long
) : DomainEvent()

data class PaymentCompletedEvent(
    override val eventId: String = UUID.randomUUID().toString(),
    override val occurredAt: LocalDateTime = LocalDateTime.now(),
    val paymentId: String,
    val userId: String,
    val amount: Long
) : DomainEvent()
```

#### RabbitMQë¥¼ í†µí•œ ì´ë²¤íŠ¸ ë°œí–‰/êµ¬ë…
```kotlin
// Event Publisher
@Component
class RabbitMQEventPublisher(
    private val rabbitTemplate: RabbitTemplate
) : DomainEventPublisher {
    
    override fun publish(event: DomainEvent) {
        val routingKey = when (event) {
            is TradeExecutedEvent -> "trade.executed"
            is RewardRequestedEvent -> "reward.requested"
            is RewardApprovedEvent -> "reward.approved"
            is PaymentCompletedEvent -> "payment.completed"
            else -> "domain.event"
        }
        
        rabbitTemplate.convertAndSend(
            "domain-events",  // exchange
            routingKey,
            event
        )
    }
}

// Event Consumer (Notification Service)
@Component
class NotificationEventHandler(
    private val notificationService: NotificationService
) {
    
    @RabbitListener(queues = ["notification-queue"])
    fun handleTradeExecuted(event: TradeExecutedEvent) {
        notificationService.sendPushNotification(
            userId = event.userId,
            title = "ê±°ë˜ ì™„ë£Œ",
            message = "${event.stock} ${event.type} ${event.quantity}ì£¼ ê±°ë˜ê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤."
        )
    }
    
    @RabbitListener(queues = ["notification-queue"])
    fun handleRewardRequested(event: RewardRequestedEvent) {
        notificationService.sendPushNotification(
            userId = event.parentId,
            title = "ìš©ëˆ ìš”ì²­",
            message = "ìë…€ê°€ ${event.amount}ì› ìš©ëˆì„ ìš”ì²­í–ˆìŠµë‹ˆë‹¤."
        )
    }
}

// Event Consumer (Payment Service)
@Component
class PaymentEventHandler(
    private val paymentService: PaymentApplicationService
) {
    
    @RabbitListener(queues = ["payment-queue"])
    fun handleRewardApproved(event: RewardApprovedEvent) {
        // ë¹„ë™ê¸°ë¡œ ì§€ê¸‰ ì²˜ë¦¬
        paymentService.processPayment(event)
    }
}
```

### 3ï¸âƒ£ Saga íŒ¨í„´ (ë¶„ì‚° íŠ¸ëœì­ì…˜)

#### ìš©ëˆ ì§€ê¸‰ Saga
```kotlin
@Component
class AllowanceSaga(
    private val rewardService: RewardApplicationService,
    private val paymentService: PaymentApplicationService,
    private val gameService: GameApplicationService
) {
    
    @Transactional
    fun executeAllowanceFlow(command: RequestAllowanceCommand) {
        try {
            // 1ë‹¨ê³„: ìš©ëˆ ìš”ì²­ ìƒì„±
            val rewardRequest = rewardService.requestReward(command)
            
            // 2ë‹¨ê³„: ë¶€ëª¨ ìŠ¹ì¸ ëŒ€ê¸°
            // (ì´ë²¤íŠ¸ ê¸°ë°˜ìœ¼ë¡œ ì²˜ë¦¬)
            
        } catch (e: Exception) {
            // ë³´ìƒ íŠ¸ëœì­ì…˜ (Compensating Transaction)
            rollbackAllowanceFlow(command)
        }
    }
    
    @EventListener
    fun onRewardApproved(event: RewardApprovedEvent) {
        try {
            // 3ë‹¨ê³„: ê²Œì„ë¨¸ë‹ˆ ì°¨ê°
            gameService.deductGameMoney(event.childId, event.amount * 10)
            
            // 4ë‹¨ê³„: ì‹¤ì œ ì§€ê¸‰
            paymentService.processPayment(event)
            
        } catch (e: Exception) {
            // ë³´ìƒ: ê²Œì„ë¨¸ë‹ˆ ë³µêµ¬ + ìš”ì²­ ì·¨ì†Œ
            gameService.restoreGameMoney(event.childId, event.amount * 10)
            rewardService.cancelRequest(event.requestId)
        }
    }
}
```

---

## ğŸ—„ï¸ ë°ì´í„°ë² ì´ìŠ¤ ì„¤ê³„ (Per Service)

### User Service DB

```sql
-- users í…Œì´ë¸”
CREATE TABLE users (
    user_id VARCHAR(36) PRIMARY KEY,
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    role VARCHAR(20) NOT NULL,  -- PARENT, CHILD
    name VARCHAR(100) NOT NULL,
    birth_date DATE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- families í…Œì´ë¸”
CREATE TABLE families (
    family_id VARCHAR(36) PRIMARY KEY,
    parent_id VARCHAR(36) NOT NULL,
    family_name VARCHAR(100),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (parent_id) REFERENCES users(user_id)
);

-- family_members í…Œì´ë¸”
CREATE TABLE family_members (
    family_id VARCHAR(36),
    child_id VARCHAR(36),
    joined_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (family_id, child_id),
    FOREIGN KEY (family_id) REFERENCES families(family_id),
    FOREIGN KEY (child_id) REFERENCES users(user_id)
);

-- ì¸ë±ìŠ¤
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_families_parent ON families(parent_id);
```

### Game Service DB
```sql
-- portfolios í…Œì´ë¸”
CREATE TABLE portfolios (
    portfolio_id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36) NOT NULL UNIQUE,
    game_balance BIGINT NOT NULL DEFAULT 100000,  -- ì´ˆê¸° 10ë§Œì›
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- holdings í…Œì´ë¸” (ë³´ìœ  ì£¼ì‹)
CREATE TABLE holdings (
    holding_id VARCHAR(36) PRIMARY KEY,
    portfolio_id VARCHAR(36) NOT NULL,
    stock_symbol VARCHAR(20) NOT NULL,
    stock_name VARCHAR(100) NOT NULL,
    quantity INT NOT NULL,
    avg_purchase_price BIGINT NOT NULL,
    FOREIGN KEY (portfolio_id) REFERENCES portfolios(portfolio_id),
    UNIQUE (portfolio_id, stock_symbol)
);

-- trades í…Œì´ë¸” (ê±°ë˜ ë‚´ì—­)
CREATE TABLE trades (
    trade_id VARCHAR(36) PRIMARY KEY,
    portfolio_id VARCHAR(36) NOT NULL,
    stock_symbol VARCHAR(20) NOT NULL,
    trade_type VARCHAR(10) NOT NULL,  -- BUY, SELL
    quantity INT NOT NULL,
    price BIGINT NOT NULL,
    total_amount BIGINT NOT NULL,
    executed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (portfolio_id) REFERENCES portfolios(portfolio_id)
);

-- ì¸ë±ìŠ¤
CREATE INDEX idx_portfolios_user ON portfolios(user_id);
CREATE INDEX idx_holdings_portfolio ON holdings(portfolio_id);
CREATE INDEX idx_trades_portfolio_date ON trades(portfolio_id, executed_at DESC);
```

### Reward Service DB
```sql
-- reward_requests í…Œì´ë¸”
CREATE TABLE reward_requests (
    request_id VARCHAR(36) PRIMARY KEY,
    child_id VARCHAR(36) NOT NULL,
    parent_id VARCHAR(36) NOT NULL,
    game_profit BIGINT NOT NULL,
    converted_amount BIGINT NOT NULL,
    status VARCHAR(20) NOT NULL,  -- PENDING, APPROVED, REJECTED
    requested_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    processed_at TIMESTAMP
);

-- conversion_history í…Œì´ë¸” (í™˜ì‚° ë‚´ì—­)
CREATE TABLE conversion_history (
    history_id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36) NOT NULL,
    game_amount BIGINT NOT NULL,
    real_amount BIGINT NOT NULL,
    conversion_rate DECIMAL(5,2) NOT NULL,
    converted_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ì¸ë±ìŠ¤
CREATE INDEX idx_reward_child ON reward_requests(child_id);
CREATE INDEX idx_reward_parent ON reward_requests(parent_id);
CREATE INDEX idx_reward_status ON reward_requests(status, requested_at DESC);
```

### Payment Service DB
```sql
-- payments í…Œì´ë¸”
CREATE TABLE payments (
    payment_id VARCHAR(36) PRIMARY KEY,
    reward_request_id VARCHAR(36) NOT NULL,
    recipient_id VARCHAR(36) NOT NULL,
    amount BIGINT NOT NULL,
    status VARCHAR(20) NOT NULL,  -- PENDING, PROCESSING, COMPLETED, FAILED
    transaction_id VARCHAR(100),
    payment_method VARCHAR(50),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    completed_at TIMESTAMP
);

-- payment_transactions í…Œì´ë¸” (ì™¸ë¶€ ê±°ë˜ ì¶”ì )
CREATE TABLE payment_transactions (
    transaction_id VARCHAR(100) PRIMARY KEY,
    payment_id VARCHAR(36) NOT NULL,
    gateway VARCHAR(50) NOT NULL,  -- TOSS, KAKAO
    raw_response TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (payment_id) REFERENCES payments(payment_id)
);

-- ì¸ë±ìŠ¤
CREATE INDEX idx_payments_recipient ON payments(recipient_id);
CREATE INDEX idx_payments_status ON payments(status, created_at DESC);
```

### Report Service DB
```sql
-- performance_reports í…Œì´ë¸”
CREATE TABLE performance_reports (
    report_id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36) NOT NULL,
    period VARCHAR(20) NOT NULL,  -- WEEKLY, MONTHLY
    start_date DATE NOT NULL,
    end_date DATE NOT NULL,
    total_return DECIMAL(10,2) NOT NULL,
    win_rate DECIMAL(5,2) NOT NULL,
    total_trades INT NOT NULL,
    profitable_trades INT NOT NULL,
    generated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- educational_insights í…Œì´ë¸”
CREATE TABLE educational_insights (
    insight_id VARCHAR(36) PRIMARY KEY,
    report_id VARCHAR(36) NOT NULL,
    category VARCHAR(50) NOT NULL,
    message TEXT NOT NULL,
    level VARCHAR(20) NOT NULL,  -- EXCELLENT, GOOD, WARNING
    FOREIGN KEY (report_id) REFERENCES performance_reports(report_id)
);

-- peer_statistics í…Œì´ë¸” (ë˜ë˜ í†µê³„)
CREATE TABLE peer_statistics (
    stat_id VARCHAR(36) PRIMARY KEY,
    age_group VARCHAR(20) NOT NULL,
    period VARCHAR(20) NOT NULL,
    avg_return DECIMAL(10,2) NOT NULL,
    avg_win_rate DECIMAL(5,2) NOT NULL,
    calculated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ì¸ë±ìŠ¤
CREATE INDEX idx_reports_user_period ON performance_reports(user_id, period, end_date DESC);
CREATE INDEX idx_peer_stats ON peer_statistics(age_group, period);
```

---

## ğŸ” API Gateway êµ¬ì„±

### Kong Gateway ì„¤ì •
```yaml
# kong.yml
_format_version: "3.0"

services:
  - name: user-service
    url: http://user-service:8001
    routes:
      - name: user-routes
        paths:
          - /api/users
        strip_path: false

  - name: game-service
    url: http://game-service:8002
    routes:
      - name: game-routes
        paths:
          - /api/game
        strip_path: false

  - name: reward-service
    url: http://reward-service:8004
    routes:
      - name: reward-routes
        paths:
          - /api/reward
        strip_path: false

plugins:
  - name: jwt
    config:
      key_claim_name: sub
      secret_is_base64: false

  - name: rate-limiting
    config:
      minute: 100
      hour: 1000
      policy: local

  - name: cors
    config:
      origins:
        - "*"
      methods:
        - GET
        - POST
        - PUT
        - DELETE
```

### BFF (Backend for Frontend)
```typescript
// ìë…€ ì•±ìš© BFF
@Controller('bff/child')
export class ChildBFFController {
  constructor(
    private gameService: GameServiceClient,
    private rewardService: RewardServiceClient
  ) {}

  // í™ˆ í™”ë©´ì— í•„ìš”í•œ ëª¨ë“  ë°ì´í„°ë¥¼ í•œ ë²ˆì—
  @Get('dashboard')
  async getDashboard(@CurrentUser() user: User) {
    const [portfolio, performance, pendingRewards] = await Promise.all([
      this.gameService.getPortfolio(user.id),
      this.gameService.getPerformance(user.id),
      this.rewardService.getPendingRequests(user.id)
    ]);

    return {
      portfolio,
      performance,
      pendingRewards,
      canRequestReward: performance.profit > 0
    };
  }
}

// ë¶€ëª¨ ì•±ìš© BFF
@Controller('bff/parent')
export class ParentBFFController {
  constructor(
    private gameService: GameServiceClient,
    private rewardService: RewardServiceClient,
    private reportService: ReportServiceClient
  ) {}

  @Get('children/:childId/overview')
  async getChildOverview(@Param('childId') childId: string) {
    const [portfolio, performance, recentTrades, pendingRewards] = await Promise.all([
      this.gameService.getPortfolio(childId),
      this.gameService.getPerformance(childId),
      this.gameService.getRecentTrades(childId, 10),
      this.rewardService.getPendingRequests(childId)
    ]);

    return {
      portfolio,
      performance,
      recentTrades,
      pendingRewards
    };
  }
}
```

---

## ğŸš€ ë°°í¬ ì•„í‚¤í…ì²˜ (Kubernetes)

### Helm Chart êµ¬ì¡°
```yaml
# values.yaml
global:
  environment: production
  registry: your-registry.azurecr.io

services:
  user-service:
    replicaCount: 3
    image:
      repository: user-service
      tag: "1.0.0"
    resources:
      requests:
        cpu: 100m
        memory: 256Mi
      limits:
        cpu: 500m
        memory: 512Mi
    env:
      - name: DB_HOST
        value: user-db.default.svc.cluster.local
      - name: REDIS_HOST
        value: redis.default.svc.cluster.local

  game-service:
    replicaCount: 5  # ê°€ì¥ ë§ì´ ì‚¬ìš©ë˜ëŠ” ì„œë¹„ìŠ¤
    image:
      repository: game-service
      tag: "1.0.0"
    resources:
      requests:
        cpu: 200m
        memory: 512Mi
      limits:
        cpu: 1000m
        memory: 1Gi
    autoscaling:
      enabled: true
      minReplicas: 5
      maxReplicas: 20
      targetCPUUtilizationPercentage: 70

  # ... ë‹¤ë¥¸ ì„œë¹„ìŠ¤ë“¤
```

### Deployment ì˜ˆì‹œ

yaml

```yaml
# game-service-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: game-service
  labels:
    app: game-service
spec:
  replicas: 5
  selector:
    matchLabels:
      app: game-service
  template:
    metadata:
      labels:
        app: game-service
    spec:
      containers:
      - name: game-service
        image: your-registry/game-service:1.0.0
        ports:
        - containerPort: 8002
        env:
        - name: DB_HOST
          valueFrom:
            configMapKeyRef:
              name: game-config
              key: db.host
        - name: DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: game-secrets
              key: db.password
        resources:
          requests:
            cpu: 200m
            memory: 512Mi
          limits:
            cpu: 1000m
            memory: 1Gi
        livenessProbe:
          httpGet:
            path: /actuator/health
            port: 8002
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /actuator/health/readiness
            port: 8002
          initialDelaySeconds: 20
          periodSeconds: 5
---
apiVersion: v1
kind: Service
metadata:
  name: game-service
spec:
  selector:
    app: game-service
  ports:
  - protocol: TCP
    port: 8002
    targetPort: 8002
  type: ClusterIP
```

### Horizontal Pod Autoscaler

yaml

```yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: game-service-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: game-service
  minReplicas: 5
  maxReplicas: 20
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
```

---

## ğŸ“Š ëª¨ë‹ˆí„°ë§ ë° ê´€ì°°ì„±

### Prometheus + Grafana ì„¤ì •
```yaml
# prometheus-config.yaml
global:
  scrape_interval: 15s

scrape_configs:
  - job_name: 'user-service'
    static_configs:
      - targets: ['user-service:8001']
    metrics_path: '/actuator/prometheus'

  - job_name: 'game-service'
    static_configs:
      - targets: ['game-service:8002']
    metrics_path: '/metrics'

  - job_name: 'reward-service'
    static_configs:
      - targets: ['reward-service:8004']
    metrics_path: '/actuator/prometheus'
```

### ì»¤ìŠ¤í…€ ë©”íŠ¸ë¦­ (Spring Boot)

kotlin

```kotlin
@Component
class GameMetrics(
    private val meterRegistry: MeterRegistry
) {
    private val tradeCounter = meterRegistry.counter("game.trades.total")
    private val profitGauge = meterRegistry.gauge("game.portfolio.profit", emptyList())

    fun recordTrade(type: TradeType) {
        tradeCounter.increment()
        Tags.of("type", type.name)
    }

    fun updateProfit(userId: UserId, profit: Double) {
        profitGauge?.let {
            meterRegistry.gauge(
                "game.portfolio.profit",
                Tags.of("user", userId.value),
                profit
            )
        }
    }
}
```

### Distributed Tracing (Jaeger)

kotlin

```kotlin
// OpenTelemetry ì„¤ì •
@Configuration
class TracingConfig {
    @Bean
    fun openTelemetry(): OpenTelemetry {
        return OpenTelemetrySdk.builder()
            .setTracerProvider(
                SdkTracerProvider.builder()
                    .addSpanProcessor(
                        BatchSpanProcessor.builder(
                            JaegerGrpcSpanExporter.builder()
                                .setEndpoint("http://jaeger:14250")
                                .build()
                        ).build()
                    )
                    .build()
            )
            .buildAndRegisterGlobal()
    }
}

// ì‚¬ìš©
@Service
class GameApplicationService(
    private val tracer: Tracer
) {
    fun executeTrade(command: ExecuteTradeCommand): TradeResult {
        val span = tracer.spanBuilder("executeTrade").startSpan()
        try {
            span.setAttribute("user.id", command.userId.value)
            span.setAttribute("stock.symbol", command.stock.symbol)
            
            // ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§
            val result = performTrade(command)
            
            span.setStatus(StatusCode.OK)
            return result
        } catch (e: Exception) {
            span.recordException(e)
            span.setStatus(StatusCode.ERROR)
            throw e
        } finally {
            span.end()
        }
    }
}
```

---

## ğŸ”’ ë³´ì•ˆ ê°•í™”

### JWT í† í° ê²€ì¦ (API Gateway)
```typescript
@Injectable()
export class JwtAuthGuard implements CanActivate {
  canActivate(context: ExecutionContext): boolean {
    const request = context.switchToHttp().getRequest();
    const token = this.extractToken(request);
    
    if (!token) {
      throw new UnauthorizedException('í† í°ì´ ì—†ìŠµë‹ˆë‹¤');
    }

    try {
      const payload = jwt.verify(token, process.env.JWT_SECRET);
      
      // ì—­í•  ê¸°ë°˜ ì ‘ê·¼ ì œì–´
      const requiredRole = this.reflector.get<string>('role', context.getHandler());
      if (requiredRole && payload.role !== requiredRole) {
        throw new ForbiddenException('ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤');
      }

      request.user = payload;
      return true;
    } catch (e) {
      throw new UnauthorizedException('ìœ íš¨í•˜ì§€ ì•Šì€ í† í°ì…ë‹ˆë‹¤');
    }
  }

  private extractToken(request: any): string | null {
    const authHeader = request.headers.authorization;
    if (!authHeader?.startsWith('Bearer ')) {
      return null;
    }
    return authHeader.substring(7);
  }
}

// ì‚¬ìš©
@Controller('api/reward')
export class RewardController {
  @Post('request')
  @Roles('CHILD')  // ìë…€ë§Œ ê°€ëŠ¥
  @UseGuards(JwtAuthGuard, RolesGuard)
  async requestReward(@CurrentUser() user: User, @Body() dto: RequestRewardDto) {
    // ...
  }

  @Put(':requestId/approve')
  @Roles('PARENT')  // ë¶€ëª¨ë§Œ ê°€ëŠ¥
  @UseGuards(JwtAuthGuard, RolesGuard)
  async approveReward(@Param('requestId') requestId: string, @CurrentUser() user: User) {
    // ...
  }
}
```

### Rate Limiting (ì„œë¹„ìŠ¤ë³„)

kotlin

```kotlin
@Configuration
class RateLimitConfig {
    @Bean
    fun rateLimiter(): RateLimiter {
        return RateLimiterRegistry.of(
            RateLimiterConfig.custom()
                .limitForPeriod(10)  // 10 requests
                .limitRefreshPeriod(Duration.ofMinutes(1))  // per minute
                .timeoutDuration(Duration.ofSeconds(5))
                .build()
        ).rateLimiter("trade-limiter")
    }
}

@Service
class GameApplicationService(
    @Qualifier("trade-limiter") private val rateLimiter: RateLimiter
) {
    fun executeTrade(command: ExecuteTradeCommand): TradeResult {
        return Try.ofSupplier(
            Supplier.decorateCheckedSupplier(rateLimiter) {
                performTrade(command)
            }
        ).get()
    }
}
```

---

## ğŸ§ª í…ŒìŠ¤íŠ¸ ì „ëµ

### ë„ë©”ì¸ ë¡œì§ í…ŒìŠ¤íŠ¸ (Unit Test)

```kotlin
class PortfolioTest {
    @Test
    fun `ì£¼ì‹ ë§¤ìˆ˜ ì‹œ ì”ì•¡ì´ ì°¨ê°ëœë‹¤`() {
        // given
        val portfolio = Portfolio(
            portfolioId = PortfolioId.generate(),
            userId = UserId.generate(),
            gameBalance = Money(100000, Currency.GAME),
            holdings = mutableListOf()
        )
        val stock = Stock("005930", "ì‚¼ì„±ì „ì")
        val price = Money(70000, Currency.GAME)

        // when
        portfolio.buyStock(stock, 1, price)

        // then
        assertThat(portfolio.gameBalance.amount).isEqualTo(30000)
        assertThat(portfolio.holdings).hasSize(1)
        assertThat(portfolio.holdings[0].quantity).isEqualTo(1)
    }

    @Test
    fun `ì”ì•¡ì´ ë¶€ì¡±í•˜ë©´ ë§¤ìˆ˜í•  ìˆ˜ ì—†ë‹¤`() {
        // given
        val portfolio = Portfolio(
            portfolioId = PortfolioId.generate(),
            userId = UserId.generate(),
            gameBalance = Money(50000, Currency.GAME),
            holdings = mutableListOf()
        )
        val stock = Stock("005930", "ì‚¼ì„±ì „ì")
        val price = Money(70000, Currency.GAME)

        // when & then
        assertThrows<InsufficientBalanceError> {
            portfolio.buyStock(stock, 1, price)
        }
    }
}
```

### í†µí•© í…ŒìŠ¤íŠ¸ (Integration Test)

kotlin

```kotlin
@SpringBootTest
@AutoConfigureTestDatabase
class GameServiceIntegrationTest {
    @Autowired
    lateinit var gameService: GameApplicationService

    @Autowired
    lateinit var portfolioRepository: PortfolioRepository

    @Test
    @Transactional
    fun `ê±°ë˜ ì‹¤í–‰ í›„ DBì— ì €ì¥ëœë‹¤`() {
        // given
        val userId = UserId.generate()
        val portfolio = createTestPortfolio(userId)
        portfolioRepository.save(portfolio)

        val command = ExecuteTradeCommand(
            portfolioId = portfolio.portfolioId,
            stock = Stock("005930", "ì‚¼ì„±ì „ì"),
            type = TradeType.BUY,
            quantity = 1
        )

        // when
        val result = gameService.executeTrade(command)

        // then
        val savedPortfolio = portfolioRepository.findById(portfolio.portfolioId)
        assertThat(savedPortfolio).isNotNull
        assertThat(savedPortfolio!!.holdings).hasSize(1)
    }
}
```

### ì»¨íŠ¸ë™íŠ¸ í…ŒìŠ¤íŠ¸ (Contract Test - Pact

ì„±

ê³„ì†

)

kotlin

```kotlin
// Consumer (Reward Service) - Producer (Game Service) ê³„ì•½ ì •ì˜
@ExtendWith(PactConsumerTestExt::class)
@PactTestFor(providerName = "game-service")
class GameServiceContractTest {

    @Pact(consumer = "reward-service")
    fun getPerformancePact(builder: PactDslWithProvider): RequestResponsePact {
        return builder
            .given("user has a portfolio with positive returns")
            .uponReceiving("a request for performance data")
            .path("/api/game/performance/user-123")
            .method("GET")
            .willRespondWith()
            .status(200)
            .body(
                PactDslJsonBody()
                    .stringValue("userId", "user-123")
                    .decimalType("returnRate", 15.5)
                    .integerType("profitAmount", 15000)
                    .integerType("totalValue", 115000)
            )
            .toPact()
    }

    @Test
    @PactTestFor(pactMethod = "getPerformancePact")
    fun testPerformanceEndpoint(mockServer: MockServer) {
        // given
        val gameClient = GameServiceClient(mockServer.getUrl())

        // when
        val performance = gameClient.getPerformance("user-123")

        // then
        assertThat(performance.returnRate).isEqualTo(15.5)
        assertThat(performance.profitAmount).isEqualTo(15000)
    }
}
```

### E2E í…ŒìŠ¤íŠ¸ (Cypress)

typescript

```typescript
// cypress/e2e/allowance-flow.cy.ts
describe('ìš©ëˆ ìš”ì²­ í”Œë¡œìš°', () => {
  beforeEach(() => {
    // ìë…€ ê³„ì •ìœ¼ë¡œ ë¡œê·¸ì¸
    cy.login('child@example.com', 'password')
  })

  it('ìˆ˜ìµì´ ìˆì„ ë•Œ ìš©ëˆì„ ìš”ì²­í•  ìˆ˜ ìˆë‹¤', () => {
    // í¬íŠ¸í´ë¦¬ì˜¤ í˜ì´ì§€ ì´ë™
    cy.visit('/portfolio')
    
    // ìˆ˜ìµë¥  í™•ì¸
    cy.contains('+15%').should('be.visible')
    cy.contains('15,000ì› ìˆ˜ìµ').should('be.visible')

    // ìš©ëˆ ìš”ì²­ ë²„íŠ¼ í´ë¦­
    cy.contains('ìš©ëˆ ìš”ì²­í•˜ê¸°').click()

    // í™˜ì‚° ê¸ˆì•¡ í™•ì¸
    cy.contains('1,500ì›').should('be.visible')
    cy.contains('í™•ì¸').click()

    // ì„±ê³µ ë©”ì‹œì§€
    cy.contains('ìš©ëˆ ìš”ì²­ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤').should('be.visible')
  })

  it('ë¶€ëª¨ê°€ ìš©ëˆ ìš”ì²­ì„ ìŠ¹ì¸í•œë‹¤', () => {
    // ë¶€ëª¨ ê³„ì •ìœ¼ë¡œ ì „í™˜
    cy.logout()
    cy.login('parent@example.com', 'password')

    // ì•Œë¦¼ í™•ì¸
    cy.visit('/notifications')
    cy.contains('ìë…€ê°€ 1,500ì› ìš©ëˆì„ ìš”ì²­í–ˆìŠµë‹ˆë‹¤').click()

    // ìƒì„¸ í˜ì´ì§€ì—ì„œ ìŠ¹ì¸
    cy.contains('ìŠ¹ì¸').click()
    cy.contains('ìš©ëˆì´ ì§€ê¸‰ë˜ì—ˆìŠµë‹ˆë‹¤').should('be.visible')
  })
})
```

---

## ğŸ“ˆ ì„±ëŠ¥ ìµœì í™” ì „ëµ

### 1ï¸âƒ£ ìºì‹± ì „ëµ

#### ë‹¤ì¸µ ìºì‹± êµ¬ì¡°
```typescript
@Injectable()
export class CachedMarketDataService {
  constructor(
    private redisClient: Redis,
    private marketDataAdapter: MarketDataAdapter
  ) {}

  async getCurrentPrice(stock: Stock): Promise<Money> {
    const cacheKey = `price:${stock.symbol}`;

    // L1: Redis ìºì‹œ í™•ì¸
    const cachedPrice = await this.redisClient.get(cacheKey);
    if (cachedPrice) {
      return new Money(parseFloat(cachedPrice), 'GAME');
    }

    // L2: API í˜¸ì¶œ
    const freshPrice = await this.marketDataAdapter.getCurrentPrice(stock);

    // ìºì‹œ ì €ì¥ (5ì´ˆ TTL)
    await this.redisClient.setex(cacheKey, 5, freshPrice.amount.toString());

    return freshPrice;
  }

  // ë°°ì¹˜ë¡œ ì—¬ëŸ¬ ì¢…ëª© ì¡°íšŒ (N+1 ë¬¸ì œ í•´ê²°)
  async getCurrentPrices(stocks: Stock[]): Promise<Map<Stock, Money>> {
    const pipeline = this.redisClient.pipeline();
    
    // í•œ ë²ˆì— ì—¬ëŸ¬ í‚¤ ì¡°íšŒ
    stocks.forEach(stock => {
      pipeline.get(`price:${stock.symbol}`);
    });

    const cachedResults = await pipeline.exec();
    const prices = new Map<Stock, Money>();
    const uncachedStocks: Stock[] = [];

    stocks.forEach((stock, index) => {
      const [err, result] = cachedResults[index];
      if (!err && result) {
        prices.set(stock, new Money(parseFloat(result as string), 'GAME'));
      } else {
        uncachedStocks.push(stock);
      }
    });

    // ìºì‹œ ë¯¸ìŠ¤ í•­ëª©ë§Œ API í˜¸ì¶œ
    if (uncachedStocks.length > 0) {
      const freshPrices = await this.marketDataAdapter.batchGetPrices(uncachedStocks);
      
      // íŒŒì´í”„ë¼ì¸ìœ¼ë¡œ í•œ ë²ˆì— ìºì‹œ ì €ì¥
      const setPipeline = this.redisClient.pipeline();
      freshPrices.forEach((price, stock) => {
        prices.set(stock, price);
        setPipeline.setex(`price:${stock.symbol}`, 5, price.amount.toString());
      });
      await setPipeline.exec();
    }

    return prices;
  }
}
```

#### Application-Level ìºì‹± (Caffeine)

kotlin

```kotlin
@Configuration
class CacheConfig {
    @Bean
    fun cacheManager(): CacheManager {
        return CaffeineCacheManager().apply {
            setCaffeine(
                Caffeine.newBuilder()
                    .maximumSize(10_000)
                    .expireAfterWrite(10, TimeUnit.MINUTES)
                    .recordStats()
            )
        }
    }
}

@Service
class UserService {
    @Cacheable(value = ["users"], key = "#userId")
    fun findUser(userId: UserId): User {
        // DB ì¡°íšŒ
        return userRepository.findById(userId)
    }

    @CacheEvict(value = ["users"], key = "#user.userId")
    fun updateUser(user: User) {
        userRepository.save(user)
    }
}
```

### 2ï¸âƒ£ ë°ì´í„°ë² ì´ìŠ¤ ìµœì í™”

#### ì¸ë±ìŠ¤ ì „ëµ
```sql
-- ë³µí•© ì¸ë±ìŠ¤ (ìì£¼ í•¨ê»˜ ì¡°íšŒë˜ëŠ” ì»¬ëŸ¼)
CREATE INDEX idx_trades_user_date 
ON trades(portfolio_id, executed_at DESC)
INCLUDE (stock_symbol, trade_type, quantity, price);

-- ë¶€ë¶„ ì¸ë±ìŠ¤ (ì¡°ê±´ë¶€ ì¸ë±ìŠ¤)
CREATE INDEX idx_pending_rewards 
ON reward_requests(parent_id, requested_at DESC)
WHERE status = 'PENDING';

-- ì»¤ë²„ë§ ì¸ë±ìŠ¤ (ì¿¼ë¦¬ì— í•„ìš”í•œ ëª¨ë“  ì»¬ëŸ¼ í¬í•¨)
CREATE INDEX idx_portfolio_summary 
ON portfolios(user_id)
INCLUDE (game_balance, updated_at);
```

#### ì¿¼ë¦¬ ìµœì í™”

kotlin

```kotlin
// N+1 ë¬¸ì œ í•´ê²° - Fetch Join
@Repository
interface PortfolioRepository : JpaRepository<Portfolio, PortfolioId> {
    @Query("""
        SELECT p FROM Portfolio p
        LEFT JOIN FETCH p.holdings h
        WHERE p.userId = :userId
    """)
    fun findByUserIdWithHoldings(@Param("userId") userId: UserId): Portfolio?

    // ë°°ì¹˜ ì¡°íšŒ
    @Query("""
        SELECT p FROM Portfolio p
        WHERE p.userId IN :userIds
    """)
    fun findByUserIds(@Param("userIds") userIds: List<UserId>): List<Portfolio>
}
```

#### Read Replica ë¶„ë¦¬

yaml

```yaml
# application.yml
spring:
  datasource:
    hikari:
      maximum-pool-size: 20
    master:
      url: jdbc:postgresql://master-db:5432/gamedb
      username: ${DB_USER}
      password: ${DB_PASSWORD}
    slave:
      url: jdbc:postgresql://replica-db:5432/gamedb
      username: ${DB_USER}
      password: ${DB_PASSWORD}
      read-only: true
```

kotlin

```kotlin
@Configuration
class DataSourceConfig {
    
    @Bean
    @Primary
    fun routingDataSource(
        @Qualifier("masterDataSource") master: DataSource,
        @Qualifier("slaveDataSource") slave: DataSource
    ): DataSource {
        val dataSources = mapOf(
            "master" to master,
            "slave" to slave
        )

        return RoutingDataSource().apply {
            setTargetDataSources(dataSources as Map<Any, Any>)
            setDefaultTargetDataSource(master)
        }
    }
}

// ì‚¬ìš©
@Transactional(readOnly = true)  // Slaveë¡œ ë¼ìš°íŒ…
fun getPortfolio(userId: UserId): Portfolio {
    return portfolioRepository.findById(userId)
}

@Transactional  // Masterë¡œ ë¼ìš°íŒ…
fun executeTrade(command: ExecuteTradeCommand) {
    // ...
}
```

### 3ï¸âƒ£ ë¹„ë™ê¸° ì²˜ë¦¬

#### ë¦¬í¬íŠ¸ ìƒì„± ë¹„ë™ê¸°í™”
```kotlin
@Service
class ReportApplicationService(
    private val reportRepository: ReportRepository,
    @Async private val executor: TaskExecutor
) {
    
    @Async("reportExecutor")
    fun generateMonthlyReportAsync(userId: UserId): CompletableFuture<ReportId> {
        return CompletableFuture.supplyAsync({
            val report = generateMonthlyReport(userId)
            reportRepository.save(report)
            report.reportId
        }, executor)
    }
}

@Configuration
class AsyncConfig {
    @Bean("reportExecutor")
    fun reportTaskExecutor(): ThreadPoolTaskExecutor {
        return ThreadPoolTaskExecutor().apply {
            corePoolSize = 5
            maxPoolSize = 10
            queueCapacity = 100
            setThreadNamePrefix("report-")
            initialize()
        }
    }
}
```

#### ì´ë²¤íŠ¸ ì²˜ë¦¬ ë³‘ë ¬í™”

typescript

```typescript
@Injectable()
export class ParallelEventProcessor {
  constructor(
    private notificationService: NotificationService,
    private analyticsService: AnalyticsService
  ) {}

  async processTradeExecutedEvent(event: TradeExecutedEvent): Promise<void> {
    // ì—¬ëŸ¬ ì‘ì—…ì„ ë³‘ë ¬ë¡œ ì²˜ë¦¬
    await Promise.all([
      this.notificationService.sendPushNotification(event.userId, {
        title: 'ê±°ë˜ ì™„ë£Œ',
        body: `${event.stock} ${event.type} ${event.quantity}ì£¼`
      }),
      this.analyticsService.trackTrade(event),
      this.updatePortfolioCache(event.userId)
    ]);
  }
}
```

---

## ğŸ”„ CI/CD íŒŒì´í”„ë¼ì¸

### GitHub Actions Workflow
```yaml
# .github/workflows/deploy.yml
name: CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service: [user-service, game-service, reward-service, payment-service, report-service]
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up JDK 17
        uses: actions/setup-java@v3
        with:
          java-version: '17'
          distribution: 'temurin'
      
      - name: Run Tests
        run: |
          cd services/${{ matrix.service }}
          ./gradlew test
      
      - name: Upload Coverage
        uses: codecov/codecov-action@v3
        with:
          file: services/${{ matrix.service }}/build/reports/jacoco/test/jacocoTestReport.xml

  build:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Login to Container Registry
        uses: docker/login-action@v2
        with:
          registry: ${{ secrets.REGISTRY_URL }}
          username: ${{ secrets.REGISTRY_USERNAME }}
          password: ${{ secrets.REGISTRY_PASSWORD }}
      
      - name: Build and Push Docker Images
        run: |
          for service in user-service game-service reward-service payment-service report-service; do
            docker build -t ${{ secrets.REGISTRY_URL }}/$service:${{ github.sha }} ./services/$service
            docker push ${{ secrets.REGISTRY_URL }}/$service:${{ github.sha }}
          done

  deploy:
    needs: build
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Configure kubectl
        uses: azure/setup-kubectl@v3
      
      - name: Deploy to Kubernetes
        run: |
          kubectl set image deployment/user-service \
            user-service=${{ secrets.REGISTRY_URL }}/user-service:${{ github.sha }}
          kubectl set image deployment/game-service \
            game-service=${{ secrets.REGISTRY_URL }}/game-service:${{ github.sha }}
          # ... ë‹¤ë¥¸ ì„œë¹„ìŠ¤ë“¤
      
      - name: Wait for Rollout
        run: |
          kubectl rollout status deployment/user-service
          kubectl rollout status deployment/game-service
          # ... ë‹¤ë¥¸ ì„œë¹„ìŠ¤ë“¤
```

### ArgoCD GitOps ì„¤ì •

yaml

```yaml
# argocd/application.yaml
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: fintech-platform
  namespace: argocd
spec:
  project: default
  source:
    repoURL: https://github.com/your-org/fintech-platform
    targetRevision: HEAD
    path: k8s/overlays/production
  destination:
    server: https://kubernetes.default.svc
    namespace: production
  syncPolicy:
    automated:
      prune: true
      selfHeal: true
    syncOptions:
      - CreateNamespace=true
```

---

## ğŸ¯ í™•ì¥ ì‹œë‚˜ë¦¬ì˜¤

### 1ï¸âƒ£ ê¸€ë¡œë²Œ í™•ì¥ (Multi-Region)

```
[Asia Region]                    [US Region]
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Gateway   â”‚                 â”‚   Gateway   â”‚
â”‚  (Seoul)    â”‚                 â”‚  (Oregon)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚                               â”‚
â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”                   â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”
â”‚ Services  â”‚                   â”‚ Services  â”‚
â”‚   (KR)    â”‚ â—„â”€â”€â”€â”€ Sync â”€â”€â”€â”€â”€â–º â”‚   (US)    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚                               â”‚
â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”                   â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”
â”‚ RDS/Redis â”‚                   â”‚ RDS/Redis â”‚
â”‚  (Seoul)  â”‚ â—„â”€â”€ Replicate â”€â”€â–º â”‚ (Oregon)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### ì§€ì—­ë³„ ë¼ìš°íŒ…

typescript

```typescript
// Global Traffic Manager
@Injectable()
export class RegionRouter {
  route(request: Request): string {
    const userLocation = this.getUserLocation(request);
    
    // ìµœì  ë¦¬ì „ ì„ íƒ
    if (userLocation.country === 'KR') {
      return 'https://api-kr.yourservice.com';
    } else if (userLocation.country === 'US') {
      return 'https://api-us.yourservice.com';
    }
    
    return 'https://api-global.yourservice.com';
  }
}
```

### 2ï¸âƒ£ ì•”í˜¸í™”í ì¶”ê°€

typescript

```typescript
// ê¸°ì¡´ Stockì„ í™•ì¥
interface Asset {
  symbol: string;
  name: string;
  type: 'STOCK' | 'CRYPTO';
}

class CryptoAsset implements Asset {
  type: 'CRYPTO' = 'CRYPTO';
  
  constructor(
    public symbol: string,
    public name: string,
    public blockchain: 'BTC' | 'ETH'
  ) {}
}

// Portfolio ë„ë©”ì¸ì—ì„œ ì²˜ë¦¬
class Portfolio {
  buyAsset(asset: Asset, quantity: number, price: Money): Trade {
    if (asset.type === 'CRYPTO') {
      return this.buyCrypto(asset as CryptoAsset, quantity, price);
    } else {
      return this.buyStock(asset, quantity, price);
    }
  }
  
  private buyCrypto(crypto: CryptoAsset, quantity: number, price: Money): Trade {
    // ì•”í˜¸í™”í íŠ¹í™” ë¡œì§ (ì†Œìˆ˜ì  ì²˜ë¦¬ ë“±)
    // ...
  }
}
```

### 3ï¸âƒ£ AI íˆ¬ì ì¡°ì–¸ ì„œë¹„ìŠ¤

typescript

```typescript
// AI Service ì¶”ê°€
@Injectable()
export class AIAdvisorService {
  constructor(
    private openaiClient: OpenAI,
    private portfolioService: PortfolioService,
    private marketDataService: MarketDataService
  ) {}

  async getInvestmentAdvice(userId: UserId): Promise<InvestmentAdvice> {
    // í¬íŠ¸í´ë¦¬ì˜¤ ë¶„ì„
    const portfolio = await this.portfolioService.getPortfolio(userId);
    const performance = await this.portfolioService.getPerformance(userId);
    
    // ì‹œì¥ ë°ì´í„° ìˆ˜ì§‘
    const marketTrends = await this.marketDataService.getTrends();
    
    // AI ë¶„ì„ ìš”ì²­
    const prompt = `
      ì‚¬ìš©ì í¬íŠ¸í´ë¦¬ì˜¤:
      - ë³´ìœ  ì¢…ëª©: ${portfolio.holdings.map(h => h.stock.name).join(', ')}
      - ìˆ˜ìµë¥ : ${performance.returnRate}%
      - ìœ„í—˜ë„: ${this.calculateRisk(portfolio)}
      
      ì‹œì¥ ìƒí™©:
      ${marketTrends}
      
      ì´ˆë³´ íˆ¬ììë¥¼ ìœ„í•œ ë§ì¶¤ ì¡°ì–¸ì„ ì œê³µí•´ì£¼ì„¸ìš”.
    `;
    
    const response = await this.openaiClient.chat.completions.create({
      model: 'gpt-4',
      messages: [{ role: 'user', content: prompt }]
    });
    
    return new InvestmentAdvice(response.choices[0].message.content);
  }
}
```

---

## ğŸ“š ê¸°ìˆ  ë¬¸ì„œí™”

#### API ë¬¸ì„œ (Swagger/OpenAPI)
```kotlin
@Configuration
class SwaggerConfig {
    @Bean
    fun api(): Docket {
        return Docket(DocumentationType.OAS_30)
            .select()
            .apis(RequestHandlerSelectors.basePackage("com.fintech"))
            .paths(PathSelectors.ant("/api/**"))
            .build()
            .apiInfo(apiInfo())
    }

    private fun apiInfo(): ApiInfo {
        return ApiInfoBuilder()
            .title("ê¸ˆìœµêµìœ¡ í”Œë«í¼ API")
            .description("ê²Œì„í™”ëœ íˆ¬ì êµìœ¡ ì„œë¹„ìŠ¤")
            .version("1.0.0")
            .build()
    }
}
```

#### ì•„í‚¤í…ì²˜ ê²°ì • ê¸°ë¡ (ADR)
```markdown
```
```
# ADR 001: ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ ì•„í‚¤í…ì²˜ ì±„íƒ

## ìƒíƒœ
ìŠ¹ì¸ë¨ (2025-01-15)

## ì»¨í…ìŠ¤íŠ¸
ì„œë¹„ìŠ¤ê°€ ë‹¤ìŒê³¼ ê°™ì€ íŠ¹ì„±ì„ ê°€ì§€ê³  ìˆìŒ:
- ë…ë¦½ì ì¸ ë„ë©”ì¸ (íˆ¬ì ê²Œì„, ìš©ëˆ ê´€ë¦¬, ë¦¬í¬íŠ¸)
- ê° ë„ë©”ì¸ë³„ ìŠ¤ì¼€ì¼ë§ ìš”êµ¬ì‚¬í•­ ìƒì´
- íŒ€ë³„ ë…ë¦½ ê°œë°œ/ë°°í¬ í•„ìš”

## ê²°ì •
MSA + DDD ì•„í‚¤í…ì²˜ë¥¼ ì±„íƒí•˜ê³ , 5ê°œì˜ í•µì‹¬ ì„œë¹„ìŠ¤ë¡œ ë¶„ë¦¬

## ê²°ê³¼
### ê¸ì •ì 
- ì„œë¹„ìŠ¤ë³„ ë…ë¦½ ë°°í¬ ê°€ëŠ¥
- ì¥ì•  ê²©ë¦¬ (í•œ ì„œë¹„ìŠ¤ ì¥ì• ê°€ ì „ì²´ ì˜í–¥ ìµœì†Œí™”)
- ê¸°ìˆ  ìŠ¤íƒ ìœ ì—°ì„± (Kotlin/Node.js í˜¼ìš©)

### ë¶€ì •ì 
- ë¶„ì‚° íŠ¸ëœì­ì…˜ ë³µì¡ë„ ì¦ê°€
- ë„¤íŠ¸ì›Œí¬ ì˜¤ë²„í—¤ë“œ
- ìš´ì˜ ë³µì¡ë„ ì¦ê°€
```

---

## ğŸš¦ ì¥ì•  ëŒ€ì‘ ì‹œë‚˜ë¦¬ì˜¤

### Circuit Breaker íŒ¨í„´
```typescript
@Injectable()
export class ResilientGameServiceClient {
  private circuitBreaker: CircuitBreaker;

  constructor(private gameService: GameServiceClient) {
    this.circuitBreaker = new CircuitBreaker(
      async (userId: string) => {
        return await this.gameService.getPerformance(userId);
      },
      {
        timeout: 3000,        // 3ì´ˆ íƒ€ì„ì•„ì›ƒ
        errorThresholdPercentage: 50,
        resetTimeout: 30000   // 30ì´ˆ í›„ ì¬ì‹œë„
      }
    );

    // Fallback ì„¤ì •
    this.circuitBreaker.fallback((userId: string) => {
      // ìºì‹œëœ ë°ì´í„° ë°˜í™˜ ë˜ëŠ” ê¸°ë³¸ê°’
      return this.getCachedPerformance(userId);
    });
  }

  async getPerformance(userId: string): Promise<Performance> {
    return await this.circuitBreaker.fire(userId);
  }
}
```

### Retry íŒ¨í„´
```kotlin
@Configuration
class RetryConfig {
    @Bean
    fun retryTemplate(): RetryTemplate {
        return RetryTemplate.builder()
            .maxAttempts(3)
            .exponentialBackoff(100, 2.0, 2000)
            .retryOn(RemoteServiceException::class.java)
            .build()
    }
}

@Service
class PaymentService(
    private val retryTemplate: RetryTemplate,
    private val paymentGateway: PaymentGateway
) {
    fun processPayment(request: PaymentRequest): PaymentResult {
        return retryTemplate.execute<PaymentResult, RemoteServiceException> {
            paymentGateway.transfer(request)
        }
    }
}
```

---

## ğŸ“Š ìµœì¢… ì•„í‚¤í…ì²˜ ìš”ì•½

### í•µì‹¬ ì„¤ê³„ ì›ì¹™

```
âœ… Domain-Driven Design (DDD)
   - ë°”ìš´ë””ë“œ ì»¨í…ìŠ¤íŠ¸ ëª…í™•íˆ ë¶„ë¦¬
   - í’ë¶€í•œ ë„ë©”ì¸ ëª¨ë¸ (Rich Domain Model)
   - ë„ë©”ì¸ ì´ë²¤íŠ¸ í™œìš©

âœ… Microservices Architecture (MSA)
   - ì„œë¹„ìŠ¤ë³„ ë…ë¦½ ë°°í¬/í™•ì¥
   - ëŠìŠ¨í•œ ê²°í•© (Loose Coupling)
   - ì´ë²¤íŠ¸ ê¸°ë°˜ í†µì‹ 

âœ… Cloud Native
   - ì»¨í…Œì´ë„ˆ ê¸°ë°˜ (Docker/K8s)
   - ë¬´ìƒíƒœ ì„œë¹„ìŠ¤ (Stateless)
   - íƒ„ë ¥ì  í™•ì¥ (Auto-scaling)

âœ… ê´€ì°°ì„± (Observability)
   - ë©”íŠ¸ë¦­, ë¡œê·¸, íŠ¸ë ˆì´ì‹±
   - ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§
   - ì•Œë¦¼ ë° ëŒ€ì‘ ìë™í™”
```

### ì„œë¹„ìŠ¤ ë§µ

```
User Service â”€â”€â”€â”€â”€â”€â”€â”€â”
                     â”‚
Game Service â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â–º API Gateway â”€â”€â”€â–º Client Apps
                     â”‚
Reward Service â”€â”€â”€â”€â”€â”€â”¤
                     â”‚
Payment Service â”€â”€â”€â”€â”€â”¤
                     â”‚
Report Service â”€â”€â”€â”€â”€â”€â”˜

        â–²
        â”‚ Events (RabbitMQ)
        â–¼

Notification Service
```