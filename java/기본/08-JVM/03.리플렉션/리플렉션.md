## 리플렉션이란?

- **런타임**에 클래스 정보 조회/조작
- 클래스, 메서드, 필드에 **동적 접근**

---

## Class 객체 얻기
```java
// 1. 클래스명.class
Class<User> clazz1 = User.class;

// 2. 인스턴스.getClass()
User user = new User();
Class<? extends User> clazz2 = user.getClass();

// 3. Class.forName()
Class<?> clazz3 = Class.forName("com.example.User");
```

---

## 클래스 정보 조회
```java
Class<User> clazz = User.class;

// 기본 정보
clazz.getName();           // com.example.User
clazz.getSimpleName();     // User
clazz.getPackageName();    // com.example
clazz.getSuperclass();     // class java.lang.Object
clazz.getInterfaces();     // 구현 인터페이스들

// 수정자
int mod = clazz.getModifiers();
Modifier.isPublic(mod);    // true
Modifier.isAbstract(mod);  // false
```

---

## 필드 접근
```java
public class User {
    public String name;
    private int age;
    private static int count;
}
```
```java
Class<User> clazz = User.class;

// 필드 조회
Field[] fields = clazz.getDeclaredFields();  // 모든 필드 (private 포함)
Field[] fields = clazz.getFields();          // public만

// 특정 필드
Field nameField = clazz.getDeclaredField("name");
Field ageField = clazz.getDeclaredField("age");

// 필드 정보
nameField.getName();    // name
nameField.getType();    // class java.lang.String

// 값 읽기/쓰기
User user = new User();
nameField.set(user, "Kim");
String name = (String) nameField.get(user);

// private 필드 접근
ageField.setAccessible(true);  // 접근 허용!
ageField.set(user, 25);
int age = (int) ageField.get(user);
```

---

## 메서드 호출
```java
public class Calculator {
    public int add(int a, int b) {
        return a + b;
    }
    
    private void secret() {
        System.out.println("비밀!");
    }
}
```
```java
Class<Calculator> clazz = Calculator.class;

// 메서드 조회
Method[] methods = clazz.getDeclaredMethods();

// 특정 메서드 (이름, 파라미터 타입)
Method addMethod = clazz.getDeclaredMethod("add", int.class, int.class);
Method secretMethod = clazz.getDeclaredMethod("secret");

// 메서드 정보
addMethod.getName();           // add
addMethod.getReturnType();     // int
addMethod.getParameterTypes(); // [int, int]

// 메서드 호출
Calculator calc = new Calculator();
int result = (int) addMethod.invoke(calc, 10, 20);  // 30

// private 메서드 호출
secretMethod.setAccessible(true);
secretMethod.invoke(calc);  // "비밀!"
```

---

## 생성자
```java
public class User {
    private String name;
    
    public User() { }
    public User(String name) { this.name = name; }
}
```
```java
Class<User> clazz = User.class;

// 생성자 조회
Constructor<?>[] constructors = clazz.getDeclaredConstructors();

// 특정 생성자
Constructor<User> noArg = clazz.getDeclaredConstructor();
Constructor<User> withName = clazz.getDeclaredConstructor(String.class);

// 인스턴스 생성
User user1 = noArg.newInstance();
User user2 = withName.newInstance("Kim");
```

---

## 어노테이션 조회
```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface Column {
    String name() default "";
}

public class User {
    @Column(name = "user_name")
    private String name;
}
```
```java
Field field = User.class.getDeclaredField("name");

// 어노테이션 확인
if (field.isAnnotationPresent(Column.class)) {
    Column column = field.getAnnotation(Column.class);
    System.out.println(column.name());  // user_name
}

// 모든 어노테이션
Annotation[] annotations = field.getAnnotations();
```

---

## 실전 예제

### 간단한 ObjectMapper
```java
public class SimpleMapper {
    
    public static <T> T toObject(Map<String, Object> map, Class<T> clazz) 
            throws Exception {
        T instance = clazz.getDeclaredConstructor().newInstance();
        
        for (Field field : clazz.getDeclaredFields()) {
            field.setAccessible(true);
            String fieldName = field.getName();
            
            if (map.containsKey(fieldName)) {
                field.set(instance, map.get(fieldName));
            }
        }
        return instance;
    }
    
    public static Map<String, Object> toMap(Object obj) throws Exception {
        Map<String, Object> map = new HashMap<>();
        
        for (Field field : obj.getClass().getDeclaredFields()) {
            field.setAccessible(true);
            map.put(field.getName(), field.get(obj));
        }
        return map;
    }
}

// 사용
Map<String, Object> data = Map.of("name", "Kim", "age", 25);
User user = SimpleMapper.toObject(data, User.class);
```

### 메서드 프록시
```java
public static Object createProxy(Object target) {
    return Proxy.newProxyInstance(
        target.getClass().getClassLoader(),
        target.getClass().getInterfaces(),
        (proxy, method, args) -> {
            System.out.println("Before: " + method.getName());
            Object result = method.invoke(target, args);
            System.out.println("After: " + method.getName());
            return result;
        }
    );
}
```

---

## 주의사항

|단점|설명|
|---|---|
|성능|일반 호출보다 느림|
|타입 안전성|컴파일 타임 체크 X|
|캡슐화 위반|private 접근 가능|
|유지보수|리팩토링 시 문제|
```java
// 성능 비교
// 일반 호출: ~1ns
// 리플렉션: ~100ns
```

---

## 활용 사례

|분야|예시|
|---|---|
|프레임워크|Spring DI, JPA|
|테스트|JUnit, Mockito|
|직렬화|Jackson, Gson|
|ORM|Hibernate|

---

> [!tip] 핵심 정리
> 
> - **Class 객체**: 클래스 메타정보
> - **Field**: 필드 접근/수정
> - **Method**: 메서드 호출
> - **Constructor**: 객체 생성
> - **setAccessible(true)**: private 접근
> - 프레임워크 핵심 기술이지만 남용 주의

---

#Java #리플렉션 #Reflection #JVM