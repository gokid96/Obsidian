## 클래스로더란?

- **.class 파일**을 JVM 메모리에 로드
- **동적 로딩** (필요할 때 로드)

---

## 클래스로더 계층
```
        ┌─────────────────────┐
        │ Bootstrap ClassLoader│  ← rt.jar (java.lang.*)
        └──────────┬──────────┘
                   ↓
        ┌─────────────────────┐
        │ Extension ClassLoader│  ← jre/lib/ext
        └──────────┬──────────┘
                   ↓
        ┌─────────────────────┐
        │ Application ClassLoader│ ← classpath
        └──────────┬──────────┘
                   ↓
        ┌─────────────────────┐
        │  Custom ClassLoader  │  ← 사용자 정의
        └─────────────────────┘
```

|클래스로더|로드 대상|
|---|---|
|Bootstrap|핵심 라이브러리 (java.lang, java.util)|
|Extension|확장 라이브러리 (jre/lib/ext)|
|Application|애플리케이션 클래스 (classpath)|

---

## 동작 원리

### 1. 위임 모델 (Delegation Model)
```
요청 → Application → Extension → Bootstrap
                                     ↓
                               찾으면 로드
                               못 찾으면 ↓
         로드 실패 ← Application ← Extension
```
```java
// String 클래스 로드 요청
Class<?> stringClass = Class.forName("java.lang.String");

// 1. Application → Extension → Bootstrap 위임
// 2. Bootstrap에서 String 찾음
// 3. 로드 완료
```

### 2. 가시성 (Visibility)

- 하위 로더는 상위 로더의 클래스 접근 가능
- 상위 로더는 하위 로더의 클래스 접근 불가

### 3. 유일성 (Uniqueness)

- 상위에서 로드한 클래스는 하위에서 다시 로드 X
- 같은 클래스 중복 로드 방지

---

## 클래스 로딩 과정
```
Loading → Linking → Initialization
              │
    ┌─────────┼─────────┐
    ↓         ↓         ↓
Verification Resolution Preparation
```

### 1. Loading
```java
// .class 파일 읽어서 Method Area에 저장
// Class 객체 생성
Class<?> clazz = Class.forName("com.example.User");
```

### 2. Linking

|단계|설명|
|---|---|
|Verification|바이트코드 검증|
|Preparation|static 변수 메모리 할당, 기본값|
|Resolution|심볼릭 참조 → 실제 참조|

### 3. Initialization
```java
public class User {
    static int count = 10;  // 이 시점에 10 할당
    
    static {
        System.out.println("초기화!");  // static 블록 실행
    }
}
```

---

## 클래스 로드 시점
```java
// 1. 인스턴스 생성
new User();

// 2. static 멤버 접근
User.count;
User.doSomething();

// 3. Class.forName()
Class.forName("com.example.User");

// 4. 하위 클래스 로드 시 상위도 로드
class Admin extends User { }
new Admin();  // User도 로드
```

---

## 클래스로더 확인
```java
public class Main {
    public static void main(String[] args) {
        // String → Bootstrap (null로 표시)
        System.out.println(String.class.getClassLoader());
        // null
        
        // 내 클래스 → Application
        System.out.println(Main.class.getClassLoader());
        // sun.misc.Launcher$AppClassLoader
        
        // 부모 확인
        ClassLoader cl = Main.class.getClassLoader();
        while (cl != null) {
            System.out.println(cl);
            cl = cl.getParent();
        }
    }
}
```

---

## 커스텀 클래스로더
```java
public class MyClassLoader extends ClassLoader {
    
    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        byte[] bytes = loadClassBytes(name);  // .class 파일 읽기
        return defineClass(name, bytes, 0, bytes.length);
    }
    
    private byte[] loadClassBytes(String name) {
        // 파일이나 네트워크에서 바이트코드 로드
        String path = name.replace('.', '/') + ".class";
        try (InputStream is = new FileInputStream(path)) {
            return is.readAllBytes();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}

// 사용
MyClassLoader loader = new MyClassLoader();
Class<?> clazz = loader.loadClass("com.example.User");
Object obj = clazz.getDeclaredConstructor().newInstance();
```

---

## 실전 활용

### 플러그인 시스템
```java
// 런타임에 플러그인 로드
URLClassLoader loader = new URLClassLoader(
    new URL[] { new URL("file:///plugins/plugin.jar") }
);

Class<?> pluginClass = loader.loadClass("com.plugin.MyPlugin");
Plugin plugin = (Plugin) pluginClass.getDeclaredConstructor().newInstance();
plugin.execute();

loader.close();  // 언로드
```

### 클래스 리로딩
```java
// 기존 로더와 다른 로더로 로드하면 다른 클래스로 인식
MyClassLoader loader1 = new MyClassLoader();
MyClassLoader loader2 = new MyClassLoader();

Class<?> c1 = loader1.loadClass("User");
Class<?> c2 = loader2.loadClass("User");

System.out.println(c1 == c2);  // false!
```

---

> [!tip] 핵심 정리
> 
> - **계층 구조**: Bootstrap → Extension → Application
> - **위임 모델**: 상위 로더에게 먼저 위임
> - **로딩 과정**: Loading → Linking → Initialization
> - **동적 로딩**: 필요할 때 로드
> - **커스텀 로더**: 플러그인, 핫 리로딩

---

#Java #JVM #ClassLoader #클래스로더