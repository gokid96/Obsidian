## 개요

- 데이터를 **비트(bit) 단위**로 연산
- 정수 타입에서만 사용 가능
- 하드웨어 제어, 암호화, 최적화 등에 활용

---

## 비트 연산자 종류

|연산자|의미|설명|
|---|---|---|
|`&`|AND|둘 다 1이면 1|
|`|`|OR|
|`^`|XOR|다르면 1|
|`~`|NOT|비트 반전|
|`<<`|왼쪽 시프트|비트를 왼쪽으로 이동|
|`>>`|오른쪽 시프트|비트를 오른쪽으로 이동 (부호 유지)|
|`>>>`|부호 없는 오른쪽 시프트|비트를 오른쪽으로 이동 (0으로 채움)|

---

## AND 연산자 (&)

### 진리표

|A|B|A & B|
|---|---|---|
|0|0|0|
|0|1|0|
|1|0|0|
|1|1|**1**|

### 예시

```java
int a = 12;  // 1100
int b = 10;  // 1010
int c = a & b;  // 1000 → 8

//   1100 (12)
// & 1010 (10)
// --------
//   1000 (8)
```

### 활용: 특정 비트 추출 (마스킹)

```java
int value = 0b11010110;  // 214
int mask = 0b00001111;   // 하위 4비트 마스크

int lower = value & mask;  // 0110 → 6

// RGB 색상에서 Blue 추출
int color = 0xFF5733;  // RGB
int blue = color & 0xFF;  // 0x33 → 51
```

---

## OR 연산자 (|)

### 진리표

|A|B|A \| B|
|---|---|---|
|0|0|0|
|0|1|**1**|
|1|0|**1**|
|1|1|**1**|

### 예시

```java
int a = 12;  // 1100
int b = 10;  // 1010
int c = a | b;  // 1110 → 14

//   1100 (12)
// | 1010 (10)
// --------
//   1110 (14)
```

### 활용: 비트 플래그 설정

```java
int flags = 0;

int READ = 1;     // 0001
int WRITE = 2;    // 0010
int EXECUTE = 4;  // 0100

// 플래그 설정
flags = flags | READ;     // 0001
flags = flags | WRITE;    // 0011
flags |= EXECUTE;         // 0111

System.out.println(flags);  // 7
```

---

## XOR 연산자 (^)

### 진리표

|A|B|A ^ B|
|---|---|---|
|0|0|0|
|0|1|**1**|
|1|0|**1**|
|1|1|0|

### 예시

```java
int a = 12;  // 1100
int b = 10;  // 1010
int c = a ^ b;  // 0110 → 6

//   1100 (12)
// ^ 1010 (10)
// --------
//   0110 (6)
```

### 활용: 값 교환 (임시 변수 없이)

```java
int a = 5, b = 3;

a = a ^ b;  // a = 6
b = a ^ b;  // b = 5
a = a ^ b;  // a = 3

System.out.println(a + ", " + b);  // 3, 5
```

### 활용: 간단한 암호화

```java
int data = 0b11010110;
int key = 0b10101010;

// 암호화
int encrypted = data ^ key;  // 01111100

// 복호화 (같은 키로 XOR)
int decrypted = encrypted ^ key;  // 11010110 (원본)
```

---

## NOT 연산자 (~)

### 모든 비트 반전

```java
int a = 10;   // 00000000 00000000 00000000 00001010
int b = ~a;   // 11111111 11111111 11111111 11110101 → -11

// ~n = -(n+1)
System.out.println(~10);   // -11
System.out.println(~0);    // -1
System.out.println(~(-1)); // 0
```

### 활용: 플래그 해제

```java
int flags = 0b0111;  // 7
int WRITE = 0b0010;  // 2

// WRITE 플래그 해제
flags = flags & ~WRITE;  // 0101 → 5

//   0111
// & 1101 (~0010)
// --------
//   0101
```

---

## 왼쪽 시프트 (<<)

### 비트를 왼쪽으로 이동

- 오른쪽은 0으로 채움
- **n << k = n × 2^k**

```java
int a = 3;    // 00000011

int b = a << 1;  // 00000110 → 6  (3 × 2^1)
int c = a << 2;  // 00001100 → 12 (3 × 2^2)
int d = a << 3;  // 00011000 → 24 (3 × 2^3)
```

### 활용: 2의 거듭제곱 곱셈

```java
int n = 5;
int result = n << 3;  // 5 × 8 = 40 (곱셈보다 빠름)

// 2의 거듭제곱 구하기
int pow2 = 1 << 10;  // 2^10 = 1024
```

---

## 오른쪽 시프트 (>>)

### 비트를 오른쪽으로 이동 (부호 유지)

- 양수: 왼쪽을 0으로 채움
- 음수: 왼쪽을 1로 채움 (부호 비트 유지)
- **n >> k = n ÷ 2^k** (내림)

```java
int a = 24;   // 00011000

int b = a >> 1;  // 00001100 → 12 (24 ÷ 2)
int c = a >> 2;  // 00000110 → 6  (24 ÷ 4)
int d = a >> 3;  // 00000011 → 3  (24 ÷ 8)

// 음수
int neg = -8;    // 11111111...11111000
int e = neg >> 1;  // 11111111...11111100 → -4
```

### 활용: 2의 거듭제곱 나눗셈

```java
int n = 100;
int result = n >> 2;  // 100 ÷ 4 = 25

// 평균 구하기 (오버플로우 방지)
int avg = (a + b) >> 1;  // (a + b) / 2
```

---

## 부호 없는 오른쪽 시프트 (>>>)

### 항상 0으로 채움

```java
int a = -8;  // 11111111 11111111 11111111 11111000

int b = a >> 1;   // 11111111...11111100 → -4 (부호 유지)
int c = a >>> 1;  // 01111111...11111100 → 2147483644 (양수)
```

### 활용

```java
// 부호 없는 정수처럼 처리해야 할 때
int unsigned = -1;  // 모든 비트 1
int shifted = unsigned >>> 1;  // 최상위 비트 0 → Integer.MAX_VALUE
```

---

## 실전 예제

### 짝수/홀수 판별 (& 1)

```java
int n = 7;

// 비트 연산 (빠름)
if ((n & 1) == 0) {
    System.out.println("짝수");
} else {
    System.out.println("홀수");
}

// 마지막 비트가 0이면 짝수, 1이면 홀수
// 7 = 0111 → 0111 & 0001 = 0001 (홀수)
// 8 = 1000 → 1000 & 0001 = 0000 (짝수)
```

### 2의 거듭제곱 판별

```java
int n = 8;  // 1000

// n이 2의 거듭제곱이면 비트가 하나만 1
boolean isPowerOf2 = (n > 0) && ((n & (n - 1)) == 0);

// 8 & 7 = 1000 & 0111 = 0000 → true
// 6 & 5 = 0110 & 0101 = 0100 → false
```

### RGB 색상 처리

```java
int color = 0xFF5733;  // RGB

// 각 색상 추출
int red = (color >> 16) & 0xFF;    // 0xFF → 255
int green = (color >> 8) & 0xFF;   // 0x57 → 87
int blue = color & 0xFF;           // 0x33 → 51

// RGB 합치기
int newColor = (red << 16) | (green << 8) | blue;
```

### 비트 카운트

```java
// 1인 비트 개수 세기
int n = 0b10110101;
int count = 0;

while (n != 0) {
    count += n & 1;
    n >>>= 1;
}
System.out.println(count);  // 5

// 또는 내장 메서드
int count2 = Integer.bitCount(0b10110101);  // 5
```

---

## 비트 연산 활용 정리

|작업|연산|예시|
|---|---|---|
|짝수/홀수|`n & 1`|0이면 짝수|
|2로 곱하기|`n << 1`|`5 << 1 = 10`|
|2로 나누기|`n >> 1`|`10 >> 1 = 5`|
|특정 비트 켜기|`n|= (1 << k)`|
|특정 비트 끄기|`n &= ~(1 << k)`|k번째 비트 해제|
|특정 비트 토글|`n ^= (1 << k)`|k번째 비트 반전|
|특정 비트 확인|`(n >> k) & 1`|k번째 비트 값|

---

> [!tip] 핵심 정리
> 
> - `&` (AND): 마스킹, 특정 비트 추출
> - `|` (OR): 비트 설정
> - `^` (XOR): 토글, 값 교환, 암호화
> - `~` (NOT): 비트 반전
> - `<<` : 왼쪽 시프트 (×2)
> - `>>` : 오른쪽 시프트 (÷2, 부호 유지)
> - `>>>` : 부호 없는 오른쪽 시프트

---

#Java #연산자 #비트연산자 #기초문법