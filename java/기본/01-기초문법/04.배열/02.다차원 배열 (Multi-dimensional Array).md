## 개요

- **배열의 배열**: 배열 요소가 또 다른 배열
- 주로 **2차원 배열** 사용 (행과 열)
- 표, 행렬, 좌표, 게임 맵 등에 활용

---

## 2차원 배열

### 선언과 생성

```java
// 선언
int[][] arr;
int arr[][];
int[] arr[];

// 생성 (3행 4열)
int[][] arr = new int[3][4];

// 리터럴로 생성
int[][] arr = {
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9}
};
```

### 구조

```
arr[0] → [1, 2, 3]
arr[1] → [4, 5, 6]
arr[2] → [7, 8, 9]

arr[1][2] = 6
    ↑  ↑
   행 열
```

### 메모리 구조

```
[Stack]          [Heap]
┌──────┐         ┌────────────────┐
│ arr  │────────→│ [ref0, ref1, ref2]
└──────┘         └───┬────┬────┬──┘
                     ↓    ↓    ↓
                 [1,2,3][4,5,6][7,8,9]
```

---

## 2차원 배열 접근

### 요소 접근

```java
int[][] arr = {
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9}
};

int value = arr[1][2];  // 6 (2행 3열)
arr[0][0] = 100;        // 첫 번째 요소 수정
```

### 길이

```java
int rows = arr.length;        // 행 개수: 3
int cols = arr[0].length;     // 열 개수: 3 (첫 번째 행 기준)
```

---

## 2차원 배열 순회

### 이중 for문

```java
int[][] arr = {
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9}
};

for (int i = 0; i < arr.length; i++) {
    for (int j = 0; j < arr[i].length; j++) {
        System.out.print(arr[i][j] + " ");
    }
    System.out.println();
}
```

### for-each

```java
for (int[] row : arr) {
    for (int value : row) {
        System.out.print(value + " ");
    }
    System.out.println();
}
```

### 열 우선 순회

```java
// 열(column)을 먼저 순회
for (int j = 0; j < arr[0].length; j++) {
    for (int i = 0; i < arr.length; i++) {
        System.out.print(arr[i][j] + " ");
    }
    System.out.println();
}
// 출력: 1 4 7 / 2 5 8 / 3 6 9
```

---

## 가변 배열 (Jagged Array)

### 행마다 다른 열 크기

```java
int[][] arr = new int[3][];  // 행만 지정

arr[0] = new int[2];  // 첫 번째 행: 2열
arr[1] = new int[4];  // 두 번째 행: 4열
arr[2] = new int[3];  // 세 번째 행: 3열
```

### 리터럴로 생성

```java
int[][] arr = {
    {1, 2},
    {3, 4, 5, 6},
    {7, 8, 9}
};
```

### 구조

```
arr[0] → [1, 2]
arr[1] → [3, 4, 5, 6]
arr[2] → [7, 8, 9]
```

### 가변 배열 순회

```java
for (int i = 0; i < arr.length; i++) {
    for (int j = 0; j < arr[i].length; j++) {  // arr[i].length 중요!
        System.out.print(arr[i][j] + " ");
    }
    System.out.println();
}
```

---

## 3차원 배열

### 선언과 생성

```java
int[][][] arr = new int[2][3][4];
// 2개의 면, 각 면은 3행 4열

int[][][] arr = {
    {
        {1, 2, 3},
        {4, 5, 6}
    },
    {
        {7, 8, 9},
        {10, 11, 12}
    }
};
```

### 접근

```java
int value = arr[0][1][2];  // 첫 번째 면, 두 번째 행, 세 번째 열
```

### 순회

```java
for (int i = 0; i < arr.length; i++) {
    for (int j = 0; j < arr[i].length; j++) {
        for (int k = 0; k < arr[i][j].length; k++) {
            System.out.print(arr[i][j][k] + " ");
        }
        System.out.println();
    }
    System.out.println("---");
}
```

---

## 실전 예제

### 행렬 덧셈

```java
int[][] a = {{1, 2}, {3, 4}};
int[][] b = {{5, 6}, {7, 8}};
int[][] result = new int[2][2];

for (int i = 0; i < 2; i++) {
    for (int j = 0; j < 2; j++) {
        result[i][j] = a[i][j] + b[i][j];
    }
}
// result = {{6, 8}, {10, 12}}
```

### 행렬 전치 (Transpose)

```java
int[][] matrix = {
    {1, 2, 3},
    {4, 5, 6}
};  // 2x3

int[][] transposed = new int[3][2];  // 3x2

for (int i = 0; i < matrix.length; i++) {
    for (int j = 0; j < matrix[i].length; j++) {
        transposed[j][i] = matrix[i][j];
    }
}
// transposed = {{1, 4}, {2, 5}, {3, 6}}
```

### 좌표 표현

```java
int[][] map = new int[10][10];  // 10x10 맵

// 특정 좌표에 값 설정
int x = 5, y = 3;
map[y][x] = 1;  // 주의: 보통 [행][열] = [y][x]

// 주변 8방향 탐색
int[] dx = {-1, 0, 1, -1, 1, -1, 0, 1};
int[] dy = {-1, -1, -1, 0, 0, 1, 1, 1};

for (int i = 0; i < 8; i++) {
    int nx = x + dx[i];
    int ny = y + dy[i];
    if (nx >= 0 && nx < 10 && ny >= 0 && ny < 10) {
        // 유효한 좌표
    }
}
```

### 게임 맵

```java
char[][] gameMap = {
    {'#', '#', '#', '#', '#'},
    {'#', ' ', ' ', ' ', '#'},
    {'#', ' ', 'P', ' ', '#'},
    {'#', ' ', ' ', 'E', '#'},
    {'#', '#', '#', '#', '#'}
};
// #: 벽, P: 플레이어, E: 적, ' ': 빈 공간

// 맵 출력
for (char[] row : gameMap) {
    for (char cell : row) {
        System.out.print(cell);
    }
    System.out.println();
}
```

### 학생 성적표

```java
String[] students = {"김철수", "이영희", "박민수"};
String[] subjects = {"국어", "영어", "수학"};
int[][] scores = {
    {90, 85, 78},
    {88, 92, 95},
    {76, 80, 88}
};

// 학생별 평균
for (int i = 0; i < students.length; i++) {
    int sum = 0;
    for (int j = 0; j < subjects.length; j++) {
        sum += scores[i][j];
    }
    double avg = (double) sum / subjects.length;
    System.out.println(students[i] + " 평균: " + avg);
}
```

### 2차원 배열 출력 (Arrays)

```java
int[][] arr = {{1, 2}, {3, 4}};

// 잘못된 출력
System.out.println(Arrays.toString(arr));
// [[I@..., [I@...]

// 올바른 출력
System.out.println(Arrays.deepToString(arr));
// [[1, 2], [3, 4]]
```

### 2차원 배열 비교

```java
int[][] arr1 = {{1, 2}, {3, 4}};
int[][] arr2 = {{1, 2}, {3, 4}};

// 잘못된 비교
System.out.println(Arrays.equals(arr1, arr2));  // false!

// 올바른 비교
System.out.println(Arrays.deepEquals(arr1, arr2));  // true
```

---

## 다차원 배열 복사

### 얕은 복사 (주의!)

```java
int[][] original = {{1, 2}, {3, 4}};
int[][] shallow = original.clone();

shallow[0][0] = 100;
System.out.println(original[0][0]);  // 100! (같이 변경됨)
```

### 깊은 복사

```java
int[][] original = {{1, 2}, {3, 4}};
int[][] deep = new int[original.length][];

for (int i = 0; i < original.length; i++) {
    deep[i] = original[i].clone();
}

deep[0][0] = 100;
System.out.println(original[0][0]);  // 1 (원본 유지)
```

---

## 주의사항

### 1. NullPointerException

```java
int[][] arr = new int[3][];  // 행만 생성

// arr[0][0] = 1;  // NPE! arr[0]이 null

arr[0] = new int[2];  // 먼저 열 생성
arr[0][0] = 1;        // OK
```

### 2. 길이 확인

```java
// 가변 배열에서 각 행 길이 다름
for (int i = 0; i < arr.length; i++) {
    for (int j = 0; j < arr[i].length; j++) {  // arr[i].length!
        // ...
    }
}
```

---

> [!tip] 핵심 정리
> 
> - 2차원 배열: `타입[][] 변수 = new 타입[행][열]`
> - 접근: `arr[행][열]` 또는 `arr[y][x]`
> - 길이: `arr.length`(행), `arr[i].length`(열)
> - 가변 배열: 행마다 열 크기 다를 수 있음
> - 깊은 복사: 각 행을 개별적으로 복사

---

#Java #배열 #다차원배열 #2차원배열 #기초문법