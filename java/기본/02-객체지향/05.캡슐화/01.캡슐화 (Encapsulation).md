## 캡슐화란?
- 데이터(필드)와 기능(메서드)을 **하나로 묶음**
- 외부에서 내부 구현을 **숨김** (정보 은닉)
- **접근 제한자**를 통해 구현

---

## 캡슐화의 목적

1. **데이터 보호**: 잘못된 값 설정 방지
2. **유지보수성**: 내부 구현 변경 시 외부 영향 최소화
3. **사용 편의성**: 복잡한 내부 로직 숨김

---

## 캡슐화 구현

### 기본 패턴
```java
public class Person {
    // private 필드
    private String name;
    private int age;
    
    // public Getter
    public String getName() {
        return name;
    }
    
    public int getAge() {
        return age;
    }
    
    // public Setter (유효성 검사)
    public void setName(String name) {
        if (name != null && !name.isEmpty()) {
            this.name = name;
        }
    }
    
    public void setAge(int age) {
        if (age >= 0 && age <= 150) {
            this.age = age;
        }
    }
}
```

### 캡슐화 없이 vs 캡슐화
```java
// 캡슐화 없이 - 위험!
class BadPerson {
    public int age;
}

BadPerson p = new BadPerson();
p.age = -100;  // 잘못된 값 허용!
p.age = 9999;  // 막을 방법 없음

// 캡슐화 적용 - 안전!
class GoodPerson {
    private int age;
    
    public void setAge(int age) {
        if (age >= 0 && age <= 150) {
            this.age = age;
        } else {
            throw new IllegalArgumentException("유효하지 않은 나이");
        }
    }
}

GoodPerson p2 = new GoodPerson();
p2.setAge(-100);  // 예외 발생 또는 무시
```

---

## Getter와 Setter

### 기본 형태
```java
public class Product {
    private String name;
    private int price;
    private boolean available;
    
    // Getter
    public String getName() {
        return name;
    }
    
    public int getPrice() {
        return price;
    }
    
    // boolean은 isXxx()
    public boolean isAvailable() {
        return available;
    }
    
    // Setter
    public void setName(String name) {
        this.name = name;
    }
    
    public void setPrice(int price) {
        this.price = price;
    }
    
    public void setAvailable(boolean available) {
        this.available = available;
    }
}
```

### 유효성 검사 추가
```java
public class BankAccount {
    private String accountNumber;
    private int balance;
    
    public void setBalance(int balance) {
        if (balance < 0) {
            throw new IllegalArgumentException("잔액은 음수가 될 수 없습니다");
        }
        this.balance = balance;
    }
    
    public void deposit(int amount) {
        if (amount <= 0) {
            throw new IllegalArgumentException("입금액은 양수여야 합니다");
        }
        this.balance += amount;
    }
    
    public void withdraw(int amount) {
        if (amount <= 0) {
            throw new IllegalArgumentException("출금액은 양수여야 합니다");
        }
        if (amount > balance) {
            throw new IllegalArgumentException("잔액이 부족합니다");
        }
        this.balance -= amount;
    }
}
```

---

## 읽기 전용 / 쓰기 전용

### 읽기 전용 (Getter만)
```java
public class ImmutablePerson {
    private final String name;
    private final int birthYear;
    
    public ImmutablePerson(String name, int birthYear) {
        this.name = name;
        this.birthYear = birthYear;
    }
    
    public String getName() {
        return name;
    }
    
    public int getBirthYear() {
        return birthYear;
    }
    
    // Setter 없음 - 불변 객체
}
```

### 쓰기 전용 (Setter만)
```java
public class PasswordManager {
    private String password;
    
    public void setPassword(String password) {
        // 비밀번호는 설정만 가능, 조회 불가
        this.password = encrypt(password);
    }
    
    public boolean verifyPassword(String input) {
        return encrypt(input).equals(password);
    }
    
    private String encrypt(String text) {
        // 암호화 로직
        return text;
    }
}
```

---

## 방어적 복사

### 참조 타입 필드 보호
```java
public class Student {
    private int[] scores;
    
    // 잘못된 Getter - 내부 배열 노출
    public int[] getScoresBad() {
        return scores;  // 외부에서 수정 가능!
    }
    
    // 올바른 Getter - 복사본 반환
    public int[] getScores() {
        return scores.clone();  // 방어적 복사
    }
    
    // 올바른 Setter - 복사본 저장
    public void setScores(int[] scores) {
        this.scores = scores.clone();
    }
}
```

### List 필드
```java
public class Team {
    private List<String> members;
    
    public Team() {
        this.members = new ArrayList<>();
    }
    
    // 방어적 복사 반환
    public List<String> getMembers() {
        return new ArrayList<>(members);
    }
    
    // 불변 리스트 반환
    public List<String> getMembersReadOnly() {
        return Collections.unmodifiableList(members);
    }
    
    // 개별 추가/삭제 메서드 제공
    public void addMember(String member) {
        members.add(member);
    }
    
    public void removeMember(String member) {
        members.remove(member);
    }
}
```

---

## 실전 예제

### 회원 클래스
```java
public class Member {
    private String id;
    private String password;
    private String name;
    private String email;
    private LocalDate joinDate;
    
    public Member(String id, String password, String name) {
        setId(id);
        setPassword(password);
        setName(name);
        this.joinDate = LocalDate.now();
    }
    
    // ID: 읽기 전용 (한 번 설정 후 변경 불가)
    public String getId() {
        return id;
    }
    
    private void setId(String id) {
        if (id == null || id.length() < 4) {
            throw new IllegalArgumentException("ID는 4자 이상이어야 합니다");
        }
        this.id = id;
    }
    
    // 비밀번호: 쓰기 전용
    public void setPassword(String password) {
        if (password == null || password.length() < 8) {
            throw new IllegalArgumentException("비밀번호는 8자 이상이어야 합니다");
        }
        this.password = encrypt(password);
    }
    
    public boolean checkPassword(String password) {
        return this.password.equals(encrypt(password));
    }
    
    // 이름: 읽기/쓰기
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        if (name == null || name.trim().isEmpty()) {
            throw new IllegalArgumentException("이름은 필수입니다");
        }
        this.name = name.trim();
    }
    
    // 이메일: 읽기/쓰기 + 형식 검증
    public String getEmail() {
        return email;
    }
    
    public void setEmail(String email) {
        if (email != null && !email.contains("@")) {
            throw new IllegalArgumentException("이메일 형식이 올바르지 않습니다");
        }
        this.email = email;
    }
    
    // 가입일: 읽기 전용
    public LocalDate getJoinDate() {
        return joinDate;
    }
    
    private String encrypt(String text) {
        // 실제로는 암호화 로직
        return text;
    }
}
```

### 상품 주문
```java
public class Order {
    private String orderId;
    private List<OrderItem> items;
    private OrderStatus status;
    
    public Order(String orderId) {
        this.orderId = orderId;
        this.items = new ArrayList<>();
        this.status = OrderStatus.CREATED;
    }
    
    public String getOrderId() {
        return orderId;
    }
    
    public List<OrderItem> getItems() {
        return Collections.unmodifiableList(items);
    }
    
    public void addItem(OrderItem item) {
        if (status != OrderStatus.CREATED) {
            throw new IllegalStateException("주문 확정 후 상품 추가 불가");
        }
        items.add(item);
    }
    
    public int getTotalPrice() {
        return items.stream()
            .mapToInt(OrderItem::getPrice)
            .sum();
    }
    
    public void confirm() {
        if (items.isEmpty()) {
            throw new IllegalStateException("상품이 없습니다");
        }
        this.status = OrderStatus.CONFIRMED;
    }
}
```

---

## 캡슐화 원칙

### 1. 필드는 private
```java
private int value;  // 항상 private
```

### 2. 필요한 경우만 Getter/Setter
```java
// 모든 필드에 Getter/Setter를 만들지 않음
// 필요한 것만 제공
```

### 3. 의미 있는 메서드명
```java
// setAge() 대신 의미 있는 이름
void birthday() {
    this.age++;
}

// setBalance() 대신
void deposit(int amount) { }
void withdraw(int amount) { }
```

### 4. 불변 객체 고려
```java
// 가능하면 불변으로 설계
public final class Money {
    private final int amount;
    
    public Money(int amount) {
        this.amount = amount;
    }
    
    public int getAmount() {
        return amount;
    }
    
    public Money add(Money other) {
        return new Money(this.amount + other.amount);
    }
}
```

---

> [!tip] 핵심 정리
> - **캡슐화**: 데이터 보호 + 정보 은닉
> - 필드는 **private**, 메서드로 접근
> - **Getter/Setter**에 유효성 검사 추가
> - 참조 타입은 **방어적 복사** 고려
> - 가능하면 **불변 객체**로 설계

---

#Java #객체지향 #캡슐화 #Encapsulation #Getter #Setter
