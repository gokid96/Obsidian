# 추상화 - 인터페이스 (Interface)

## 인터페이스란?
- **규약(Contract)**을 정의하는 타입
- 구현 클래스가 **반드시 구현해야 할 메서드** 명세
- 다중 구현 가능

---

## 인터페이스 선언

### 기본 형식
```java
public interface 인터페이스명 {
    // 상수
    public static final 타입 상수명 = 값;
    
    // 추상 메서드
    public abstract 반환타입 메서드명();
}
```

### 생략 가능
```java
public interface Drawable {
    // public static final 생략 가능
    int MAX_SIZE = 100;  // 자동으로 public static final
    
    // public abstract 생략 가능
    void draw();  // 자동으로 public abstract
    void resize(int size);
}
```

---

## 인터페이스 구현

### implements 키워드
```java
public class Circle implements Drawable {
    private int radius;
    
    @Override
    public void draw() {
        System.out.println("원을 그립니다");
    }
    
    @Override
    public void resize(int size) {
        this.radius = size;
    }
}
```

### 다중 구현
```java
interface Flyable {
    void fly();
}

interface Swimmable {
    void swim();
}

// 여러 인터페이스 구현 가능
class Duck implements Flyable, Swimmable {
    @Override
    public void fly() {
        System.out.println("오리가 날아갑니다");
    }
    
    @Override
    public void swim() {
        System.out.println("오리가 수영합니다");
    }
}
```

### 상속과 구현 동시에
```java
class Animal { }

class Duck extends Animal implements Flyable, Swimmable {
    // ...
}
```

---

## 인터페이스 타입

### 다형성
```java
interface Movable {
    void move();
}

class Car implements Movable {
    @Override
    public void move() {
        System.out.println("자동차 이동");
    }
}

class Bicycle implements Movable {
    @Override
    public void move() {
        System.out.println("자전거 이동");
    }
}

// 인터페이스 타입으로 참조
Movable m1 = new Car();
Movable m2 = new Bicycle();

m1.move();  // 자동차 이동
m2.move();  // 자전거 이동
```

### 매개변수로 활용
```java
class Navigator {
    void navigate(Movable vehicle) {
        System.out.println("네비게이션 시작");
        vehicle.move();
        System.out.println("도착");
    }
}

Navigator navi = new Navigator();
navi.navigate(new Car());
navi.navigate(new Bicycle());
```

---

## 인터페이스 상속

### 인터페이스 간 상속
```java
interface Readable {
    void read();
}

interface Writable {
    void write();
}

// 인터페이스 다중 상속 가능
interface ReadWritable extends Readable, Writable {
    void readWrite();
}

class File implements ReadWritable {
    @Override
    public void read() { }
    
    @Override
    public void write() { }
    
    @Override
    public void readWrite() { }
}
```

---

## default 메서드 (Java 8+)

### 기본 구현 제공
```java
interface Calculator {
    int add(int a, int b);
    int subtract(int a, int b);
    
    // default 메서드 - 기본 구현 제공
    default int multiply(int a, int b) {
        return a * b;
    }
}

class BasicCalculator implements Calculator {
    @Override
    public int add(int a, int b) {
        return a + b;
    }
    
    @Override
    public int subtract(int a, int b) {
        return a - b;
    }
    // multiply는 구현 안 해도 됨
}
```

### 다중 인터페이스 충돌
```java
interface A {
    default void hello() {
        System.out.println("A");
    }
}

interface B {
    default void hello() {
        System.out.println("B");
    }
}

class C implements A, B {
    @Override
    public void hello() {
        A.super.hello();  // A의 default 호출
    }
}
```

---

## static 메서드 (Java 8+)

```java
interface StringUtils {
    static boolean isEmpty(String s) {
        return s == null || s.length() == 0;
    }
}

// 인터페이스명으로 호출
boolean result = StringUtils.isEmpty("");
```

---

## 함수형 인터페이스 (Java 8+)

### 추상 메서드가 하나인 인터페이스
```java
@FunctionalInterface
interface Calculator {
    int calculate(int a, int b);
}

// 람다식으로 구현
Calculator add = (a, b) -> a + b;
Calculator multiply = (a, b) -> a * b;

System.out.println(add.calculate(5, 3));  // 8
```

---

## 실전 예제: 전략 패턴

```java
interface PaymentStrategy {
    void pay(int amount);
}

class CreditCardPayment implements PaymentStrategy {
    @Override
    public void pay(int amount) {
        System.out.println("신용카드 결제: " + amount + "원");
    }
}

class KakaoPayPayment implements PaymentStrategy {
    @Override
    public void pay(int amount) {
        System.out.println("카카오페이 결제: " + amount + "원");
    }
}

class ShoppingCart {
    private PaymentStrategy paymentStrategy;
    
    void setPaymentStrategy(PaymentStrategy strategy) {
        this.paymentStrategy = strategy;
    }
    
    void checkout(int amount) {
        paymentStrategy.pay(amount);
    }
}

// 사용
ShoppingCart cart = new ShoppingCart();
cart.setPaymentStrategy(new CreditCardPayment());
cart.checkout(10000);

cart.setPaymentStrategy(new KakaoPayPayment());
cart.checkout(20000);
```

---

## 추상 클래스 vs 인터페이스

| 구분 | 추상 클래스 | 인터페이스 |
|------|------------|-----------|
| 키워드 | abstract class | interface |
| 다중 상속/구현 | 불가 | 가능 |
| 생성자 | 있음 | 없음 |
| 필드 | 모든 종류 | public static final만 |
| 메서드 | 모든 종류 | public abstract (기본) |
| 사용 시점 | IS-A, 공통 코드 | CAN-DO, 규약 정의 |

---

> [!tip] 핵심 정리
> - **인터페이스**: 규약 정의, 다중 구현 가능
> - `implements`로 구현, 모든 추상 메서드 구현 필수
> - **default 메서드**: 기본 구현 제공 (Java 8+)
> - **함수형 인터페이스**: 람다식 사용 가능
> - 다형성, 전략 패턴, 의존성 주입에 활용

---

#Java #객체지향 #인터페이스 #interface #다형성
