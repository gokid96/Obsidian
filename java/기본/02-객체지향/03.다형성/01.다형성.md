# 다형성 (Polymorphism)

## 다형성이란?
- **하나의 타입**으로 **여러 형태의 객체**를 참조
- 같은 메서드 호출이 **객체에 따라 다르게 동작**
- OOP의 핵심 특성 중 하나

---

## 다형성의 기본

### 부모 타입으로 자식 참조
```java
class Animal {
    void sound() {
        System.out.println("동물 소리");
    }
}

class Dog extends Animal {
    @Override
    void sound() {
        System.out.println("멍멍!");
    }
}

class Cat extends Animal {
    @Override
    void sound() {
        System.out.println("야옹!");
    }
}

// 다형성
Animal a1 = new Dog();  // 부모 타입으로 자식 객체 참조
Animal a2 = new Cat();

a1.sound();  // "멍멍!" - Dog의 메서드 실행
a2.sound();  // "야옹!" - Cat의 메서드 실행
```

---

## 타입 변환

### 업캐스팅 (Upcasting)
- 자식 → 부모 타입 변환
- **자동 변환**

```java
Dog dog = new Dog();
Animal animal = dog;  // 업캐스팅 (자동)
Animal animal2 = new Dog();  // 동시에

// 부모 타입으로는 부모 멤버만 접근 가능
animal.sound();  // OK
// animal.fetch();  // 에러! Dog만의 메서드
```

### 다운캐스팅 (Downcasting)
- 부모 → 자식 타입 변환
- **명시적 변환** 필요

```java
Animal animal = new Dog();  // 업캐스팅
Dog dog = (Dog) animal;     // 다운캐스팅 (명시적)
dog.fetch();                // OK - Dog 메서드 사용 가능

// 잘못된 다운캐스팅
Animal animal2 = new Cat();
// Dog dog2 = (Dog) animal2;  // ClassCastException!
```

---

## instanceof 연산자

### 타입 확인
```java
Animal animal = new Dog();

if (animal instanceof Dog) {
    Dog dog = (Dog) animal;
    dog.fetch();
}

if (animal instanceof Cat) {
    Cat cat = (Cat) animal;
    cat.scratch();
}

// 부모 타입도 true
System.out.println(animal instanceof Animal);  // true
System.out.println(animal instanceof Object);  // true
```

### 패턴 매칭 (Java 16+)
```java
// 기존 방식
if (animal instanceof Dog) {
    Dog dog = (Dog) animal;
    dog.fetch();
}

// Java 16+ 패턴 매칭
if (animal instanceof Dog dog) {
    dog.fetch();  // 바로 사용 가능
}
```

---

## 다형성 활용

### 배열/컬렉션
```java
// 부모 타입 배열에 여러 자식 저장
Animal[] animals = new Animal[3];
animals[0] = new Dog();
animals[1] = new Cat();
animals[2] = new Dog();

for (Animal animal : animals) {
    animal.sound();  // 각 객체에 맞는 메서드 호출
}
// 출력: 멍멍!, 야옹!, 멍멍!
```

### 매개변수
```java
class AnimalHospital {
    // 어떤 동물이든 받을 수 있음
    void treat(Animal animal) {
        System.out.println("치료 시작");
        animal.sound();
        System.out.println("치료 완료");
    }
}

AnimalHospital hospital = new AnimalHospital();
hospital.treat(new Dog());  // Dog 치료
hospital.treat(new Cat());  // Cat 치료
```

### 반환 타입
```java
class AnimalFactory {
    static Animal create(String type) {
        if (type.equals("dog")) {
            return new Dog();
        } else if (type.equals("cat")) {
            return new Cat();
        }
        return null;
    }
}

Animal a = AnimalFactory.create("dog");
a.sound();  // 멍멍!
```

---

## 메서드 오버라이딩과 다형성

### 동적 바인딩
```java
class Shape {
    void draw() {
        System.out.println("도형을 그립니다");
    }
}

class Circle extends Shape {
    @Override
    void draw() {
        System.out.println("원을 그립니다");
    }
}

class Rectangle extends Shape {
    @Override
    void draw() {
        System.out.println("사각형을 그립니다");
    }
}

// 동적 바인딩: 실행 시점에 실제 객체의 메서드 호출
Shape s1 = new Circle();
Shape s2 = new Rectangle();

s1.draw();  // "원을 그립니다" - Circle.draw()
s2.draw();  // "사각형을 그립니다" - Rectangle.draw()
```

### 정적 바인딩 vs 동적 바인딩
| 구분 | 정적 바인딩 | 동적 바인딩 |
|------|------------|------------|
| 시점 | 컴파일 타임 | 런타임 |
| 대상 | static, private, final | 오버라이딩된 메서드 |
| 결정 | 참조 타입 | 실제 객체 타입 |

---

## 필드와 다형성

### 필드는 다형성 적용 안 됨
```java
class Parent {
    String name = "Parent";
}

class Child extends Parent {
    String name = "Child";
}

Parent p = new Child();
System.out.println(p.name);  // "Parent" - 참조 타입 기준

Child c = (Child) p;
System.out.println(c.name);  // "Child"
```

---

## 실전 예제

### 결제 시스템
```java
abstract class Payment {
    abstract void pay(int amount);
}

class CreditCardPayment extends Payment {
    @Override
    void pay(int amount) {
        System.out.println("신용카드로 " + amount + "원 결제");
    }
}

class KakaoPayment extends Payment {
    @Override
    void pay(int amount) {
        System.out.println("카카오페이로 " + amount + "원 결제");
    }
}

class NaverPayment extends Payment {
    @Override
    void pay(int amount) {
        System.out.println("네이버페이로 " + amount + "원 결제");
    }
}

// 결제 처리
class PaymentProcessor {
    void process(Payment payment, int amount) {
        System.out.println("결제 시작...");
        payment.pay(amount);
        System.out.println("결제 완료!");
    }
}

// 사용
PaymentProcessor processor = new PaymentProcessor();
processor.process(new CreditCardPayment(), 10000);
processor.process(new KakaoPayment(), 20000);
```

### 도형 면적 계산
```java
abstract class Shape {
    abstract double getArea();
}

class Circle extends Shape {
    double radius;
    
    Circle(double radius) {
        this.radius = radius;
    }
    
    @Override
    double getArea() {
        return Math.PI * radius * radius;
    }
}

class Rectangle extends Shape {
    double width, height;
    
    Rectangle(double width, double height) {
        this.width = width;
        this.height = height;
    }
    
    @Override
    double getArea() {
        return width * height;
    }
}

// 전체 면적 계산
Shape[] shapes = {
    new Circle(5),
    new Rectangle(4, 6),
    new Circle(3)
};

double totalArea = 0;
for (Shape shape : shapes) {
    totalArea += shape.getArea();  // 다형성!
}
System.out.println("총 면적: " + totalArea);
```

---

## 인터페이스와 다형성

```java
interface Flyable {
    void fly();
}

class Bird implements Flyable {
    @Override
    public void fly() {
        System.out.println("새가 날아갑니다");
    }
}

class Airplane implements Flyable {
    @Override
    public void fly() {
        System.out.println("비행기가 날아갑니다");
    }
}

// 인터페이스 타입으로 다형성
Flyable f1 = new Bird();
Flyable f2 = new Airplane();

f1.fly();  // 새가 날아갑니다
f2.fly();  // 비행기가 날아갑니다
```

---

## 다형성의 장점

1. **유연성**: 새로운 타입 추가 용이
2. **확장성**: 기존 코드 수정 없이 기능 확장
3. **유지보수성**: 코드 중복 감소
4. **결합도 감소**: 구체적 타입에 의존하지 않음

---

> [!tip] 핵심 정리
> - **다형성**: 부모 타입으로 여러 자식 객체 참조
> - **업캐스팅**: 자식 → 부모 (자동)
> - **다운캐스팅**: 부모 → 자식 (명시적, instanceof 확인)
> - **동적 바인딩**: 실행 시점에 실제 객체의 메서드 호출
> - 배열, 매개변수, 반환 타입에 활용

---

#Java #객체지향 #다형성 #Polymorphism #업캐스팅 #다운캐스팅
