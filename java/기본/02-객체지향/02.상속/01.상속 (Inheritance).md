## 상속이란?
- 기존 클래스의 **필드와 메서드를 물려받아** 새 클래스 정의
- **코드 재사용**과 **계층 구조** 형성
- 부모 클래스(상위) → 자식 클래스(하위)

---

## 상속 기본

### extends 키워드
```java
class 자식클래스 extends 부모클래스 {
    // 추가 필드, 메서드
}
```

### 예시
```java
// 부모 클래스
public class Animal {
    String name;
    int age;
    
    void eat() {
        System.out.println(name + "이(가) 먹습니다");
    }
    
    void sleep() {
        System.out.println(name + "이(가) 잡니다");
    }
}

// 자식 클래스
public class Dog extends Animal {
    String breed;  // 추가 필드
    
    void bark() {  // 추가 메서드
        System.out.println("멍멍!");
    }
}

// 사용
Dog dog = new Dog();
dog.name = "바둑이";  // 부모로부터 상속
dog.age = 3;         // 부모로부터 상속
dog.breed = "진돗개"; // Dog만의 필드
dog.eat();           // 부모로부터 상속
dog.bark();          // Dog만의 메서드
```

---

## 상속의 특징

### 단일 상속
- Java는 **클래스 단일 상속**만 지원
- 다중 상속 불가 (인터페이스로 해결)

```java
class Child extends Parent1 { }  // OK

// class Child extends Parent1, Parent2 { }  // 에러!
```

### 상속 계층
```java
class Animal { }
class Mammal extends Animal { }
class Dog extends Mammal { }

// Dog는 Mammal과 Animal의 모든 것을 상속
```

### Object 클래스
- 모든 클래스의 **최상위 부모**
- 명시하지 않아도 자동 상속

```java
class MyClass { }
// 실제로는: class MyClass extends Object { }
```

---

## super 키워드

### 부모 멤버 접근
```java
class Parent {
    int value = 10;
}

class Child extends Parent {
    int value = 20;
    
    void show() {
        System.out.println(value);        // 20 (자식)
        System.out.println(this.value);   // 20 (자식)
        System.out.println(super.value);  // 10 (부모)
    }
}
```

### 부모 메서드 호출
```java
class Parent {
    void display() {
        System.out.println("Parent");
    }
}

class Child extends Parent {
    void display() {
        super.display();  // 부모 메서드 호출
        System.out.println("Child");
    }
}

// 출력: Parent, Child
```

---

## super() - 부모 생성자 호출

### 기본 규칙
- 자식 생성자는 **부모 생성자를 먼저 호출**
- 명시하지 않으면 `super()` 자동 삽입
- **반드시 첫 줄**에 위치

```java
class Parent {
    String name;
    
    Parent() {
        System.out.println("Parent 기본 생성자");
    }
    
    Parent(String name) {
        this.name = name;
        System.out.println("Parent(name) 생성자");
    }
}

class Child extends Parent {
    int age;
    
    Child() {
        // super();  // 자동 삽입
        System.out.println("Child 기본 생성자");
    }
    
    Child(String name, int age) {
        super(name);  // 부모 생성자 명시적 호출
        this.age = age;
        System.out.println("Child(name, age) 생성자");
    }
}

// new Child("홍길동", 20);
// 출력: Parent(name) 생성자, Child(name, age) 생성자
```

### 부모에 기본 생성자 없을 때
```java
class Parent {
    String name;
    
    Parent(String name) {  // 기본 생성자 없음
        this.name = name;
    }
}

class Child extends Parent {
    // Child() { }  // 에러! super() 호출 불가
    
    Child(String name) {
        super(name);  // 반드시 명시적 호출
    }
}
```

---

## 메서드 오버라이딩

### 부모 메서드 재정의
```java
class Animal {
    void sound() {
        System.out.println("동물 소리");
    }
}

class Dog extends Animal {
    @Override  // 어노테이션 (권장)
    void sound() {
        System.out.println("멍멍!");
    }
}

class Cat extends Animal {
    @Override
    void sound() {
        System.out.println("야옹!");
    }
}
```

### 오버라이딩 규칙
| 규칙 | 설명 |
|------|------|
| 메서드 시그니처 | 이름, 매개변수 동일 |
| 반환 타입 | 동일 또는 하위 타입 |
| 접근 제한자 | 같거나 더 넓게 |
| 예외 | 같거나 더 좁게 |

```java
class Parent {
    protected Object getValue() { return null; }
}

class Child extends Parent {
    @Override
    public String getValue() {  // OK: public ≥ protected, String ≤ Object
        return "Hello";
    }
}
```

### @Override 어노테이션
```java
@Override  // 컴파일러가 오버라이딩 검증
void method() { }

// 오타 시 컴파일 에러로 발견 가능
```

---

## final 키워드

### final 클래스 - 상속 불가
```java
final class FinalClass {
    // ...
}

// class Child extends FinalClass { }  // 에러!
```

### final 메서드 - 오버라이딩 불가
```java
class Parent {
    final void importantMethod() {
        // 자식이 변경할 수 없는 메서드
    }
}

class Child extends Parent {
    // void importantMethod() { }  // 에러!
}
```

---

## 상속과 생성 순서

```java
class Parent {
    int parentField = initParent();
    
    Parent() {
        System.out.println("3. Parent 생성자");
    }
    
    int initParent() {
        System.out.println("2. Parent 필드 초기화");
        return 10;
    }
}

class Child extends Parent {
    int childField = initChild();
    
    Child() {
        System.out.println("5. Child 생성자");
    }
    
    int initChild() {
        System.out.println("4. Child 필드 초기화");
        return 20;
    }
}

// new Child(); 실행 순서:
// 1. 메모리 할당
// 2. Parent 필드 초기화
// 3. Parent 생성자
// 4. Child 필드 초기화
// 5. Child 생성자
```

---

## 실전 예제

### 직원 상속 구조
```java
public class Employee {
    protected String name;
    protected int salary;
    
    public Employee(String name, int salary) {
        this.name = name;
        this.salary = salary;
    }
    
    public void work() {
        System.out.println(name + " 일합니다.");
    }
    
    public int getSalary() {
        return salary;
    }
}

public class Manager extends Employee {
    private int bonus;
    
    public Manager(String name, int salary, int bonus) {
        super(name, salary);
        this.bonus = bonus;
    }
    
    @Override
    public int getSalary() {
        return super.getSalary() + bonus;
    }
    
    public void manage() {
        System.out.println(name + " 관리합니다.");
    }
}

public class Developer extends Employee {
    private String language;
    
    public Developer(String name, int salary, String language) {
        super(name, salary);
        this.language = language;
    }
    
    @Override
    public void work() {
        System.out.println(name + " " + language + "로 개발합니다.");
    }
}
```

---

## 상속 vs 구성

### 상속 (IS-A)
```java
class Dog extends Animal { }  // Dog IS-A Animal
```

### 구성 (HAS-A)
```java
class Car {
    private Engine engine;  // Car HAS-A Engine
    
    Car(Engine engine) {
        this.engine = engine;
    }
}
```

### 선택 기준
- **IS-A 관계**면 상속
- **HAS-A 관계**면 구성
- 확신이 없으면 **구성 우선** 고려

---

> [!tip] 핵심 정리
> - `extends`: 상속 키워드, 단일 상속만
> - `super`: 부모 멤버 접근
> - `super()`: 부모 생성자 호출 (첫 줄)
> - `@Override`: 메서드 오버라이딩
> - `final class/method`: 상속/오버라이딩 금지

---

#Java #객체지향 #상속 #extends #super #오버라이딩
