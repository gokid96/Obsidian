
## HashMap이란?

- **키-값(Key-Value) 쌍**으로 데이터 저장
- **해시 테이블** 기반 → 빠른 검색 (O(1))
- 키 중복 불가, 값 중복 가능
- 순서 보장 안 됨
- null 키/값 허용

---

## 생성

```java
import java.util.HashMap;

// 기본 생성
HashMap<String, Integer> map1 = new HashMap<>();

// 초기 용량 지정
HashMap<String, Integer> map2 = new HashMap<>(100);

// Map 인터페이스로 선언 (권장)
Map<String, Integer> map3 = new HashMap<>();

// 초기값과 함께 (Java 9+)
Map<String, Integer> map4 = Map.of("A", 1, "B", 2);  // 불변
```

---

## 요소 추가/수정

### put()

```java
Map<String, Integer> map = new HashMap<>();

map.put("apple", 1000);
map.put("banana", 2000);
map.put("orange", 1500);

// 같은 키로 다시 put → 값 덮어쓰기
Integer old = map.put("apple", 1200);  // old = 1000
```

### putAll()

```java
Map<String, Integer> other = Map.of("grape", 3000, "melon", 5000);
map.putAll(other);
```

### putIfAbsent()

```java
// 키가 없을 때만 추가
map.putIfAbsent("apple", 9999);  // 이미 있으므로 무시
map.putIfAbsent("mango", 4000);  // 추가됨
```

---

## 요소 조회

### get()

```java
Map<String, Integer> map = new HashMap<>();
map.put("apple", 1000);

Integer price = map.get("apple");   // 1000
Integer none = map.get("unknown");  // null
```

### getOrDefault()

```java
// 없으면 기본값 반환
Integer price = map.getOrDefault("unknown", 0);  // 0
```

### containsKey() / containsValue()

```java
boolean hasApple = map.containsKey("apple");     // true
boolean has1000 = map.containsValue(1000);       // true
```

---

## 요소 삭제

### remove()

```java
Map<String, Integer> map = new HashMap<>();
map.put("apple", 1000);
map.put("banana", 2000);

Integer removed = map.remove("apple");  // 1000 반환, 삭제됨

// 키와 값 모두 일치할 때만 삭제
boolean result = map.remove("banana", 9999);  // false (값 불일치)
boolean result2 = map.remove("banana", 2000); // true
```

### clear()

```java
map.clear();  // 전체 삭제
```

---

## 크기와 상태

```java
int size = map.size();
boolean empty = map.isEmpty();
```

---

## 순회

### keySet() - 키 순회

```java
Map<String, Integer> map = new HashMap<>();
map.put("A", 1);
map.put("B", 2);
map.put("C", 3);

for (String key : map.keySet()) {
    System.out.println(key + " = " + map.get(key));
}
```

### values() - 값 순회

```java
for (Integer value : map.values()) {
    System.out.println(value);
}
```

### entrySet() - 키-값 쌍 순회 (권장)

```java
for (Map.Entry<String, Integer> entry : map.entrySet()) {
    System.out.println(entry.getKey() + " = " + entry.getValue());
}
```

### forEach (Java 8+)

```java
map.forEach((key, value) -> {
    System.out.println(key + " = " + value);
});
```

---

## 계산 메서드 (Java 8+)

### compute()

```java
Map<String, Integer> map = new HashMap<>();
map.put("A", 1);

// 키가 있으면 계산, 없으면 null 처리
map.compute("A", (k, v) -> v + 10);  // A = 11
map.compute("B", (k, v) -> v == null ? 1 : v + 10);  // B = 1
```

### computeIfAbsent()

```java
// 키가 없을 때만 계산하여 추가
map.computeIfAbsent("C", k -> 100);  // C = 100

// 활용: 리스트 값 맵
Map<String, List<String>> listMap = new HashMap<>();
listMap.computeIfAbsent("fruits", k -> new ArrayList<>()).add("apple");
```

### computeIfPresent()

```java
// 키가 있을 때만 계산
map.computeIfPresent("A", (k, v) -> v * 2);  // A = 22
```

### merge()

```java
Map<String, Integer> map = new HashMap<>();
map.put("A", 10);

// 키가 있으면 병합, 없으면 추가
map.merge("A", 5, Integer::sum);  // A = 15
map.merge("B", 5, Integer::sum);  // B = 5
```

---

## 객체 키 사용 시 주의

### equals()와 hashCode() 필수

```java
class Product {
    String code;
    
    Product(String code) {
        this.code = code;
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Product product = (Product) o;
        return Objects.equals(code, product.code);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(code);
    }
}
```

---

## Map 변형

### LinkedHashMap - 순서 유지

```java
Map<String, Integer> map = new LinkedHashMap<>();
map.put("C", 3);
map.put("A", 1);
map.put("B", 2);

System.out.println(map);  // {C=3, A=1, B=2} - 삽입 순서 유지
```

### TreeMap - 정렬

```java
Map<String, Integer> map = new TreeMap<>();
map.put("C", 3);
map.put("A", 1);
map.put("B", 2);

System.out.println(map);  // {A=1, B=2, C=3} - 키 정렬
```

---

## 실전 예제

### 빈도수 세기

```java
String[] words = {"apple", "banana", "apple", "orange", "banana", "apple"};
Map<String, Integer> freq = new HashMap<>();

for (String word : words) {
    freq.merge(word, 1, Integer::sum);
}
// {apple=3, banana=2, orange=1}

// 또는
for (String word : words) {
    freq.put(word, freq.getOrDefault(word, 0) + 1);
}
```

### 그룹화

```java
List<String> names = Arrays.asList("Kim", "Lee", "Park", "Kang", "Lim");
Map<Character, List<String>> grouped = new HashMap<>();

for (String name : names) {
    char initial = name.charAt(0);
    grouped.computeIfAbsent(initial, k -> new ArrayList<>()).add(name);
}
// {K=[Kim, Kang], L=[Lee, Lim], P=[Park]}
```

### 역 인덱스

```java
Map<String, Integer> original = Map.of("A", 1, "B", 2, "C", 1);
Map<Integer, List<String>> inverted = new HashMap<>();

original.forEach((key, value) -> {
    inverted.computeIfAbsent(value, k -> new ArrayList<>()).add(key);
});
// {1=[A, C], 2=[B]}
```

### 캐시 (간단 버전)

```java
Map<String, String> cache = new HashMap<>();

public String getData(String key) {
    return cache.computeIfAbsent(key, k -> expensiveComputation(k));
}
```

---

## 성능

|연산|시간 복잡도|
|---|---|
|put|O(1)|
|get|O(1)|
|remove|O(1)|
|containsKey|O(1)|
|containsValue|O(n)|

---

> [!tip] 핵심 정리
> 
> - **HashMap**: 키-값 쌍, 해시 기반, O(1) 검색
> - 키 중복 X, 값 중복 O
> - **getOrDefault()**: null 대신 기본값
> - **computeIfAbsent()**: 지연 초기화
> - **merge()**: 값 병합
> - 순서 필요 → LinkedHashMap
> - 정렬 필요 → TreeMap

---

#Java #HashMap #Map #컬렉션 #해시맵