

## TreeMap이란?

- **키가 정렬된** Map
- **Red-Black Tree** 기반
- 검색, 삽입, 삭제 O(log n)
- null 키 불허 (비교 불가)

---

## 생성

```java
import java.util.TreeMap;

// 기본 생성 (키 자연 순서)
TreeMap<String, Integer> map1 = new TreeMap<>();

// Comparator 지정 (역순)
TreeMap<String, Integer> map2 = new TreeMap<>(Comparator.reverseOrder());

// NavigableMap 또는 SortedMap으로 선언
NavigableMap<String, Integer> map3 = new TreeMap<>();
SortedMap<String, Integer> map4 = new TreeMap<>();
```

---

## 자동 정렬

```java
TreeMap<String, Integer> map = new TreeMap<>();
map.put("C", 3);
map.put("A", 1);
map.put("B", 2);

System.out.println(map);  // {A=1, B=2, C=3} - 키 정렬
```

---

## 기본 메서드 (HashMap과 동일)

```java
// 추가
map.put("apple", 1000);

// 조회
Integer value = map.get("apple");
Integer def = map.getOrDefault("unknown", 0);

// 삭제
map.remove("apple");

// 포함 여부
boolean hasKey = map.containsKey("apple");

// 크기
int size = map.size();
```

---

## 최소/최대 키

```java
TreeMap<Integer, String> map = new TreeMap<>();
map.put(3, "C");
map.put(1, "A");
map.put(5, "E");
map.put(2, "B");

// 최소/최대 키
Integer firstKey = map.firstKey();  // 1
Integer lastKey = map.lastKey();    // 5

// 최소/최대 엔트리
Map.Entry<Integer, String> firstEntry = map.firstEntry();  // 1=A
Map.Entry<Integer, String> lastEntry = map.lastEntry();    // 5=E
```

---

## 근접 키 검색

```java
TreeMap<Integer, String> map = new TreeMap<>();
map.put(10, "A");
map.put(20, "B");
map.put(30, "C");
map.put(40, "D");

// lowerKey: 미만 중 최대
Integer lower = map.lowerKey(25);    // 20

// floorKey: 이하 중 최대
Integer floor = map.floorKey(30);    // 30
Integer floor2 = map.floorKey(25);   // 20

// higherKey: 초과 중 최소
Integer higher = map.higherKey(25);  // 30

// ceilingKey: 이상 중 최소
Integer ceiling = map.ceilingKey(25);  // 30
Integer ceiling2 = map.ceilingKey(30); // 30
```

### Entry로 조회

```java
Map.Entry<Integer, String> lowerEntry = map.lowerEntry(25);   // 20=B
Map.Entry<Integer, String> higherEntry = map.higherEntry(25); // 30=C
```

---

## 범위 검색

### subMap()

```java
TreeMap<Integer, String> map = new TreeMap<>();
map.put(10, "A");
map.put(20, "B");
map.put(30, "C");
map.put(40, "D");
map.put(50, "E");

// from 이상, to 미만
SortedMap<Integer, String> sub1 = map.subMap(20, 40);  // {20=B, 30=C}

// inclusive 지정
NavigableMap<Integer, String> sub2 = map.subMap(20, true, 40, true);
// {20=B, 30=C, 40=D}
```

### headMap() / tailMap()

```java
// to 미만
SortedMap<Integer, String> head = map.headMap(30);  // {10=A, 20=B}

// from 이상
SortedMap<Integer, String> tail = map.tailMap(30);  // {30=C, 40=D, 50=E}
```

---

## 추출 및 삭제

```java
TreeMap<Integer, String> map = new TreeMap<>();
map.put(1, "A");
map.put(2, "B");
map.put(3, "C");

// 첫 번째 엔트리 삭제 후 반환
Map.Entry<Integer, String> first = map.pollFirstEntry();  // 1=A

// 마지막 엔트리 삭제 후 반환
Map.Entry<Integer, String> last = map.pollLastEntry();    // 3=C

// map = {2=B}
```

---

## 역순

### descendingMap()

```java
TreeMap<String, Integer> map = new TreeMap<>();
map.put("A", 1);
map.put("B", 2);
map.put("C", 3);

NavigableMap<String, Integer> descMap = map.descendingMap();
System.out.println(descMap);  // {C=3, B=2, A=1}
```

### descendingKeySet()

```java
NavigableSet<String> descKeys = map.descendingKeySet();
for (String key : descKeys) {
    System.out.println(key);  // C, B, A
}
```

---

## 사용자 정의 정렬

### Comparable 구현

```java
class Product implements Comparable<Product> {
    String name;
    int price;
    
    Product(String name, int price) {
        this.name = name;
        this.price = price;
    }
    
    @Override
    public int compareTo(Product other) {
        return this.price - other.price;  // 가격순
    }
}

TreeMap<Product, Integer> map = new TreeMap<>();
```

### Comparator 사용

```java
// 가격 역순
TreeMap<Product, Integer> map = new TreeMap<>(
    (p1, p2) -> p2.price - p1.price
);

// 이름순
TreeMap<Product, Integer> map2 = new TreeMap<>(
    Comparator.comparing(p -> p.name)
);
```

---

## HashMap vs TreeMap

|구분|HashMap|TreeMap|
|---|---|---|
|순서|X|키 정렬|
|검색|O(1)|O(log n)|
|삽입/삭제|O(1)|O(log n)|
|null 키|허용|불허|
|범위 검색|X|O|
|구현|해시 테이블|Red-Black Tree|

---

## 실전 예제

### 점수 순위표

```java
TreeMap<Integer, List<String>> ranking = new TreeMap<>(Collections.reverseOrder());

ranking.computeIfAbsent(95, k -> new ArrayList<>()).add("Kim");
ranking.computeIfAbsent(88, k -> new ArrayList<>()).add("Lee");
ranking.computeIfAbsent(95, k -> new ArrayList<>()).add("Park");
ranking.computeIfAbsent(72, k -> new ArrayList<>()).add("Choi");

// {95=[Kim, Park], 88=[Lee], 72=[Choi]} - 점수 내림차순

// 상위 2개 점수
ranking.entrySet().stream()
    .limit(2)
    .forEach(e -> System.out.println(e.getKey() + ": " + e.getValue()));
```

### 시간대 스케줄

```java
TreeMap<LocalTime, String> schedule = new TreeMap<>();
schedule.put(LocalTime.of(9, 0), "회의");
schedule.put(LocalTime.of(12, 0), "점심");
schedule.put(LocalTime.of(14, 30), "미팅");
schedule.put(LocalTime.of(18, 0), "퇴근");

LocalTime now = LocalTime.of(10, 30);

// 다음 일정
Map.Entry<LocalTime, String> next = schedule.ceilingEntry(now);
System.out.println("다음 일정: " + next);  // 12:00=점심

// 오전 일정
SortedMap<LocalTime, String> morning = schedule.headMap(LocalTime.NOON);
System.out.println("오전: " + morning);  // {09:00=회의}
```

### IP 범위 검색

```java
TreeMap<Long, String> ipRanges = new TreeMap<>();
ipRanges.put(ipToLong("192.168.0.0"), "내부망");
ipRanges.put(ipToLong("10.0.0.0"), "VPN");
ipRanges.put(ipToLong("172.16.0.0"), "개발망");

long targetIp = ipToLong("192.168.1.100");
Map.Entry<Long, String> range = ipRanges.floorEntry(targetIp);
// 해당 IP가 속한 범위 찾기
```

---

> [!tip] 핵심 정리
> 
> - **TreeMap**: 키 정렬 Map, Red-Black Tree
> - 검색/삽입/삭제 O(log n)
> - **범위 검색**: subMap, headMap, tailMap
> - **근접 검색**: lowerKey, floorKey, higherKey, ceilingKey
> - 키 객체: Comparable 또는 Comparator 필요
> - HashMap보다 느리지만 정렬/범위 기능 제공

---

#Java #TreeMap #Map #컬렉션 #정렬