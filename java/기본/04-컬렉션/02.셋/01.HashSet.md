

## HashSet이란?

- **중복을 허용하지 않는** 집합
- **순서를 보장하지 않음**
- **해시 테이블** 기반 → 빠른 검색 (O(1))
- null 허용 (1개만)

---

## 생성

```java
import java.util.HashSet;

// 기본 생성
HashSet<String> set1 = new HashSet<>();

// 초기 용량 지정
HashSet<String> set2 = new HashSet<>(100);

// 다른 컬렉션으로 초기화
HashSet<String> set3 = new HashSet<>(Arrays.asList("A", "B", "C"));

// Set 인터페이스로 선언 (권장)
Set<String> set4 = new HashSet<>();
```

---

## 요소 추가

### add()

```java
Set<String> set = new HashSet<>();

set.add("A");  // true (추가됨)
set.add("B");  // true
set.add("A");  // false (중복 - 추가 안 됨)

System.out.println(set);  // [A, B] (순서 불확정)
```

### addAll()

```java
Set<String> set = new HashSet<>();
set.add("A");

set.addAll(Arrays.asList("B", "C", "A"));  // [A, B, C]
```

---

## 요소 조회

### contains()

```java
Set<String> set = new HashSet<>(Arrays.asList("A", "B", "C"));

boolean hasA = set.contains("A");  // true
boolean hasX = set.contains("X");  // false
```

### containsAll()

```java
boolean hasAll = set.containsAll(Arrays.asList("A", "B"));  // true
```

---

## 요소 삭제

### remove()

```java
Set<String> set = new HashSet<>(Arrays.asList("A", "B", "C"));

set.remove("B");  // true, set = [A, C]
set.remove("X");  // false (없는 요소)
```

### removeAll() / retainAll()

```java
Set<String> set = new HashSet<>(Arrays.asList("A", "B", "C", "D"));

set.removeAll(Arrays.asList("A", "C"));  // [B, D] - 지정 요소 삭제
set.retainAll(Arrays.asList("B"));       // [B] - 지정 요소만 유지
```

### clear()

```java
set.clear();  // 전체 삭제
```

---

## 크기와 상태

```java
Set<String> set = new HashSet<>(Arrays.asList("A", "B", "C"));

int size = set.size();        // 3
boolean empty = set.isEmpty(); // false
```

---

## 순회

### for-each

```java
Set<String> set = new HashSet<>(Arrays.asList("A", "B", "C"));

for (String item : set) {
    System.out.println(item);  // 순서 보장 안 됨
}
```

### Iterator

```java
Iterator<String> it = set.iterator();
while (it.hasNext()) {
    String item = it.next();
    if (item.equals("B")) {
        it.remove();  // 순회 중 안전한 삭제
    }
}
```

### forEach (Java 8+)

```java
set.forEach(System.out::println);
```

---

## 집합 연산

### 합집합 (Union)

```java
Set<Integer> set1 = new HashSet<>(Arrays.asList(1, 2, 3));
Set<Integer> set2 = new HashSet<>(Arrays.asList(3, 4, 5));

Set<Integer> union = new HashSet<>(set1);
union.addAll(set2);  // [1, 2, 3, 4, 5]
```

### 교집합 (Intersection)

```java
Set<Integer> intersection = new HashSet<>(set1);
intersection.retainAll(set2);  // [3]
```

### 차집합 (Difference)

```java
Set<Integer> difference = new HashSet<>(set1);
difference.removeAll(set2);  // [1, 2]
```

### 대칭 차집합 (XOR)

```java
Set<Integer> xor = new HashSet<>(set1);
xor.addAll(set2);
Set<Integer> common = new HashSet<>(set1);
common.retainAll(set2);
xor.removeAll(common);  // [1, 2, 4, 5]
```

---

## 객체 저장 시 주의

### equals()와 hashCode()

```java
class Person {
    String name;
    int age;
    
    Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    // equals와 hashCode 미구현
}

Set<Person> set = new HashSet<>();
set.add(new Person("홍길동", 25));
set.add(new Person("홍길동", 25));
System.out.println(set.size());  // 2 (중복으로 인식 안 됨!)
```

### 올바른 구현

```java
class Person {
    String name;
    int age;
    
    Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Person person = (Person) o;
        return age == person.age && Objects.equals(name, person.name);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(name, age);
    }
}

Set<Person> set = new HashSet<>();
set.add(new Person("홍길동", 25));
set.add(new Person("홍길동", 25));
System.out.println(set.size());  // 1 (중복 제거됨!)
```

---

## Set 변형

### LinkedHashSet - 순서 유지

```java
Set<String> set = new LinkedHashSet<>();
set.add("C");
set.add("A");
set.add("B");

System.out.println(set);  // [C, A, B] - 삽입 순서 유지
```

### TreeSet - 정렬

```java
Set<String> set = new TreeSet<>();
set.add("C");
set.add("A");
set.add("B");

System.out.println(set);  // [A, B, C] - 정렬됨
```

---

## 실전 예제

### 중복 제거

```java
List<String> list = Arrays.asList("A", "B", "A", "C", "B");
Set<String> set = new HashSet<>(list);
List<String> unique = new ArrayList<>(set);
```

### 중복 검사

```java
public boolean hasDuplicates(List<String> list) {
    Set<String> set = new HashSet<>(list);
    return set.size() < list.size();
}
```

### 공통 요소 찾기

```java
public Set<String> findCommon(List<String> list1, List<String> list2) {
    Set<String> set1 = new HashSet<>(list1);
    Set<String> set2 = new HashSet<>(list2);
    set1.retainAll(set2);
    return set1;
}
```

### 고유 문자 개수

```java
public int countUniqueChars(String str) {
    Set<Character> chars = new HashSet<>();
    for (char c : str.toCharArray()) {
        chars.add(c);
    }
    return chars.size();
}
```

---

## 성능

|연산|시간 복잡도|
|---|---|
|add|O(1)|
|remove|O(1)|
|contains|O(1)|
|size|O(1)|
|순회|O(n)|

---

> [!tip] 핵심 정리
> 
> - **HashSet**: 중복 X, 순서 X, 빠른 검색
> - **contains()** O(1) → 포함 여부 확인에 최적
> - 객체 저장 시 **equals() + hashCode()** 필수
> - **LinkedHashSet**: 순서 유지
> - **TreeSet**: 정렬 유지
> - 집합 연산: addAll(합), retainAll(교), removeAll(차)

---

#Java #HashSet #Set #컬렉션 #집합