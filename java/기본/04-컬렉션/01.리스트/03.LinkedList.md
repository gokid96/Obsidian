# LinkedList

## LinkedList란?
- **이중 연결 리스트** 구조
- 삽입/삭제 빠름 (O(1) - 위치 알 때)
- 조회 느림 (O(n))
- **List + Deque** 인터페이스 구현

---

## 구조

```
┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐
│ null │←───│  A   │←──→│  B   │←──→│  C   │───→ null
│      │    │ prev │    │ prev │    │ prev │
│      │    │ next │    │ next │    │ next │
└──────┘    └──────┘    └──────┘    └──────┘
             head                     tail
```

---

## 생성

```java
import java.util.LinkedList;

// 기본 생성
LinkedList<String> list1 = new LinkedList<>();

// 다른 컬렉션으로 초기화
LinkedList<String> list2 = new LinkedList<>(Arrays.asList("A", "B", "C"));

// List 인터페이스로 선언
List<String> list3 = new LinkedList<>();

// Deque 인터페이스로 선언
Deque<String> deque = new LinkedList<>();
```

---

## List 메서드 (ArrayList와 동일)

```java
LinkedList<String> list = new LinkedList<>();

// 추가
list.add("A");
list.add(0, "B");

// 조회
String item = list.get(0);
int idx = list.indexOf("A");

// 수정
list.set(0, "X");

// 삭제
list.remove(0);
list.remove("A");

// 크기
int size = list.size();
boolean empty = list.isEmpty();
```

---

## LinkedList 전용 메서드

### 처음/끝 추가
```java
LinkedList<String> list = new LinkedList<>(Arrays.asList("B", "C"));

list.addFirst("A");  // [A, B, C]
list.addLast("D");   // [A, B, C, D]

// 또는
list.offerFirst("X");
list.offerLast("Y");
```

### 처음/끝 조회
```java
LinkedList<String> list = new LinkedList<>(Arrays.asList("A", "B", "C"));

String first = list.getFirst();  // "A"
String last = list.getLast();    // "C"

// 비어있으면 null 반환 (예외 X)
String peekFirst = list.peekFirst();
String peekLast = list.peekLast();
```

### 처음/끝 삭제
```java
String first = list.removeFirst();  // "A" 반환 후 삭제
String last = list.removeLast();    // "C" 반환 후 삭제

// 비어있으면 null 반환 (예외 X)
String pollFirst = list.pollFirst();
String pollLast = list.pollLast();
```

---

## Deque로 사용

### 스택 (LIFO)
```java
LinkedList<String> stack = new LinkedList<>();

// push (앞에 추가)
stack.push("A");
stack.push("B");
stack.push("C");  // [C, B, A]

// pop (앞에서 제거)
String top = stack.pop();  // "C"

// peek (조회만)
String peek = stack.peek();  // "B"
```

### 큐 (FIFO)
```java
LinkedList<String> queue = new LinkedList<>();

// offer (뒤에 추가)
queue.offer("A");
queue.offer("B");
queue.offer("C");  // [A, B, C]

// poll (앞에서 제거)
String front = queue.poll();  // "A"

// peek (조회만)
String peek = queue.peek();  // "B"
```

---

## ArrayList vs LinkedList

| 연산 | ArrayList | LinkedList |
|------|-----------|------------|
| get(i) | O(1) ✅ | O(n) |
| add(끝) | O(1) | O(1) |
| add(i) | O(n) | O(n)* |
| remove(i) | O(n) | O(n)* |
| 첫/끝 삽입삭제 | O(n) | O(1) ✅ |
| 메모리 | 적음 ✅ | 많음 |

\* 위치를 찾는 데 O(n), 삽입/삭제 자체는 O(1)

### 선택 기준
```java
// ArrayList: 조회 많음, 기본 선택
List<String> list1 = new ArrayList<>();

// LinkedList: 처음/끝 삽입삭제 많음
List<String> list2 = new LinkedList<>();

// 스택/큐 용도
Deque<String> stack = new LinkedList<>();
Queue<String> queue = new LinkedList<>();
```

---

## 순회

### for-each
```java
for (String item : list) {
    System.out.println(item);
}
```

### Iterator
```java
Iterator<String> it = list.iterator();
while (it.hasNext()) {
    System.out.println(it.next());
}
```

### 역방향 순회
```java
Iterator<String> descIt = list.descendingIterator();
while (descIt.hasNext()) {
    System.out.println(descIt.next());
}
```

### 인덱스 for문 (비효율!)
```java
// LinkedList에서는 비효율적 - 매번 O(n) 탐색
for (int i = 0; i < list.size(); i++) {
    list.get(i);  // 느림!
}
```

---

## 실전 예제

### 브라우저 히스토리
```java
class BrowserHistory {
    private LinkedList<String> history = new LinkedList<>();
    private int current = -1;
    
    public void visit(String url) {
        // 현재 위치 이후 삭제
        while (history.size() > current + 1) {
            history.removeLast();
        }
        history.add(url);
        current++;
    }
    
    public String back() {
        if (current > 0) {
            current--;
        }
        return history.get(current);
    }
    
    public String forward() {
        if (current < history.size() - 1) {
            current++;
        }
        return history.get(current);
    }
}
```

### 최근 항목 유지 (LRU 캐시 간단 버전)
```java
class RecentItems<T> {
    private LinkedList<T> items = new LinkedList<>();
    private int maxSize;
    
    public RecentItems(int maxSize) {
        this.maxSize = maxSize;
    }
    
    public void add(T item) {
        items.remove(item);  // 기존 위치에서 제거
        items.addFirst(item);  // 맨 앞에 추가
        
        if (items.size() > maxSize) {
            items.removeLast();  // 오래된 것 제거
        }
    }
    
    public List<T> getAll() {
        return new ArrayList<>(items);
    }
}
```

---

> [!tip] 핵심 정리
> - **LinkedList**: 이중 연결 리스트
> - **처음/끝 삽입삭제** 빠름 (O(1))
> - **조회** 느림 (O(n)) - 인덱스 for문 피하기
> - **List + Deque** 구현 → 스택/큐로 활용
> - 대부분 **ArrayList**가 더 좋은 선택
> - 처음/끝 작업 많으면 LinkedList 고려

---

#Java #LinkedList #리스트 #컬렉션 #Deque
