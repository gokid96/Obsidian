# TreeSet

## TreeSet이란?
- **정렬된 상태**를 유지하는 Set
- **이진 검색 트리(Red-Black Tree)** 기반
- 검색, 삽입, 삭제 O(log n)
- null 불허 (비교 불가)

---

## 생성

```java
import java.util.TreeSet;

// 기본 생성 (자연 순서)
TreeSet<Integer> set1 = new TreeSet<>();

// Comparator 지정
TreeSet<String> set2 = new TreeSet<>(Comparator.reverseOrder());

// 다른 컬렉션으로 초기화
TreeSet<String> set3 = new TreeSet<>(Arrays.asList("C", "A", "B"));

// NavigableSet 또는 SortedSet으로 선언
NavigableSet<Integer> set4 = new TreeSet<>();
SortedSet<Integer> set5 = new TreeSet<>();
```

---

## 자동 정렬

```java
TreeSet<Integer> set = new TreeSet<>();
set.add(5);
set.add(1);
set.add(3);
set.add(2);
set.add(4);

System.out.println(set);  // [1, 2, 3, 4, 5] - 자동 정렬
```

---

## 범위 검색

### 최소/최대
```java
TreeSet<Integer> set = new TreeSet<>(Arrays.asList(10, 20, 30, 40, 50));

int first = set.first();  // 10 (최소)
int last = set.last();    // 50 (최대)
```

### 근접 요소 검색
```java
TreeSet<Integer> set = new TreeSet<>(Arrays.asList(10, 20, 30, 40, 50));

// lower: 미만 중 최대
Integer lower = set.lower(30);   // 20

// floor: 이하 중 최대
Integer floor = set.floor(30);   // 30
Integer floor2 = set.floor(25);  // 20

// higher: 초과 중 최소
Integer higher = set.higher(30); // 40

// ceiling: 이상 중 최소
Integer ceiling = set.ceiling(30);  // 30
Integer ceiling2 = set.ceiling(25); // 30
```

### 범위 부분집합
```java
TreeSet<Integer> set = new TreeSet<>(Arrays.asList(10, 20, 30, 40, 50));

// subSet(from, to) - from 이상, to 미만
SortedSet<Integer> sub1 = set.subSet(20, 40);  // [20, 30]

// subSet(from, fromInclusive, to, toInclusive)
NavigableSet<Integer> sub2 = set.subSet(20, true, 40, true);  // [20, 30, 40]

// headSet(to) - to 미만
SortedSet<Integer> head = set.headSet(30);  // [10, 20]

// tailSet(from) - from 이상
SortedSet<Integer> tail = set.tailSet(30);  // [30, 40, 50]
```

---

## 추출 및 삭제

```java
TreeSet<Integer> set = new TreeSet<>(Arrays.asList(10, 20, 30, 40, 50));

// 첫 번째 요소 삭제 후 반환
Integer first = set.pollFirst();  // 10, set = [20, 30, 40, 50]

// 마지막 요소 삭제 후 반환
Integer last = set.pollLast();    // 50, set = [20, 30, 40]
```

---

## 역순 순회

```java
TreeSet<Integer> set = new TreeSet<>(Arrays.asList(1, 2, 3, 4, 5));

// 역순 Set 뷰
NavigableSet<Integer> descSet = set.descendingSet();
System.out.println(descSet);  // [5, 4, 3, 2, 1]

// 역순 Iterator
Iterator<Integer> descIt = set.descendingIterator();
while (descIt.hasNext()) {
    System.out.println(descIt.next());
}
```

---

## Comparable 구현

### 자연 순서 정의
```java
class Person implements Comparable<Person> {
    String name;
    int age;
    
    Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    @Override
    public int compareTo(Person other) {
        return this.age - other.age;  // 나이 오름차순
    }
    
    @Override
    public String toString() {
        return name + "(" + age + ")";
    }
}

TreeSet<Person> set = new TreeSet<>();
set.add(new Person("홍길동", 30));
set.add(new Person("김철수", 20));
set.add(new Person("이영희", 25));

System.out.println(set);  // [김철수(20), 이영희(25), 홍길동(30)]
```

---

## Comparator 사용

### 별도 정렬 기준
```java
class Person {
    String name;
    int age;
    
    Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
}

// 이름 순 정렬
TreeSet<Person> byName = new TreeSet<>((p1, p2) -> p1.name.compareTo(p2.name));

// 나이 역순 정렬
TreeSet<Person> byAgeDesc = new TreeSet<>((p1, p2) -> p2.age - p1.age);

// Comparator 조합
TreeSet<Person> set = new TreeSet<>(
    Comparator.comparing((Person p) -> p.age)
              .thenComparing(p -> p.name)
);
```

---

## HashSet vs TreeSet

| 구분 | HashSet | TreeSet |
|------|---------|---------|
| 순서 | X | 정렬 유지 |
| 검색 | O(1) | O(log n) |
| 삽입/삭제 | O(1) | O(log n) |
| null | 허용 | 불허 |
| 구현 | 해시 테이블 | Red-Black Tree |
| 범위 검색 | X | O |

### 선택 기준
```java
// 단순 중복 제거, 빠른 검색 → HashSet
Set<String> set1 = new HashSet<>();

// 정렬 필요, 범위 검색 → TreeSet
Set<String> set2 = new TreeSet<>();

// 순서 유지 + 빠른 검색 → LinkedHashSet
Set<String> set3 = new LinkedHashSet<>();
```

---

## 실전 예제

### 점수 순위
```java
TreeSet<Integer> scores = new TreeSet<>(Collections.reverseOrder());
scores.addAll(Arrays.asList(85, 90, 78, 92, 88));

System.out.println("전체 순위: " + scores);  // [92, 90, 88, 85, 78]
System.out.println("1등: " + scores.first());  // 92
System.out.println("90점 이상: " + scores.headSet(90, true));  // [92, 90]
```

### 시간대 이벤트
```java
TreeSet<LocalTime> events = new TreeSet<>();
events.add(LocalTime.of(9, 0));
events.add(LocalTime.of(14, 30));
events.add(LocalTime.of(11, 0));
events.add(LocalTime.of(16, 45));

LocalTime now = LocalTime.of(12, 0);

// 다음 이벤트
LocalTime next = events.ceiling(now);  // 14:30

// 오전 이벤트
SortedSet<LocalTime> morning = events.headSet(LocalTime.NOON);  // [9:00, 11:00]
```

### 문자열 사전 범위
```java
TreeSet<String> words = new TreeSet<>(
    Arrays.asList("apple", "banana", "cherry", "date", "elderberry")
);

// b~d 사이 단어
SortedSet<String> range = words.subSet("b", "e");
// [banana, cherry, date]
```

---

> [!tip] 핵심 정리
> - **TreeSet**: 정렬된 Set, Red-Black Tree
> - **범위 검색**: subSet, headSet, tailSet
> - **근접 검색**: lower, floor, higher, ceiling
> - 객체 저장: **Comparable** 또는 **Comparator** 필요
> - HashSet보다 느리지만 정렬/범위 검색 가능
> - null 저장 불가

---

#Java #TreeSet #Set #컬렉션 #정렬
