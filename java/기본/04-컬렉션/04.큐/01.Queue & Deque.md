## Queue란?

- **FIFO** (First In First Out) - 선입선출
- 대기열, 작업 큐, BFS 등에 활용

## Deque란?

- **Double-Ended Queue** - 양방향 큐
- 앞/뒤 모두 삽입/삭제 가능
- 스택 + 큐 기능

---

## Queue 인터페이스

### 생성

```java
import java.util.Queue;
import java.util.LinkedList;

Queue<String> queue = new LinkedList<>();
```

### 주요 메서드

|작업|예외 발생|null 반환|
|---|---|---|
|삽입|add(e)|offer(e)|
|삭제|remove()|poll()|
|조회|element()|peek()|

```java
Queue<String> queue = new LinkedList<>();

// 삽입
queue.offer("A");
queue.offer("B");
queue.offer("C");  // [A, B, C]

// 조회 (제거 안 함)
String front = queue.peek();  // "A"

// 삭제
String removed = queue.poll();  // "A" 반환, [B, C]

// 비어있을 때
Queue<String> empty = new LinkedList<>();
empty.poll();     // null (안전)
// empty.remove();  // NoSuchElementException
```

---

## Deque 인터페이스

### 생성

```java
import java.util.Deque;
import java.util.ArrayDeque;
import java.util.LinkedList;

Deque<String> deque1 = new ArrayDeque<>();  // 권장
Deque<String> deque2 = new LinkedList<>();
```

### 주요 메서드

|작업|First (앞)|Last (뒤)|
|---|---|---|
|삽입|addFirst / offerFirst|addLast / offerLast|
|삭제|removeFirst / pollFirst|removeLast / pollLast|
|조회|getFirst / peekFirst|getLast / peekLast|

```java
Deque<String> deque = new ArrayDeque<>();

// 앞에 추가
deque.addFirst("B");  // [B]
deque.addFirst("A");  // [A, B]

// 뒤에 추가
deque.addLast("C");   // [A, B, C]

// 조회
String first = deque.peekFirst();  // "A"
String last = deque.peekLast();    // "C"

// 삭제
deque.pollFirst();  // "A" 반환, [B, C]
deque.pollLast();   // "C" 반환, [B]
```

---

## 스택으로 사용

### Deque를 스택처럼

```java
Deque<String> stack = new ArrayDeque<>();

// push (앞에 추가)
stack.push("A");
stack.push("B");
stack.push("C");  // [C, B, A]

// peek (맨 앞 조회)
String top = stack.peek();  // "C"

// pop (맨 앞 제거)
String popped = stack.pop();  // "C", [B, A]
```

### Stack 클래스 (비권장)

```java
// 레거시 - 동기화로 느림
Stack<String> oldStack = new Stack<>();
oldStack.push("A");
oldStack.pop();

// 대신 ArrayDeque 사용 권장
Deque<String> stack = new ArrayDeque<>();
```

---

## 큐로 사용

### Deque를 큐처럼

```java
Deque<String> queue = new ArrayDeque<>();

// offer (뒤에 추가)
queue.offer("A");
queue.offer("B");
queue.offer("C");  // [A, B, C]

// poll (앞에서 제거)
String front = queue.poll();  // "A", [B, C]
```

---

## PriorityQueue

### 우선순위 큐

- 요소가 **우선순위대로** 정렬
- 최소값이 먼저 나옴 (기본)
- 힙(Heap) 구조

```java
import java.util.PriorityQueue;

// 기본: 오름차순 (최소 힙)
PriorityQueue<Integer> pq = new PriorityQueue<>();
pq.offer(30);
pq.offer(10);
pq.offer(20);

pq.poll();  // 10
pq.poll();  // 20
pq.poll();  // 30
```

### 내림차순 (최대 힙)

```java
PriorityQueue<Integer> maxPq = new PriorityQueue<>(Collections.reverseOrder());
maxPq.offer(30);
maxPq.offer(10);
maxPq.offer(20);

maxPq.poll();  // 30
maxPq.poll();  // 20
maxPq.poll();  // 10
```

### 사용자 정의 우선순위

```java
class Task {
    String name;
    int priority;
    
    Task(String name, int priority) {
        this.name = name;
        this.priority = priority;
    }
}

PriorityQueue<Task> taskQueue = new PriorityQueue<>(
    Comparator.comparingInt(t -> t.priority)
);

taskQueue.offer(new Task("낮은", 3));
taskQueue.offer(new Task("높은", 1));
taskQueue.offer(new Task("중간", 2));

taskQueue.poll().name;  // "높은"
taskQueue.poll().name;  // "중간"
```

---

## ArrayDeque vs LinkedList

|구분|ArrayDeque|LinkedList|
|---|---|---|
|구조|원형 배열|이중 연결 리스트|
|null|불허|허용|
|메모리|적음|많음|
|성능|빠름|느림|
|인덱스 접근|X|O(n)|

```java
// 대부분의 경우 ArrayDeque가 좋음
Deque<String> deque = new ArrayDeque<>();

// null이 필요하거나 List로도 사용 시
LinkedList<String> list = new LinkedList<>();
```

---

## 실전 예제

### BFS (너비 우선 탐색)

```java
public void bfs(int start, int[][] graph) {
    Queue<Integer> queue = new LinkedList<>();
    boolean[] visited = new boolean[graph.length];
    
    queue.offer(start);
    visited[start] = true;
    
    while (!queue.isEmpty()) {
        int node = queue.poll();
        System.out.println("방문: " + node);
        
        for (int next : graph[node]) {
            if (!visited[next]) {
                visited[next] = true;
                queue.offer(next);
            }
        }
    }
}
```

### 괄호 검사 (스택)

```java
public boolean isValid(String s) {
    Deque<Character> stack = new ArrayDeque<>();
    
    for (char c : s.toCharArray()) {
        if (c == '(' || c == '{' || c == '[') {
            stack.push(c);
        } else {
            if (stack.isEmpty()) return false;
            
            char top = stack.pop();
            if (c == ')' && top != '(') return false;
            if (c == '}' && top != '{') return false;
            if (c == ']' && top != '[') return false;
        }
    }
    
    return stack.isEmpty();
}
```

### 최근 N개 유지

```java
class RecentItems<T> {
    private Deque<T> items = new ArrayDeque<>();
    private int maxSize;
    
    RecentItems(int maxSize) {
        this.maxSize = maxSize;
    }
    
    void add(T item) {
        if (items.size() >= maxSize) {
            items.pollLast();  // 가장 오래된 것 제거
        }
        items.offerFirst(item);  // 맨 앞에 추가
    }
    
    List<T> getRecent() {
        return new ArrayList<>(items);
    }
}
```

### 작업 스케줄러

```java
class TaskScheduler {
    private PriorityQueue<Task> tasks;
    
    TaskScheduler() {
        // 마감일 순으로 정렬
        tasks = new PriorityQueue<>(Comparator.comparing(t -> t.deadline));
    }
    
    void addTask(Task task) {
        tasks.offer(task);
    }
    
    Task getNextTask() {
        return tasks.poll();
    }
}
```

---

## Queue 선택 가이드

```java
// 일반 큐 (FIFO)
Queue<String> queue = new LinkedList<>();

// 스택 (LIFO) 또는 양방향 큐
Deque<String> deque = new ArrayDeque<>();

// 우선순위 큐
PriorityQueue<Integer> pq = new PriorityQueue<>();

// 스레드 안전 큐
Queue<String> concurrent = new ConcurrentLinkedQueue<>();
BlockingQueue<String> blocking = new LinkedBlockingQueue<>();
```

---

> [!tip] 핵심 정리
> 
> - **Queue**: FIFO, offer/poll/peek
> - **Deque**: 양방향, 스택+큐, ArrayDeque 권장
> - **PriorityQueue**: 우선순위 정렬, 힙 구조
> - 스택: `push()`/`pop()` (Deque)
> - 큐: `offer()`/`poll()` (Queue)
> - **ArrayDeque**가 LinkedList보다 대부분 빠름

---

#Java #Queue #Deque #스택 #큐 #컬렉션