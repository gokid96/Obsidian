
## 스트림이란?
컬렉션/배열의 요소를 **함수형으로 처리**하는 API. Java 8 도입.
```java
List<String> names = Arrays.asList("Kim", "Lee", "Park", "Choi");

// 기존 방식
List<String> filtered = new ArrayList<>();
for (String name : names) {
    if (name.length() > 2) {
        filtered.add(name.toUpperCase());
    }
}

// 스트림
List<String> filtered = names.stream()
    .filter(n -> n.length() > 2)
    .map(String::toUpperCase)
    .collect(Collectors.toList());
```

## 특징
- **원본 불변**: 원본 데이터 변경 X
- **지연 연산**: 최종 연산 호출 시 실행
- **일회성**: 한 번 사용하면 재사용 불가

## 스트림 생성
```java
// 컬렉션
list.stream();

// 배열
Arrays.stream(arr);
Stream.of(1, 2, 3);

// 범위
IntStream.range(1, 5);      // 1,2,3,4
IntStream.rangeClosed(1, 5); // 1,2,3,4,5

// 무한 스트림
Stream.iterate(0, n -> n + 2);  // 0,2,4,6...
Stream.generate(Math::random);

// 파일
Files.lines(Path.of("file.txt"));
```

## 중간 연산 (Intermediate)

lazy 실행, 여러 개 체이닝 가능

| 연산 | 설명 | 예시 |
|------|------|------|
| `filter` | 조건 필터링 | `.filter(n -> n > 0)` |
| `map` | 변환 | `.map(String::toUpperCase)` |
| `flatMap` | 평탄화 | `.flatMap(list -> list.stream())` |
| `distinct` | 중복 제거 | `.distinct()` |
| `sorted` | 정렬 | `.sorted()` `.sorted(Comparator)` |
| `limit` | 개수 제한 | `.limit(5)` |
| `skip` | 건너뛰기 | `.skip(3)` |
| `peek` | 중간 확인 (디버깅) | `.peek(System.out::println)` |
```java
// flatMap 예시: 중첩 리스트 평탄화
List<List<Integer>> nested = Arrays.asList(
    Arrays.asList(1, 2),
    Arrays.asList(3, 4)
);
List<Integer> flat = nested.stream()
    .flatMap(List::stream)  // [1,2,3,4]
    .collect(Collectors.toList());
```

## 최종 연산 (Terminal)

스트림 소비, 결과 반환

| 연산 | 설명 | 반환 타입 |
|------|------|----------|
| `forEach` | 각 요소 처리 | void |
| `count` | 개수 | long |
| `collect` | 결과 수집 | Collection 등 |
| `reduce` | 누적 연산 | Optional/T |
| `findFirst` | 첫 요소 | Optional |
| `findAny` | 아무 요소 | Optional |
| `anyMatch` | 하나라도 만족? | boolean |
| `allMatch` | 모두 만족? | boolean |
| `noneMatch` | 모두 불만족? | boolean |
| `min/max` | 최솟값/최댓값 | Optional |
| `toArray` | 배열 변환 | T[] |

## reduce
```java
// 합계
int sum = numbers.stream()
    .reduce(0, (a, b) -> a + b);
// 또는
int sum = numbers.stream()
    .reduce(0, Integer::sum);

// 최댓값
Optional<Integer> max = numbers.stream()
    .reduce(Integer::max);
```

## collect & Collectors
```java
// 리스트
List<String> list = stream.collect(Collectors.toList());

// 셋
Set<String> set = stream.collect(Collectors.toSet());

// 맵
Map<Integer, String> map = stream
    .collect(Collectors.toMap(
        String::length,  // key
        s -> s           // value
    ));

// 문자열 합치기
String joined = stream.collect(Collectors.joining(", "));

// 그룹핑
Map<Integer, List<String>> byLength = stream
    .collect(Collectors.groupingBy(String::length));

// 파티셔닝 (2분할)
Map<Boolean, List<Integer>> partition = numbers.stream()
    .collect(Collectors.partitioningBy(n -> n > 0));

// 통계
IntSummaryStatistics stats = numbers.stream()
    .collect(Collectors.summarizingInt(Integer::intValue));
// stats.getSum(), getAverage(), getMax(), getMin(), getCount()
```

## 기본형 스트림

박싱/언박싱 오버헤드 제거
```java
IntStream intStream = list.stream().mapToInt(Integer::intValue);
LongStream longStream = list.stream().mapToLong(Long::valueOf);
DoubleStream doubleStream = list.stream().mapToDouble(Double::valueOf);

// 유용한 메서드
intStream.sum();
intStream.average();  // OptionalDouble
intStream.boxed();    // Stream<Integer>로 변환
```

## 병렬 스트림
```java
list.parallelStream()
    .filter(...)
    .map(...)
    .collect(...);

// 또는
list.stream()
    .parallel()
    ...
```

> ⚠️ 주의: 작은 데이터, 순서 의존 작업에는 비효율적

## 실전 예시
```java
// 나이가 20 이상인 사람의 이름을 정렬해서 출력
people.stream()
    .filter(p -> p.getAge() >= 20)
    .map(Person::getName)
    .sorted()
    .forEach(System.out::println);

// 부서별 평균 급여
Map<String, Double> avgSalaryByDept = employees.stream()
    .collect(Collectors.groupingBy(
        Employee::getDepartment,
        Collectors.averagingDouble(Employee::getSalary)
    ));
```