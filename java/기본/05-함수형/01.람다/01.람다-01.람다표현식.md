# 람다 표현식 (Lambda Expression)

## 람다란?
- **익명 함수**를 간결하게 표현
- 함수형 프로그래밍 지원 (Java 8+)
- **함수형 인터페이스**의 구현체

---

## 기본 문법

### 형식
```java
(매개변수) -> { 실행문 }
```

### 다양한 형태
```java
// 매개변수 없음
() -> System.out.println("Hello")

// 매개변수 1개 (괄호 생략 가능)
x -> x * 2
(x) -> x * 2

// 매개변수 여러 개
(x, y) -> x + y

// 실행문 여러 줄
(x, y) -> {
    int sum = x + y;
    return sum;
}

// 타입 명시 (생략 가능)
(int x, int y) -> x + y
```

---

## 익명 클래스 vs 람다

### 익명 클래스
```java
Runnable r1 = new Runnable() {
    @Override
    public void run() {
        System.out.println("Hello");
    }
};
```

### 람다
```java
Runnable r2 = () -> System.out.println("Hello");
```

### Comparator 예시
```java
// 익명 클래스
Comparator<String> comp1 = new Comparator<String>() {
    @Override
    public int compare(String a, String b) {
        return a.length() - b.length();
    }
};

// 람다
Comparator<String> comp2 = (a, b) -> a.length() - b.length();
```

---

## 함수형 인터페이스

### 정의
- **추상 메서드가 1개**인 인터페이스
- `@FunctionalInterface` 어노테이션 (선택)

```java
@FunctionalInterface
interface Calculator {
    int calculate(int a, int b);
}

// 람다로 구현
Calculator add = (a, b) -> a + b;
Calculator multiply = (a, b) -> a * b;

System.out.println(add.calculate(5, 3));       // 8
System.out.println(multiply.calculate(5, 3));  // 15
```

---

## 주요 함수형 인터페이스

### java.util.function 패키지

| 인터페이스 | 메서드 | 설명 |
|-----------|--------|------|
| `Supplier<T>` | `T get()` | 매개변수 X, 반환 O |
| `Consumer<T>` | `void accept(T)` | 매개변수 O, 반환 X |
| `Function<T,R>` | `R apply(T)` | 매개변수 O, 반환 O |
| `Predicate<T>` | `boolean test(T)` | 매개변수 O, boolean 반환 |
| `Runnable` | `void run()` | 매개변수 X, 반환 X |

### Supplier - 공급자
```java
Supplier<String> supplier = () -> "Hello";
String result = supplier.get();  // "Hello"

Supplier<Double> random = () -> Math.random();
System.out.println(random.get());  // 0.xxxxx
```

### Consumer - 소비자
```java
Consumer<String> printer = s -> System.out.println(s);
printer.accept("Hello");  // Hello

Consumer<List<Integer>> addAll = list -> {
    for (int i = 1; i <= 5; i++) {
        list.add(i);
    }
};
```

### Function - 변환
```java
Function<String, Integer> length = s -> s.length();
int len = length.apply("Hello");  // 5

Function<Integer, String> intToStr = i -> "숫자: " + i;
String str = intToStr.apply(100);  // "숫자: 100"
```

### Predicate - 조건
```java
Predicate<Integer> isPositive = n -> n > 0;
boolean result = isPositive.test(5);  // true

Predicate<String> isEmpty = s -> s == null || s.isEmpty();
```

---

## 함수형 인터페이스 조합

### Predicate 조합
```java
Predicate<Integer> isPositive = n -> n > 0;
Predicate<Integer> isEven = n -> n % 2 == 0;

// and
Predicate<Integer> isPositiveEven = isPositive.and(isEven);
isPositiveEven.test(4);   // true
isPositiveEven.test(-2);  // false

// or
Predicate<Integer> isPositiveOrEven = isPositive.or(isEven);

// negate (부정)
Predicate<Integer> isNegative = isPositive.negate();
```

### Function 조합
```java
Function<String, String> toUpper = s -> s.toUpperCase();
Function<String, String> addExclaim = s -> s + "!";

// andThen: toUpper 먼저, addExclaim 다음
Function<String, String> shout = toUpper.andThen(addExclaim);
shout.apply("hello");  // "HELLO!"

// compose: addExclaim 먼저, toUpper 다음
Function<String, String> composed = toUpper.compose(addExclaim);
composed.apply("hello");  // "HELLO!"
```

### Consumer 조합
```java
Consumer<String> print = s -> System.out.print(s);
Consumer<String> println = s -> System.out.println(s);

Consumer<String> printBoth = print.andThen(println);
```

---

## 메서드 참조 (Method Reference)

### 형식
```java
클래스::메서드
```

### 종류

#### 정적 메서드 참조
```java
// 람다
Function<String, Integer> parser1 = s -> Integer.parseInt(s);

// 메서드 참조
Function<String, Integer> parser2 = Integer::parseInt;
```

#### 인스턴스 메서드 참조 (특정 객체)
```java
String str = "Hello";

// 람다
Supplier<Integer> len1 = () -> str.length();

// 메서드 참조
Supplier<Integer> len2 = str::length;
```

#### 인스턴스 메서드 참조 (임의 객체)
```java
// 람다
Function<String, Integer> len1 = s -> s.length();

// 메서드 참조
Function<String, Integer> len2 = String::length;

// 정렬에서
list.sort((a, b) -> a.compareTo(b));
list.sort(String::compareTo);
```

#### 생성자 참조
```java
// 람다
Supplier<ArrayList<String>> supplier1 = () -> new ArrayList<>();

// 생성자 참조
Supplier<ArrayList<String>> supplier2 = ArrayList::new;

// 매개변수 있는 생성자
Function<String, StringBuilder> sbCreator = StringBuilder::new;
StringBuilder sb = sbCreator.apply("Hello");
```

---

## 람다와 지역 변수

### effectively final
```java
int num = 10;  // effectively final (변경 안 함)

Runnable r = () -> {
    System.out.println(num);  // OK
};

// num = 20;  // 이렇게 변경하면 람다에서 사용 불가
```

### 왜 final이어야 하나?
```java
// 람다는 변수의 복사본을 사용
// 변경 가능하면 동기화 문제 발생
```

---

## 실전 예제

### 리스트 정렬
```java
List<String> names = Arrays.asList("Kim", "Lee", "Park", "Choi");

// 알파벳순
names.sort((a, b) -> a.compareTo(b));
names.sort(String::compareTo);

// 길이순
names.sort((a, b) -> a.length() - b.length());
names.sort(Comparator.comparingInt(String::length));

// 역순
names.sort(Comparator.reverseOrder());
```

### 컬렉션 순회
```java
List<String> list = Arrays.asList("A", "B", "C");

// forEach
list.forEach(s -> System.out.println(s));
list.forEach(System.out::println);

// Map
Map<String, Integer> map = Map.of("A", 1, "B", 2);
map.forEach((k, v) -> System.out.println(k + "=" + v));
```

### 조건 필터링
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6);

// removeIf
numbers.removeIf(n -> n % 2 == 0);  // 짝수 제거

// replaceAll
numbers.replaceAll(n -> n * 2);  // 모두 2배
```

### 이벤트 처리
```java
button.addActionListener(e -> System.out.println("Clicked!"));

button.addActionListener(e -> {
    System.out.println("Button: " + e.getSource());
    System.out.println("Time: " + e.getWhen());
});
```

---

## BiFunction, BiConsumer, BiPredicate

### 매개변수 2개
```java
BiFunction<Integer, Integer, Integer> add = (a, b) -> a + b;
int sum = add.apply(3, 5);  // 8

BiConsumer<String, Integer> printer = (name, age) -> 
    System.out.println(name + ": " + age);
printer.accept("홍길동", 25);

BiPredicate<String, Integer> lengthCheck = (s, len) -> s.length() > len;
boolean result = lengthCheck.test("Hello", 3);  // true
```

---

> [!tip] 핵심 정리
> - **람다**: `(매개변수) -> { 실행문 }`
> - **함수형 인터페이스**: 추상 메서드 1개
> - **Supplier**: 공급 `() -> T`
> - **Consumer**: 소비 `T -> void`
> - **Function**: 변환 `T -> R`
> - **Predicate**: 조건 `T -> boolean`
> - **메서드 참조**: `클래스::메서드`

---

#Java #람다 #Lambda #함수형프로그래밍 #FunctionalInterface
