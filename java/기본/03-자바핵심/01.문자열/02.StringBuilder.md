# StringBuilder / StringBuffer

## 가변 문자열
- String과 달리 **내용 변경 가능**
- 문자열 조작 시 **새 객체 생성 안 함**
- 반복적인 문자열 연산에 효율적

---

## StringBuilder vs StringBuffer

| 구분 | StringBuilder | StringBuffer |
|------|---------------|--------------|
| 동기화 | X | O (synchronized) |
| 속도 | 빠름 | 느림 |
| 스레드 안전 | X | O |
| 사용 상황 | 단일 스레드 | 멀티 스레드 |

```java
// 대부분의 경우 StringBuilder 사용
StringBuilder sb = new StringBuilder();

// 멀티 스레드 환경에서만 StringBuffer
StringBuffer sbf = new StringBuffer();
```

---

## 생성

```java
// 빈 객체 (기본 용량 16)
StringBuilder sb1 = new StringBuilder();

// 초기 용량 지정
StringBuilder sb2 = new StringBuilder(100);

// 초기 문자열
StringBuilder sb3 = new StringBuilder("Hello");
```

---

## 주요 메서드

### append() - 추가
```java
StringBuilder sb = new StringBuilder();

sb.append("Hello");
sb.append(" ");
sb.append("World");
sb.append(123);
sb.append(true);

System.out.println(sb.toString());  // "Hello World123true"
```

### 메서드 체이닝
```java
StringBuilder sb = new StringBuilder();

sb.append("Hello")
  .append(" ")
  .append("World")
  .append("!");

System.out.println(sb);  // "Hello World!"
```

### insert() - 삽입
```java
StringBuilder sb = new StringBuilder("Hello World");

sb.insert(5, ",");      // "Hello, World"
sb.insert(0, "Say: ");  // "Say: Hello, World"
```

### delete() - 삭제
```java
StringBuilder sb = new StringBuilder("Hello World");

sb.delete(5, 11);       // "Hello" (5~10 삭제)
sb.deleteCharAt(0);     // "ello"
```

### replace() - 치환
```java
StringBuilder sb = new StringBuilder("Hello World");

sb.replace(6, 11, "Java");  // "Hello Java"
```

### reverse() - 뒤집기
```java
StringBuilder sb = new StringBuilder("Hello");

sb.reverse();
System.out.println(sb);  // "olleH"
```

### 기타 메서드
```java
StringBuilder sb = new StringBuilder("Hello");

sb.length();           // 5
sb.capacity();         // 21 (16 + 5)
sb.charAt(0);          // 'H'
sb.setCharAt(0, 'h');  // "hello"
sb.substring(0, 3);    // "hel" (새 String 반환)
sb.toString();         // String으로 변환
```

---

## String vs StringBuilder 성능

### 문자열 연결 비교
```java
// String (느림)
long start1 = System.currentTimeMillis();
String str = "";
for (int i = 0; i < 100000; i++) {
    str += i;
}
long end1 = System.currentTimeMillis();
System.out.println("String: " + (end1 - start1) + "ms");

// StringBuilder (빠름)
long start2 = System.currentTimeMillis();
StringBuilder sb = new StringBuilder();
for (int i = 0; i < 100000; i++) {
    sb.append(i);
}
String result = sb.toString();
long end2 = System.currentTimeMillis();
System.out.println("StringBuilder: " + (end2 - start2) + "ms");

// 결과 예시:
// String: 3000ms
// StringBuilder: 5ms
```

---

## 용량 (Capacity)

### 자동 확장
```java
StringBuilder sb = new StringBuilder();  // 기본 용량 16

System.out.println(sb.capacity());  // 16

sb.append("Hello World Hello World");  // 24자

System.out.println(sb.capacity());  // 34 (자동 확장)
// 새 용량 = (기존 용량 + 1) * 2
```

### 용량 관리
```java
StringBuilder sb = new StringBuilder();

// 용량 확보
sb.ensureCapacity(100);

// 크기 맞추기
sb.trimToSize();  // length에 맞게 용량 축소
```

### 미리 용량 지정 (성능 향상)
```java
// 대략적인 크기를 알 때
StringBuilder sb = new StringBuilder(1000);
```

---

## 실전 예제

### CSV 생성
```java
public String toCSV(List<String> data) {
    StringBuilder sb = new StringBuilder();
    
    for (int i = 0; i < data.size(); i++) {
        sb.append(data.get(i));
        if (i < data.size() - 1) {
            sb.append(",");
        }
    }
    
    return sb.toString();
}

// 또는 String.join 사용
String csv = String.join(",", data);
```

### HTML 생성
```java
public String buildTable(String[][] data) {
    StringBuilder sb = new StringBuilder();
    
    sb.append("<table>\n");
    for (String[] row : data) {
        sb.append("  <tr>\n");
        for (String cell : row) {
            sb.append("    <td>").append(cell).append("</td>\n");
        }
        sb.append("  </tr>\n");
    }
    sb.append("</table>");
    
    return sb.toString();
}
```

### 쿼리 빌더
```java
public String buildSelectQuery(String table, String[] columns, String where) {
    StringBuilder sb = new StringBuilder();
    
    sb.append("SELECT ");
    sb.append(String.join(", ", columns));
    sb.append(" FROM ").append(table);
    
    if (where != null && !where.isEmpty()) {
        sb.append(" WHERE ").append(where);
    }
    
    return sb.toString();
}

// 사용
String query = buildSelectQuery("users", 
    new String[]{"id", "name", "email"}, 
    "age > 20");
// "SELECT id, name, email FROM users WHERE age > 20"
```

### 문자열 반복
```java
public String repeat(String str, int count) {
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < count; i++) {
        sb.append(str);
    }
    return sb.toString();
}

// Java 11+ 에서는
"Ha".repeat(3);  // "HaHaHa"
```

---

## 사용 지침

### StringBuilder 사용 시점
```java
// 1. 반복문에서 문자열 연결
StringBuilder sb = new StringBuilder();
for (String s : list) {
    sb.append(s);
}

// 2. 조건에 따른 동적 문자열 생성
StringBuilder sb = new StringBuilder();
sb.append("SELECT * FROM users");
if (hasCondition) {
    sb.append(" WHERE active = true");
}

// 3. 대량의 문자열 조작
StringBuilder sb = new StringBuilder(largeText);
sb.replace(0, 10, "New");
sb.delete(100, 200);
```

### String 사용 시점
```java
// 1. 단순 문자열
String name = "홍길동";

// 2. 몇 번 안 되는 연결 (컴파일러 최적화)
String msg = "Hello" + " " + "World";

// 3. 불변성이 필요한 경우
```

---

> [!tip] 핵심 정리
> - **StringBuilder**: 가변 문자열, 단일 스레드용
> - **StringBuffer**: 가변 문자열, 멀티 스레드용 (동기화)
> - 반복 연결에는 **StringBuilder** 필수
> - **메서드 체이닝** 가능: `sb.append().append()`
> - 작업 완료 후 **toString()**으로 String 변환

---

#Java #StringBuilder #StringBuffer #문자열 #자바핵심
