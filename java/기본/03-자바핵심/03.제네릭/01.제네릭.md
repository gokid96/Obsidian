# 제네릭 (Generic)

## 제네릭이란?
- **타입을 파라미터화**하여 컴파일 시 타입 체크
- 타입 안정성 + 코드 재사용성
- 컬렉션 프레임워크에서 필수

---

## 제네릭 사용 이유

### 제네릭 없이
```java
// Object로 저장
List list = new ArrayList();
list.add("Hello");
list.add(123);  // 아무거나 넣을 수 있음

// 꺼낼 때 캐스팅 필요
String str = (String) list.get(0);
String str2 = (String) list.get(1);  // 런타임 에러!
```

### 제네릭 사용
```java
// 타입 지정
List<String> list = new ArrayList<>();
list.add("Hello");
// list.add(123);  // 컴파일 에러!

// 캐스팅 불필요
String str = list.get(0);
```

---

## 제네릭 클래스

### 정의
```java
public class Box<T> {
    private T item;
    
    public void set(T item) {
        this.item = item;
    }
    
    public T get() {
        return item;
    }
}
```

### 사용
```java
Box<String> stringBox = new Box<>();
stringBox.set("Hello");
String str = stringBox.get();

Box<Integer> intBox = new Box<>();
intBox.set(123);
Integer num = intBox.get();
```

### 타입 파라미터 관례
| 기호 | 의미 |
|------|------|
| T | Type |
| E | Element |
| K | Key |
| V | Value |
| N | Number |
| R | Return |

---

## 제네릭 메서드

### 정의
```java
public class Util {
    // <T>: 타입 파라미터 선언
    public static <T> T getFirst(T[] array) {
        if (array == null || array.length == 0) {
            return null;
        }
        return array[0];
    }
    
    public static <T> void printArray(T[] array) {
        for (T item : array) {
            System.out.println(item);
        }
    }
}
```

### 사용
```java
String[] names = {"Kim", "Lee", "Park"};
String first = Util.getFirst(names);  // 타입 추론

Integer[] numbers = {1, 2, 3};
Integer firstNum = Util.<Integer>getFirst(numbers);  // 명시적
```

---

## 멀티 타입 파라미터

```java
public class Pair<K, V> {
    private K key;
    private V value;
    
    public Pair(K key, V value) {
        this.key = key;
        this.value = value;
    }
    
    public K getKey() { return key; }
    public V getValue() { return value; }
}

// 사용
Pair<String, Integer> pair = new Pair<>("나이", 25);
String key = pair.getKey();      // "나이"
Integer value = pair.getValue(); // 25
```

---

## 타입 제한 (Bounded Type)

### extends - 상한 제한
```java
// T는 Number 또는 그 하위 타입만
public class NumberBox<T extends Number> {
    private T number;
    
    public void set(T number) {
        this.number = number;
    }
    
    public double getDouble() {
        return number.doubleValue();  // Number 메서드 사용 가능
    }
}

NumberBox<Integer> intBox = new NumberBox<>();  // OK
NumberBox<Double> doubleBox = new NumberBox<>();  // OK
// NumberBox<String> strBox = new NumberBox<>();  // 에러!
```

### 다중 제한
```java
// 클래스와 인터페이스 동시 제한
public <T extends Number & Comparable<T>> T max(T a, T b) {
    return a.compareTo(b) > 0 ? a : b;
}
```

---

## 와일드카드 (?)

### 비제한 와일드카드
```java
// 모든 타입 허용
public void printList(List<?> list) {
    for (Object item : list) {
        System.out.println(item);
    }
}

printList(new ArrayList<String>());
printList(new ArrayList<Integer>());
```

### 상한 와일드카드 (extends)
```java
// Number와 하위 타입만
public double sum(List<? extends Number> list) {
    double sum = 0;
    for (Number num : list) {
        sum += num.doubleValue();
    }
    return sum;
}

sum(new ArrayList<Integer>());  // OK
sum(new ArrayList<Double>());   // OK
// sum(new ArrayList<String>());  // 에러!
```

### 하한 와일드카드 (super)
```java
// Integer와 상위 타입만
public void addNumbers(List<? super Integer> list) {
    list.add(1);
    list.add(2);
    list.add(3);
}

addNumbers(new ArrayList<Integer>());  // OK
addNumbers(new ArrayList<Number>());   // OK
addNumbers(new ArrayList<Object>());   // OK
// addNumbers(new ArrayList<Double>());  // 에러!
```

### PECS 원칙
- **P**roducer **E**xtends: 읽기 전용 → `extends`
- **C**onsumer **S**uper: 쓰기 전용 → `super`

```java
// 읽기 (Producer) - extends
public void copy(List<? extends Number> src, 
                 List<? super Number> dest) {
    for (Number num : src) {  // 읽기
        dest.add(num);        // 쓰기
    }
}
```

---

## 타입 소거 (Type Erasure)

### 컴파일 후 타입 정보 제거
```java
// 컴파일 전
List<String> list = new ArrayList<>();
list.add("Hello");
String str = list.get(0);

// 컴파일 후 (타입 소거)
List list = new ArrayList();
list.add("Hello");
String str = (String) list.get(0);
```

### 제한 사항
```java
public class Box<T> {
    // new T()  // 에러! 타입 파라미터로 인스턴스 생성 불가
    // new T[]  // 에러! 타입 파라미터로 배열 생성 불가
    // T.class  // 에러! 타입 파라미터로 class 리터럴 불가
    
    // instanceof도 불가
    // if (obj instanceof T) { }  // 에러!
}
```

---

## 제네릭 상속과 구현

### 제네릭 클래스 상속
```java
// 부모
public class Box<T> {
    protected T item;
}

// 타입 유지
public class ColorBox<T> extends Box<T> {
    private String color;
}

// 타입 지정
public class StringBox extends Box<String> {
    // item은 String 타입
}
```

### 제네릭 인터페이스 구현
```java
public interface Repository<T> {
    void save(T entity);
    T findById(int id);
}

public class UserRepository implements Repository<User> {
    @Override
    public void save(User user) { }
    
    @Override
    public User findById(int id) { return null; }
}
```

---

## 실전 예제

### 제네릭 스택
```java
public class Stack<T> {
    private List<T> items = new ArrayList<>();
    
    public void push(T item) {
        items.add(item);
    }
    
    public T pop() {
        if (isEmpty()) {
            throw new EmptyStackException();
        }
        return items.remove(items.size() - 1);
    }
    
    public T peek() {
        if (isEmpty()) {
            throw new EmptyStackException();
        }
        return items.get(items.size() - 1);
    }
    
    public boolean isEmpty() {
        return items.isEmpty();
    }
}

// 사용
Stack<String> stack = new Stack<>();
stack.push("A");
stack.push("B");
System.out.println(stack.pop());  // "B"
```

### 제네릭 유틸리티
```java
public class CollectionUtils {
    
    public static <T> List<T> filter(List<T> list, Predicate<T> predicate) {
        List<T> result = new ArrayList<>();
        for (T item : list) {
            if (predicate.test(item)) {
                result.add(item);
            }
        }
        return result;
    }
    
    public static <T, R> List<R> map(List<T> list, Function<T, R> mapper) {
        List<R> result = new ArrayList<>();
        for (T item : list) {
            result.add(mapper.apply(item));
        }
        return result;
    }
}
```

---

> [!tip] 핵심 정리
> - **제네릭**: 타입을 파라미터화, 타입 안정성
> - `<T>`: 제네릭 타입 파라미터
> - `<T extends X>`: 상한 제한
> - `<?>`: 와일드카드
> - `<? extends T>`: 읽기 (Producer)
> - `<? super T>`: 쓰기 (Consumer)
> - 타입 소거로 런타임에는 타입 정보 없음

---

#Java #제네릭 #Generic #타입파라미터 #자바핵심
