
## ORM이란?

ORM은 객체지향 프로그래밍 언어와 관계형 데이터베이스를 연결하는 프로그래밍 기술입니다.

### 핵심 개념

- 객체와 관계형 데이터베이스의 데이터를 자동으로 매핑
- 개발자가 SQL 대신 객체 중심으로 데이터 다룰 수 있게 함

## ORM의 주요 특징

### 1. 객체와 테이블 매핑

```java
@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "username")
    private String name;
    
    @Column(name = "email")
    private String email;
}
```

### 2. 관계 매핑

```java
@Entity
public class Order {
    @Id
    private Long id;
    
    // 다대일 관계 매핑
    @ManyToOne
    @JoinColumn(name = "user_id")
    private User user;
    
    // 일대다 관계 매핑
    @OneToMany(mappedBy = "order")
    private List<OrderItem> items;
}
```

## ORM의 주요 장점

### 1. 생산성 향상

- 반복적인 JDBC 코드 감소
- 객체 중심의 개발 가능
- 데이터베이스 종속성 감소

### 2. 유지보수성

- 객체지향적 코드 구조
- 데이터베이스 스키마 변경에 유연한 대응

### 3. 성능 최적화

- 캐싱 메커니즘 제공
- 지연 로딩(Lazy Loading) 지원
- 벌크 연산 최적화

## ORM 사용 예시

### 기본 CRUD 연산

```java
@Service
public class UserService {
    @PersistenceContext
    private EntityManager entityManager;

    // 생성(Create)
    @Transactional
    public User createUser(User user) {
        entityManager.persist(user);
        return user;
    }

    // 조회(Read)
    public User findUser(Long id) {
        return entityManager.find(User.class, id);
    }

    // 수정(Update)
    @Transactional
    public User updateUser(User user) {
        return entityManager.merge(user);
    }

    // 삭제(Delete)
    @Transactional
    public void deleteUser(Long id) {
        User user = entityManager.find(User.class, id);
        entityManager.remove(user);
    }
}
```

### 복잡한 쿼리 처리

```java
// JPQL 사용 예시
public List<User> findActiveUsers() {
    return entityManager.createQuery(
        "SELECT u FROM User u WHERE u.status = :status", User.class)
        .setParameter("status", "ACTIVE")
        .getResultList();
}

// Criteria API 사용 예시
public List<User> complexUserSearch(String name, String email) {
    CriteriaBuilder cb = entityManager.getCriteriaBuilder();
    CriteriaQuery<User> query = cb.createQuery(User.class);
    Root<User> user = query.from(User.class);

    List<Predicate> conditions = new ArrayList<>();
    
    if (name != null) {
        conditions.add(cb.like(user.get("name"), "%" + name + "%"));
    }
    
    if (email != null) {
        conditions.add(cb.like(user.get("email"), "%" + email + "%"));
    }

    query.where(conditions.toArray(new Predicate[0]));
    
    return entityManager.createQuery(query).getResultList();
}
```

## ORM의 주의사항

### 성능 고려사항

- N+1 쿼리 문제 주의
- 과도한 객체 생성 방지
- 적절한 페치 전략 사용

### 복잡한 쿼리 처리

- 매우 복잡한 쿼리는 native query 고려
- 성능이 중요한 지점은 최적화 필요

### N+1 쿼리 문제 해결

```java
// 페치 조인으로 N+1 쿼리 문제 해결
public List<Order> findOrdersWithUsers() {
    return entityManager.createQuery(
        "SELECT DISTINCT o FROM Order o " +
        "JOIN FETCH o.user", Order.class)
        .getResultList();
}

// EntityGraph 사용
@EntityGraph(attributePaths = {"user"})
@Query("SELECT o FROM Order o")
List<Order> findAllWithUser();
```

### 지연 로딩과 즉시 로딩

```java
@Entity
public class Order {
    // 지연 로딩 - 실제 사용 시점에 로딩
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id")
    private User user;

    // 즉시 로딩 - 조회 시 즉시 함께 로딩
    @OneToMany(fetch = FetchType.EAGER)
    private List<OrderItem> items;
}
```

## ORM 설계 원칙

### 1. 도메인 모델 중심 설계

- 데이터베이스가 아닌 도메인 로직에 집중
- 풍부한 도메인 모델 구현

### 2. 객체지향 원칙 준수

- 상속, 다형성 등 객체지향 개념 활용
- 객체 간 관계를 명확하게 모델링

## 결론

ORM은 객체지향 프로그래밍과 관계형 데이터베이스 사이의 불일치를 해결하는 강력한 도구입니다. 장점을 최대화하고 잠재적 pitfall을 피하기 위해서는 신중한 설계와 지속적인 최적화가 필요합니다.