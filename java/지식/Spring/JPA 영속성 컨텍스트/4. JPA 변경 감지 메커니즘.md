## 변경 감지(Dirty Checking)란?

변경 감지는 JPA에서 엔티티의 상태 변경을 자동으로 추적하고 데이터베이스에 반영하는 핵심 메커니즘입니다.

### 핵심 원리

1. 엔티티 최초 조회 시 스냅샷 생성
2. 트랜잭션 커밋 시점에 스냅샷과 현재 엔티티 상태 비교
3. 변경된 부분 감지 및 자동 UPDATE SQL 생성

## 변경 감지 상세 과정

### 1. 엔티티 조회 및 스냅샷 생성

```java
@Transactional
public void changeDetectionProcess() {
    // 엔티티 조회 시 최초 상태 스냅샷 생성
    Member member = entityManager.find(Member.class, 1L);
    
    // 최초 조회 시점의 상태가 스냅샷으로 저장됨
    // 이 시점의 name, age 등이 원본 상태로 기록
}
```

### 2. 엔티티 상태 변경

```java
@Transactional
public void updateMember() {
    // 1. 엔티티 조회
    Member member = entityManager.find(Member.class, 1L);
    
    // 2. 엔티티 상태 변경
    member.setName("새로운 이름");
    member.setAge(30);
    
    // 별도의 update 메서드 호출 불필요
    // 트랜잭션 커밋 시 자동으로 변경 감지
}
```

### 3. 트랜잭션 커밋 시 변경 감지 과정

```java
// JPA 내부적으로 다음과 같은 과정 수행
public void commitTransaction() {
    // 1. 스냅샷과 현재 엔티티 상태 비교
    if (isChanged(member, snapshot)) {
        // 2. 변경된 필드 확인
        List<ChangedField> changedFields = findChangedFields(member, snapshot);
        
        // 3. 해당 필드에 대한 UPDATE SQL 자동 생성
        generateUpdateSQL(member, changedFields);
    }
}
```

## 변경 감지의 특징

### 장점

- 개발자의 명시적 update 호출 불필요
- 코드의 간결성 확보
- 모든 필드의 변경을 자동으로 추적

### 성능 고려사항

- 모든 필드의 변경을 추적하므로 일부 오버헤드 존재
- 대량 데이터 처리 시 성능에 주의 필요

## 고급 사용 예제

### 부분 필드 업데이트

```java
@Entity
public class Product {
    @Id
    private Long id;
    private String name;
    private int price;
    
    // updatable = false 설정으로 특정 필드 변경 제외
    @Column(updatable = false)
    private LocalDateTime createdAt;
}

@Service
public class ProductService {
    @Transactional
    public void updateProductPrice(Long productId, int newPrice) {
        Product product = entityManager.find(Product.class, productId);
        
        // 가격만 변경 - createdAt은 변경 대상에서 제외
        product.setPrice(newPrice);
        // 트랜잭션 커밋 시 price 필드만 업데이트
    }
}
```

### 연관관계 변경

```java
@Transactional
public void changeUserTeam() {
    User user = entityManager.find(User.class, 1L);
    Team newTeam = entityManager.find(Team.class, 2L);
    
    // 연관관계 변경도 변경 감지로 자동 처리
    user.setTeam(newTeam);
}
```

## 성능 최적화 전략

### 벌크 연산 고려

```java
@Transactional
public void bulkUpdate() {
    // 대량 업데이트의 경우 JPQL 벌크 연산 사용
    int updatedCount = entityManager.createQuery(
        "UPDATE Product p SET p.price = p.price * 1.1 " +
        "WHERE p.category = :category")
        .setParameter("category", "ELECTRONICS")
        .executeUpdate();
    
    // 영속성 컨텍스트 초기화
    entityManager.clear();
}
```

### 불필요한 변경 감지 방지

```java
@Transactional(readOnly = true)
public void readOnlyMethod() {
    // 읽기 전용 트랜잭션에서는 변경 감지 비활성화
    Member member = entityManager.find(Member.class, 1L);
    // 변경 없이 읽기만 수행
}
```

## 주의사항

### 성능 고려

- 과도한 엔티티 변경은 성능 저하 가능
- 대량 데이터 처리 시 벌크 연산 고려
- 불필요한 변경 감지 최소화

### 메모리 관리

- 영속성 컨텍스트의 1차 캐시 크기에 주의
- 필요 시 `clear()` 메서드로 캐시 초기화

## 결론

변경 감지 메커니즘은 JPA의 강력한 기능으로, 데이터베이스 상호작용을 자동화하고 코드를 간결하게 만듭니다. 하지만 성능과 메모리 사용에 대한 신중한 접근이 필요합니다.