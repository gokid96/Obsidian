
# 스프링 싱글턴 패턴

**스프링이 객체를 딱 한 번만 생성해서 계속 재사용하는 패턴**

----
## 스프링 싱글턴이란?

스프링에서는 **기본적으로 빈(Bean)을 싱글턴 스코프로 관리**한다.
- 스프링 컨테이너당 하나의 인스턴스만 생성
- 생성된 인스턴스를 공유해서 사용
```java
@Service
public class UserService {
    // 스프링 컨테이너에서 이 클래스의 인스턴스는 하나만 생성됨
}
```

---

## 일반 싱글턴 vs 스프링 싱글턴

### 일반 싱글턴 패턴 (GoF)
- JVM당 하나의 인스턴스만 존재
- 클래스 자체에서 인스턴스 생성을 제어
```java
public class Singleton {
	// 클래스 내부에 미리 instance 객체를 만들어둠
    private static final Singleton instance = new Singleton();
    
    // 2. private 생성자 = 외부에서 new Singleton() 못하게 막음!
    private Singleton() {} // private 생성자
    
    // 3.getInstance()를 public 메서드로 선언해서 1번에 만들어둔 객체만 리턴하게 함
    public static Singleton getInstance() {
        return instance;
    }
}
```

### 스프링 싱글턴
- 스프링 컨테이너가 관리
- 컨테이너당 하나의 인스턴스 보장
- 빈으로 등록해서 재사용
```java
@Service
public class UserService {
    // 스프링이 관리하는 싱글턴 빈
}
```

---

## 스프링이 싱글턴을 사용하는 이유

웹 애플리케이션 환경:
- 동시에 수많은 요청이 들어옴
- 매 요청마다 객체를 새로 생성하면 메모리 낭비 & 성능 저하

**싱글턴 사용 시 장점:**
- ✅ 메모리 절약 (객체 하나만 생성)
- ✅ 성능 향상 (매번 생성 비용 없음)
```java
// ❌ 매 요청마다 new UserService() - 비효율적
// ✅ 스프링이 만든 하나의 UserService 재사용 - 효율적
```

---

## DI(의존성 주입)와의 관계

**싱글턴과 DI는 세트 개념!**

### 왜 빈으로 등록되어야 DI가 가능한가?

**DI의 개념 = `new`로 생성하지 않고, 빈으로 등록된 객체를 주입받는 방식**
```java
// ❌ 빈이 아닌 경우 - DI 불가능
public class UserService {
    // 스프링이 관리 안함
}

@RestController
public class UserController {
    @Autowired
    private UserService userService;  // ← null! 주입 실패
    // 스프링: "UserService? 내가 관리하는 빈이 아닌데?"
}
```
```java
// ✅ 빈으로 등록된 경우 - DI 가능
@Service  // ← 빈 등록!
public class UserService {
    // 스프링이 객체 만들어서 컨테이너에 보관
}

@RestController
public class UserController {
    @Autowired
    private UserService userService;  // ← 주입 성공!
    // 스프링: "UserService? 내가 보관중인 그 객체 주입해줄게"
}
```

### 싱글턴 + DI 작동 원리
```java
@RestController
public class UserController {
    private final UserService userService;  // DI로 주입받음
    
    @Autowired
    public UserController(UserService userService) {
        this.userService = userService;  // ← 스프링이 싱글턴 객체를 주입
    }
}

@Service
public class UserService {
    private final UserRepository userRepository;  // DI로 주입받음
    
    @Autowired
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;  // ← 싱글턴 객체 주입
    }
}
```

**정리:**
- **싱글턴** = 객체를 하나만 만들어서 보관
- **DI** = 그 보관된 객체를 필요한 곳에 자동으로 연결

---

## 싱글턴 빈 사용 시 주의사항

### 상태를 가지지 않도록 설계 (Stateless)

싱글턴 빈은 여러 스레드가 동시에 접근 가능
→ 인스턴스 변수에 상태 저장 시 동시성 문제 발생!
```java
@Service
public class UserService {
    // ❌ 나쁜 예: 인스턴스 변수에 상태 저장
    private int count = 0;
    
    public void process() {
        count++; // 동시성 문제 발생 가능!
    }
}
```
```java
@Service
public class UserService {
    // ✅ 좋은 예: 지역 변수 사용
    public void process() {
        int count = 0;  // 지역 변수는 안전
        count++;
    }
}
```

**안전한 방법:**
- 지역 변수 사용
- 파라미터 사용
- 필요 시 `ThreadLocal` 활용

---

## 다른 빈 스코프

스프링은 싱글턴 외에도 여러 스코프 제공:

| 스코프                | 설명                  |
| ------------------ | ------------------- |
| **singleton** (기본) | 스프링 컨테이너당 하나의 인스턴스  |
| **prototype**      | 요청할 때마다 새로운 인스턴스 생성 |
| **request**        | HTTP 요청당 하나의 인스턴스   |
| **session**        | HTTP 세션당 하나의 인스턴스   |
```java
@Service
@Scope("prototype")
public class PrototypeService {
    // 매번 새로운 인스턴스가 생성됨
}
```

---
- 100명이 게시글 조회해도 → 같은 `PostService` 객체 사용
- 1000명이 회원가입해도 → 같은 `UserService` 객체 사용

**매번 `new` 안 하고, 처음 만든 그 객체 하나를 계속 돌려쓴다!**

---

## 핵심 요약

1. **스프링 싱글턴** = 객체를 딱 한 번만 생성해서 계속 재사용
2. **빈으로 등록**되어야 DI로 주입 가능
3. **DI** = `new` 없이 빈으로 등록된 객체를 주입받는 것
4. **주의사항**: 상태를 가지지 않도록 설계 (Stateless)
5. 스프링의 기본 빈 스코프는 **싱글턴**

---
- **문제 상황**: HTTP는 연결-응답-종료를 반복 → 매번 new로 객체 생성하면 성능 저하
- **해결책**: 싱글턴 패턴 → 객체 한 번만 만들고 계속 재사용
- **스프링의 역할**:
    - 개발자가 싱글턴 코드 직접 안 짜도 됨
    - `@Service` 같은 어노테이션으로 **빈 등록**
    - **IoC 컨테이너**가 빈들을 관리
- **사용 방법**: **DI**로 `new` 없이 빈을 주입받아 사용


## 시각화하면

```
[HTTP 요청] → [스프링 서버]
   ↓
[IoC 컨테이너] 
   ├─ UserService (빈) ← 싱글턴
   ├─ PostService (빈) ← 싱글턴  
   └─ UserRepository (빈) ← 싱글턴
   ↓
[DI로 주입] → [Controller가 재사용]
```