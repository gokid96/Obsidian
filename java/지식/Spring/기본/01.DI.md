
# DI (Dependency Injection)

## 강한 결합 vs 느슨한 결합

**강한 결합:**
```java
@Service
public class PostService {
    private final PostRepositoryImpl repository = new PostRepositoryImpl();
    // ❌ 구현체에 직접 의존
    // ❌ 변경 시 코드 수정 필요
    // ❌ 테스트 어려움
}
```

**느슨한 결합 (DI):**
```java
@Service
public class PostService {
    private final PostRepository postRepository;  // 인터페이스에 의존
    
    public PostService(PostRepository postRepository) {
        this.postRepository = postRepository;  // Spring이 주입
    }
}
```
- ✅ 구현체 변경 시 Service 코드 변경 불필요
- ✅ 테스트 시 Mock 객체 주입 가능
- ✅ 유연한 구조

## 실제 동작 과정

### 운영 환경 (Spring이 주입)
```java
// Spring이 하는 일:
// 1. PostRepository 구현체 자동 생성
PostRepository realRepo = new SimpleJpaRepository(...);

// 2. Service 생성하면서 주입
PostService service = new PostService(realRepo);

// 3. 결과: 실제 DB 연결된 구현체 사용
```

### 테스트 환경 (개발자가 Mock 주입)
```java
@Test
void test() {
    // 1. Mock 생성
    PostRepository mockRepo = mock(PostRepository.class);
    when(mockRepo.findByUserId(1L)).thenReturn(fakePosts);
    
    // 2. Service에 Mock 주입
    PostService service = new PostService(mockRepo);
    
    // 3. 결과: DB 없이 가짜 데이터로 테스트
}
```

## 핵심 원리

### 생성자로 받은 객체가 필드에 저장됨
```java
public PostService(PostRepository postRepository) {
    this.postRepository = postRepository;  // 이 순간 결정!
}

// 운영: PostService(실제구현체) → 필드에 실제구현체 저장
// 테스트: PostService(Mock객체) → 필드에 Mock객체 저장
```

### 왜 이게 가능한가? → 인터페이스 타입!
```java
// ✅ 인터페이스 타입
private final PostRepository postRepository;
// - 실제 구현체 OK
// - Mock 객체 OK
// - 다른 구현체 OK

// ❌ 구체 클래스 타입
private final PostRepositoryImpl postRepository;
// - Mock을 받을 수 없음 (타입 불일치)
// - 테스트 어려움
```

## 정리
- **생성자 주입**으로 의존성을 외부에서 받음
- **인터페이스 타입**으로 선언해서 유연성 확보
- 운영/테스트에서 다른 구현체를 주입하여 사용

## Spring Data JPA 패턴
```java
// Repository: extends로 상속
public interface PostRepository extends JpaRepository {
    List findByUserId(Long userId);
}

// Service: 인터페이스 타입으로 주입받기
@Service
public class PostService {
    private final PostRepository postRepository;
    
    public PostService(PostRepository postRepository) {
        this.postRepository = postRepository;
    }
}
```
- Spring이 PostRepository 구현체를 자동 생성
- Service는 인터페이스만 의존
- 구현체 변경해도 Service 코드 불변



## 실제 사용 예시

### new 사용 시 (변경 어려움)
```java
// 처음에 JPA 사용
private final PostRepository repo = new JpaPostRepository();

// MongoDB로 바꾸고 싶다?
// → 코드 수정 필요!
private final PostRepository repo = new MongoPostRepository();

// 테스트하고 싶다?
// → 코드 수정 필요!
private final PostRepository repo = new MockPostRepository();
```

### 생성자 주입 시 (변경 쉬움)
```java
// Service 코드는 그대로!
public PostService(PostRepository postRepository) {
    this.postRepository = postRepository;
}

// 운영 환경
PostRepository jpaRepo = new JpaPostRepository();
PostService service = new PostService(jpaRepo);  // JPA 주입

// 테스트 환경
PostRepository mockRepo = mock(PostRepository.class);
PostService service = new PostService(mockRepo);  // Mock 주입

// MongoDB로 변경
PostRepository mongoRepo = new MongoPostRepository();
PostService service = new PostService(mongoRepo);  // MongoDB 주입

// Service 코드는 한 줄도 안 바뀜!
```