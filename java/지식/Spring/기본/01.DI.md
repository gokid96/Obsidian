**강한 결합:**
- 구현체 변경 시 사용하는 쪽 코드 전부 수정 필요 ✅

**느슨한 결합 (DI):**
- Spring이 구현체를 주입해주기 때문에 구현체 변경 시 사용하는 쪽 코드 변경 불필요 ✅
- 테스트 시 Mock 객체 주입 가능 ✅


### **DI 없이 직접 생성하는 경우:** 
```java
public class UserService {
    private UserRepository repo = new MySQLUserRepository(); // new 로 생성할경우 강한 결합으로 구현체 변경이 필요한 경우 해당 구현체를 사용하는곳에서 모두 new ~ 수정 필요
}
```
MySQL에서 PostgreSQL로 바꾸거나, 테스트용 FakeRepository를 쓰고 싶으면 **UserService** 코드 자체 수정 필요

## **DI 사용하는 경우:**
```java
public class UserService {
    private final UserRepository repo;
    
    @Autowired
    public UserService(UserRepository repo) {
        this.repo = repo;
    }
}
```

UserService 코드는 **전혀 건드리지 않고**, Spring 설정에서만 어떤 구현체를 주입할지 결정
```java
@Configuration
public class AppConfig {
    @Bean
    public UserRepository userRepository() {
        // return new MySQLUserRepository(); // 이전
        return new PostgreSQLUserRepository(); // 변경
    }
}
```


**다만 테스트 부분은 조금 다르게:**
```java
// 테스트에서는 Spring이 아니라 "우리가 직접" Mock을 주입
@Test
void testCreateUser() {
    UserRepository mockRepo = mock(UserRepository.class); // Mock 생성
    UserService service = new UserService(mockRepo); // 우리가 직접 주입
    
    // 테스트 진행
}
```
