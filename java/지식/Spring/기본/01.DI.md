**강한 결합:**
- 구현체 변경 시 사용하는 쪽 코드 전부 수정 필요 

**느슨한 결합 (DI):**
- Spring이 구현체를 주입해주기 때문에 구현체 변경 시 사용하는 쪽 코드 변경 불필요 
- 테스트 시 Mock 객체 주입 가능 

```java
@Service
public class PostService {
    private final PostRepository postRepository;  // 필드
    
    // 생성자 주입
    public PostService(PostRepository postRepository) {
        // 여기서 받은 객체가 필드에 저장됨!
        this.postRepository = postRepository;
    }
}
```

## 실제 동작 과정

### 운영 환경 (Spring이 주입)
```java
// Spring이 하는 일:
// 1. PostRepository 구현체 생성
PostRepository realRepo = new SimpleJpaRepository(...);  // Spring이 자동 생성

// 2. Service 생성하면서 주입
PostService service = new PostService(realRepo);

// 3. 결과
// service.postRepository = realRepo (실제 DB 연결됨)
```

### 테스트 환경 (개발자가 Mock 주입)
```java
@Test
void test() {
    // 1. 개발자가 Mock 생성
    PostRepository mockRepo = mock(PostRepository.class);
    when(mockRepo.findByUserId(1L)).thenReturn(fakePosts);
    
    // 2. 개발자가 직접 Service 생성하면서 Mock 주입
    PostService service = new PostService(mockRepo);
    
    // 3. 결과
    // service.postRepository = mockRepo (DB 없이 가짜 데이터)
}
```

## 핵심: 생성자 파라미터로 받은 걸 필드에 저장
```java
public PostService(PostRepository postRepository) {
    this.postRepository = postRepository;  // 이 순간 결정!
    // postRepository 파라미터로 뭐가 들어오든
    // 그게 this.postRepository 필드에 저장됨
}

// 운영: PostService(실제구현체) → 필드에 실제구현체 저장
// 테스트: PostService(Mock객체) → 필드에 Mock객체 저장
```

## 그래서 이게 가능한 이유
```java
// 필드 타입이 인터페이스니까!
private final PostRepository postRepository;

// 인터페이스 타입은 뭐든 받을 수 있음:
// - 실제 구현체 OK
// - Mock 객체 OK
// - 다른 구현체 OK

// 만약 구체 클래스였다면?
private final PostRepositoryImpl postRepository;
// → Mock을 받을 수 없음! (타입이 안 맞음)
```