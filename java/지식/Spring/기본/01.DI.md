DI(Dependency Injection, 의존성 주입)를 사용하는 이유

## 핵심 이유들

**1. 결합도 감소 (Loose Coupling)** 클래스가 직접 의존 객체를 생성하지 않고 외부에서 주입받으면, 구체적인 구현체가 아닌 인터페이스에 의존 이렇게 하면 나중에 구현체를 바꿔도 코드 수정이 최소화
```java
// DI 없이 - 강한 결합
public class UserService {
    private UserRepository repo = new MySQLUserRepository(); // 직접 생성
}

// DI 사용 - 느슨한 결합
public class UserService {
    private final UserRepository repo;
    
    @Autowired
    public UserService(UserRepository repo) { // 주입받음
        this.repo = repo;
    }
}
```

**2. 테스트 용이성** 실제 DB나 외부 API 대신 Mock 객체를 주입해서 단위 테스트를 쉽게 작성

```java
@Test
void testCreateUser() {
    UserRepository mockRepo = mock(UserRepository.class);
    UserService service = new UserService(mockRepo);
    // 테스트 진행
}
```

**3. 코드 재사용성과 유연성** 같은 Service를 다른 Repository 구현체와 조합해서 사용, 예를 들어 개발 환경에서는 H2, 운영에서는 MySQL을 사용

**4. 관심사의 분리 (Separation of Concerns)** 객체 생성과 사용의 책임이 분리돼. Spring Container가 객체 생성과 생명주기를 관리하고, 비즈니스 로직은 순수하게 자기 역할에만 집중

**5. AOP 적용 가능** Spring이 관리하는 Bean이어야 트랜잭션, 로깅, 보안 같은 횡단 관심사를 적용할 수 있어. @Transactional`도 DI를 통해 프록시 방식으로 동작하는 거야.