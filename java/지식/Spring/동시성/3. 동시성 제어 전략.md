## 동시성 제어의 필요성

동시성 제어는 여러 트랜잭션이 동시에 데이터베이스에 접근할 때 데이터의 일관성과 무결성을 보장하기 위한 핵심 메커니즘

### 주요 목적

- 데이터 정합성 유지
- 동시 접근으로 인한 데이터 충돌 방지
- 시스템의 안정성 확보

## 동시성 문제의 유형

### 1. 레이스 컨디션 (Race Condition)

- 여러 트랜잭션이 동시에 같은 데이터에 접근
- 실행 순서에 따라 결과가 달라지는 현상

### 2. 더티 리드 (Dirty Read)

- 다른 트랜잭션이 커밋되지 않은 데이터 읽기
- 잘못된 데이터 참조 위험

### 3. 논-리피터블 리드 (Non-Repeatable Read)

- 같은 트랜잭션 내에서 반복 조회 시 데이터 불일치

### 4. 팬텀 리드 (Phantom Read)

- 트랜잭션 실행 중 새로운 레코드 추가/삭제

## 동시성 제어 전략

### 1. 낙관적 동시성 제어 (Optimistic Concurrency Control)

```java
@Entity
public class Product {
    @Id
    private Long id;
    
    @Version
    private Long version;
    
    private BigDecimal price;
}

@Service
public class ProductService {
    @Transactional
    public void updatePrice(Long productId, BigDecimal newPrice) {
        Product product = entityManager.find(Product.class, productId);
        
        try {
            product.setPrice(newPrice);
            // 버전 자동 증가, 동시성 충돌 시 예외 발생
        } catch (OptimisticLockException e) {
            // 충돌 처리 로직
            throw new ConcurrentModificationException("가격 업데이트 실패");
        }
    }
}
```

### 2. 비관적 동시성 제어 (Pessimistic Concurrency Control)

```java
@Service
public class StockService {
    @PersistenceContext
    private EntityManager entityManager;

    @Transactional
    public void decreaseStock(Long productId, int quantity) {
        // 배타적 락으로 동시성 제어
        Product product = entityManager.find(
            Product.class, 
            productId, 
            LockModeType.PESSIMISTIC_WRITE
        );

        if (product.getStockQuantity() >= quantity) {
            product.decreaseStock(quantity);
        } else {
            throw new InsufficientStockException("재고 부족");
        }
    }
}
```

### 3. 세마포어 기반 동시성 제어

```java
@Service
public class ConcurrentResourceService {
    private final Semaphore semaphore;

    public ConcurrentResourceService() {
        // 동시 접근 제한 (예: 최대 5개 동시 접근)
        this.semaphore = new Semaphore(5);
    }

    public void accessResource() throws InterruptedException {
        try {
            // 리소스 접근 전 세마포어 획득
            semaphore.acquire();
            
            // 리소스 처리 로직
            processResource();
        } finally {
            // 리소스 해제
            semaphore.release();
        }
    }
}
```

## 복합 동시성 제어 전략

### 하이브리드 접근

```java
@Service
public class AdvancedConcurrencyService {
    @Transactional
    public void complexOperation(Long resourceId) {
        // 1. 비관적 락으로 초기 동시성 제어
        Resource resource = entityManager.find(
            Resource.class, 
            resourceId, 
            LockModeType.PESSIMISTIC_WRITE
        );

        try {
            // 2. 낙관적 락으로 추가 검증
            if (resource.getVersion() != expectedVersion) {
                throw new ConcurrentModificationException("버전 불일치");
            }

            // 실제 비즈니스 로직 수행
            resource.performAction();
        } catch (OptimisticLockException e) {
            // 충돌 처리 로직
            handleConcurrencyConflict(resource);
        }
    }
}
```

## 동시성 제어 선택 기준

### 워크로드 분석

- 읽기 작업 빈도
- 쓰기 작업 빈도
- 데이터 충돌 가능성

### 성능 고려사항

- 낙관적 동시성 제어: 충돌 빈도 낮은 경우
- 비관적 동시성 제어: 충돌 가능성 높은 경우

## 분산 시스템에서의 동시성 제어

### 분산 락 메커니즘

```java
@Service
public class DistributedConcurrencyService {
    private final DistributedLockManager lockManager;

    public void performDistributedOperation(String resourceKey) {
        try {
            // 분산 락 획득
            if (lockManager.acquireLock(resourceKey, 5, TimeUnit.SECONDS)) {
                try {
                    // 분산 환경에서 안전한 작업 수행
                    performCriticalOperation();
                } finally {
                    // 락 해제
                    lockManager.releaseLock(resourceKey);
                }
            } else {
                throw new ConcurrentModificationException("락 획득 실패");
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RuntimeException("락 획득 중 인터럽트 발생");
        }
    }
}
```

## 주의사항

### 성능 트레이드오프

- 동시성 제어 메커니즘은 항상 성능에 영향
- 과도한 동시성 제어는 시스템 성능 저하 가능

### 선택 시 고려사항

- 비즈니스 요구사항
- 데이터 일관성 수준
- 예상되는 동시 접근 패턴
- 시스템 리소스 제약

## 결론

효과적인 동시성 제어는 데이터 일관성과 시스템 성능 사이의 섬세한 균형입니다. 시스템의 특성을 깊이 이해하고, 상황에 맞는 최적의 전략을 선택하는 것이 핵심입니다.