
## 1. OOP 4대 특성

**Q: 객체지향 프로그래밍의 4대 특성에 대해 설명해주세요.**

**A:** 객체지향의 4대 특성은 캡슐화, 상속, 다형성, 추상화입니다.

**캡슐화**는 데이터와 메서드를 하나로 묶고 외부에서 직접 접근하지 못하도록 은닉하는 것입니다. private 변수와 public getter/setter를 통해 구현하며, 이를 통해 데이터 보호와 유지보수성을 높일 수 있습니다.

**상속**은 부모 클래스의 속성과 메서드를 자식 클래스가 물려받아 재사용하는 것입니다. 코드 재사용성을 높이고 계층 구조를 표현할 수 있습니다.

**다형성**은 같은 인터페이스나 부모 타입으로 여러 구현체를 다룰 수 있는 특성입니다. 오버로딩과 오버라이딩으로 구현되며, 유연하고 확장 가능한 코드 작성이 가능합니다.

**추상화**는 복잡한 내부 구현을 숨기고 필요한 기능만 외부에 제공하는 것입니다. 인터페이스와 추상 클래스를 통해 구현하며, 설계의 유연성을 높입니다.

---
## 2. JVM 구조

**Q: JVM의 구조와 동작 원리에 대해 설명해주세요.**

**A:** JVM은 크게 Class Loader, Runtime Data Area, Execution Engine으로 구성됩니다.

**Class Loader**는 .class 파일을 메모리로 로드하는 역할을 합니다. Loading, Linking, Initialization 단계를 거쳐 클래스를 메모리에 적재합니다.

**Runtime Data Area**는 실제 데이터가 저장되는 메모리 영역으로, Method Area, Heap, Stack, PC Register, Native Method Stack으로 나뉩니다. Method Area는 클래스 정보와 static 변수를 저장하고, Heap은 new로 생성된 객체를 저장하며 GC가 관리합니다. Stack은 지역변수와 메서드 호출 정보를 저장하며 각 스레드마다 독립적으로 존재합니다.

**Execution Engine**은 바이트코드를 실행하는 엔진으로, Interpreter와 JIT Compiler, Garbage Collector로 구성됩니다. Interpreter는 바이트코드를 한 줄씩 해석하고, JIT Compiler는 자주 실행되는 코드를 네이티브 코드로 컴파일하여 성능을 향상시킵니다.

이러한 구조 덕분에 Java는 플랫폼 독립적이며 자동 메모리 관리가 가능합니다.

---
## 3. Collection Framework ⭐⭐⭐

**Q: Java의 Collection Framework에 대해 설명해주세요.**

**A:** Collection Framework는 데이터를 효율적으로 관리하기 위한 자료구조 모음으로, 크게 List, Set, Map으로 나뉩니다.

**List**는 순서가 있고 중복을 허용하는 자료구조입니다. ArrayList는 배열 기반으로 인덱스 조회가 빠르지만 중간 삽입/삭제는 느립니다. LinkedList는 노드 기반으로 삽입/삭제가 빠르지만 조회는 느립니다.

**Set**은 순서가 없고 중복을 허용하지 않는 자료구조입니다. HashSet은 해시 테이블 기반으로 빠른 검색이 가능하고, TreeSet은 정렬된 상태를 유지합니다.

**Map**은 key-value 쌍으로 데이터를 저장하며 key는 중복될 수 없습니다. HashMap은 해시 테이블 기반으로 빠른 검색이 가능하고, TreeMap은 key를 기준으로 정렬된 상태를 유지합니다.

사용 목적에 따라 적절한 자료구조를 선택하는 것이 중요하며, 조회가 많으면 ArrayList나 HashMap을, 삽입/삭제가 많으면 LinkedList를 사용하는 것이 효율적입니다.

---
## 4. String/StringBuilder/StringBuffer ⭐⭐

**Q: String, StringBuilder, StringBuffer의 차이점을 설명해주세요.**

**A:** 세 클래스는 문자열을 다루는 방식과 성능, 동기화 측면에서 차이가 있습니다.

**String**은 불변(immutable) 객체로, 한 번 생성되면 값을 변경할 수 없습니다. 문자열을 수정하면 새로운 객체가 생성되기 때문에 문자열 연산이 많을 경우 메모리 낭비가 발생할 수 있습니다. 하지만 불변이기 때문에 thread-safe하고 String Pool을 통해 메모리를 효율적으로 관리할 수 있습니다.

**StringBuilder**는 가변(mutable) 객체로, 동일한 객체 내에서 문자열을 수정할 수 있습니다. 동기화를 지원하지 않아 단일 스레드 환경에서 가장 빠른 성능을 보입니다.

**StringBuffer**는 StringBuilder와 동일하게 가변 객체이지만, 동기화를 지원하여 멀티 스레드 환경에서 thread-safe합니다. 다만 동기화로 인해 StringBuilder보다는 성능이 느립니다.

따라서 문자열 변경이 없으면 String을, 단일 스레드 환경에서 문자열 조작이 많으면 StringBuilder를, 멀티 스레드 환경에서는 StringBuffer를 사용하는 것이 적절합니다.

---

## 5. ==와 equals() ⭐⭐

**Q: ==와 equals()의 차이점을 설명해주세요.**

**A:** ==와 equals()는 비교하는 대상이 다릅니다.

**==** 연산자는 참조 주소를 비교합니다. 기본 타입(primitive type)에서는 실제 값을 비교하지만, 참조 타입(reference type)에서는 객체가 저장된 메모리 주소를 비교합니다.

**equals()** 메서드는 객체의 내용(값)을 비교합니다. Object 클래스의 기본 equals()는 ==와 동일하게 주소를 비교하지만, String이나 Integer 같은 클래스에서는 equals()를 오버라이딩하여 실제 값을 비교하도록 구현되어 있습니다.

예를 들어, new String("Hello")로 생성한 두 객체는 ==로 비교하면 false이지만 equals()로 비교하면 true입니다. 이는 ==는 서로 다른 메모리 주소를 가리키기 때문이고, equals()는 문자열의 내용이 같기 때문입니다.

따라서 기본 타입은 ==로, 객체의 내용 비교가 필요할 때는 equals()를 사용해야 하며, 커스텀 클래스에서는 필요에 따라 equals()를 오버라이딩하는 것이 좋습니다.

---


## 6. IoC/DI 개념 ⭐⭐⭐

**Q: IoC(Inversion of Control)와 DI(Dependency Injection)에 대해 설명해주세요.**

**A:** IoC와 DI는 Spring Framework의 핵심 개념입니다.

**IoC(제어의 역전)**는 객체의 생성과 생명주기 관리를 개발자가 아닌 프레임워크가 담당하는 것을 의미합니다. 기존에는 개발자가 직접 new 키워드로 객체를 생성하고 관리했지만, IoC 컨테이너가 이를 대신 처리하여 객체 간의 결합도를 낮추고 유연성을 높입니다.

**DI(의존성 주입)**는 IoC를 구현하는 방법 중 하나로, 객체가 필요로 하는 의존성을 외부에서 주입받는 방식입니다. 생성자 주입, 필드 주입, 세터 주입 세 가지 방식이 있으며, 이 중 생성자 주입이 권장됩니다. 생성자 주입은 객체 생성 시점에 필수 의존성을 보장하고, 불변성을 유지하며, 테스트가 용이하기 때문입니다.

이러한 방식을 통해 객체 간의 결합도가 낮아지고, 코드의 재사용성과 테스트 용이성이 향상되며, 변경에 유연한 구조를 만들 수 있습니다.

---

## 7. REST API 설계 ⭐⭐

**Q: RESTful API 설계 원칙에 대해 설명해주세요.**

**A:** REST는 Representational State Transfer의 약자로, 자원을 URI로 표현하고 HTTP 메서드로 행위를 정의하는 아키텍처 스타일입니다.

**주요 원칙**으로는 첫째, 자원은 명사로 표현하고 URI에 동사를 사용하지 않습니다. 예를 들어 /getUsers가 아닌 /users를 사용합니다. 둘째, HTTP 메서드로 행위를 표현합니다. GET은 조회, POST는 생성, PUT은 전체 수정, PATCH는 부분 수정, DELETE는 삭제에 사용합니다.

셋째, 계층 구조를 URI로 표현합니다. /users/{userId}/orders처럼 관계를 명확히 나타냅니다. 넷째, 적절한 HTTP 상태 코드를 반환합니다. 200은 성공, 201은 생성 성공, 400은 잘못된 요청, 404는 리소스 없음, 500은 서버 오류를 의미합니다.

다섯째, 무상태성(Stateless)을 유지하여 각 요청은 독립적이어야 하며, 서버는 클라이언트의 상태를 저장하지 않습니다.

이러한 원칙을 따르면 직관적이고 확장 가능하며 유지보수가 쉬운 API를 설계할 수 있습니다.

---

## 8. JPA 기본 ⭐⭐

**Q: JPA가 무엇이고, 왜 사용하나요?**

**A:** JPA(Java Persistence API)는 Java에서 ORM(Object-Relational Mapping)을 위한 표준 인터페이스입니다.

**ORM**은 객체와 관계형 데이터베이스의 테이블을 매핑하여, SQL을 직접 작성하지 않고도 데이터베이스 작업을 수행할 수 있게 해줍니다. 이를 통해 개발자는 비즈니스 로직에 집중할 수 있고, 데이터베이스 종속성이 낮아집니다.

**JPA의 주요 특징**으로는 첫째, 영속성 컨텍스트를 통한 1차 캐시와 변경 감지 기능으로 성능을 최적화합니다. 둘째, 지연 로딩과 즉시 로딩을 통해 연관 관계 데이터를 효율적으로 조회할 수 있습니다. 셋째, JPQL이나 Criteria API를 통해 객체 지향적인 쿼리 작성이 가능합니다.

**사용하는 이유**는 SQL 반복 작업을 줄이고, 객체 중심 개발이 가능하며, 데이터베이스 변경 시 코드 수정이 최소화되기 때문입니다. 다만 복잡한 쿼리나 성능 최적화가 필요한 경우에는 Native Query나 JDBC를 함께 사용하는 것이 좋습니다.

대표적인 구현체로는 Hibernate가 있으며, Spring Data JPA를 통해 더욱 편리하게 사용할 수 있습니다.

## 9. Abstract 클래스와 Interface의 차이

**Q: Abstract 클래스와 Interface의 차이점을 설명해주세요.**

**A:** Abstract 클래스와 Interface는 추상화를 구현하는 방법이지만, 목적과 사용 방식에서 차이가 있습니다.

**Abstract 클래스**는 공통된 기능을 가진 클래스들의 공통 부분을 추상화한 것입니다. 일반 메서드와 추상 메서드를 모두 가질 수 있으며, 필드(변수)와 생성자도 선언할 수 있습니다. 단일 상속만 가능하며, "is-a" 관계를 나타냅니다. 예를 들어 Animal 추상 클래스를 Dog, Cat이 상속받는 경우, "Dog는 Animal이다"라는 관계가 성립합니다.

**Interface**는 구현체들이 반드시 구현해야 할 기능의 명세를 정의한 것입니다. Java 8 이전에는 추상 메서드만 가질 수 있었지만, Java 8 이후로는 default 메서드와 static 메서드도 가질 수 있습니다. 다중 구현이 가능하며, "can-do" 관계를 나타냅니다. 예를 들어 Flyable 인터페이스를 구현하면 "날 수 있다"는 기능을 가지게 됩니다.

**선택 기준**으로는, 공통된 기능 구현이 필요하고 관련된 클래스들 간의 상속 관계를 표현할 때는 Abstract 클래스를, 서로 관련 없는 클래스들이 공통 기능만 구현하면 될 때는 Interface를 사용합니다. 예를 들어 Bird와 Airplane은 상속 관계가 아니지만 둘 다 Flyable 인터페이스를 구현할 수 있습니다.