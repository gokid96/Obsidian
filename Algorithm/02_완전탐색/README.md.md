# 완전탐색 (Brute Force)

## 완전탐색이란?

**모든 경우의 수를 다 해보는 것.** 가장 단순하지만 확실한 방법이다.

---

## 핵심 아이디어

1. 가능한 모든 경우를 나열한다
2. 각 경우에 대해 조건을 확인한다
3. 조건을 만족하는 답을 찾는다

---

## 언제 완전탐색을 써야 하는가?

### 사용 가능한 경우

- 경우의 수가 **100만 이하**일 때
- 문제에서 "모든", "가능한", "경우의 수" 같은 키워드가 있을 때
- 더 효율적인 알고리즘이 떠오르지 않을 때

### 시간복잡도 체크

``` 
#경우의 수 
n = 10   → 10! = 3,628,800 (가능)
n = 100  → 100² = 10,000 (가능)
n = 1000 → 1000³ = 10억 (불가능)
```

---

## 구현 방법

### 1. 단일 반복문

```java
// 1부터 n까지 중 조건을 만족하는 수 찾기
for (int i = 1; i <= n; i++) {
    if (조건) {
        // 답 처리
    }
}
```

### 2. 이중 반복문

```java
// 두 수의 조합 탐색
for (int i = 0; i < n; i++) {
    for (int j = i + 1; j < n; j++) {
        // arr[i]와 arr[j] 조합 확인
    }
}
```

### 3. 삼중 반복문

```java
// 세 수의 조합 탐색
for (int i = 0; i < n; i++) {
    for (int j = i + 1; j < n; j++) {
        for (int k = j + 1; k < n; k++) {
            // arr[i], arr[j], arr[k] 조합 확인
        }
    }
}
```

---

## 완전탐색 유형

|유형|설명|시간복잡도|
|---|---|---|
|선형 탐색|하나씩 확인|O(n)|
|이중 반복|두 개 조합|O(n²)|
|삼중 반복|세 개 조합|O(n³)|
|순열|순서 있는 나열|O(n!)|
|조합|순서 없는 선택|O(2ⁿ)|

---

## 문제 접근법

1. **입력 크기 확인** → 완전탐색 가능한지 판단
2. **경우의 수 정의** → 뭘 다 해볼 건지 명확히
3. **반복문 설계** → 모든 경우를 빠짐없이 탐색
4. **조건 확인** → 각 경우에서 정답 조건 체크

---

## 자주 하는 실수

- **중복 탐색**: j = 0이 아니라 j = i + 1부터 시작
- **범위 누락**: 경계값(0, n-1) 포함 여부 확인
- **조기 종료**: 답을 찾으면 break로 탈출

---

## 정리

> 💡 "일단 다 해보자" = 완전탐색 💡 n이 작으면 완전탐색부터 시도 💡 시간초과 나면 그때 최적화 고민