# 완전탐색 (Brute Force)

## 완전탐색이란?

**모든 경우의 수를 다 해보는 것.** 가장 단순하지만 확실한 방법이다.

---

## 핵심 아이디어

1. 가능한 모든 경우를 나열한다
2. 각 경우에 대해 조건을 확인한다
3. 조건을 만족하는 답을 찾는다

---

## 언제 완전탐색을 써야 하는가?

### 사용 가능한 경우

- 경우의 수가 **1억 이하**일 때 (1초 기준)
- 문제에서 "모든", "가능한", "경우의 수" 같은 키워드가 있을 때
- 더 효율적인 알고리즘이 떠오르지 않을 때

### 시간복잡도 판단 기준

**1초에 약 1억 번 연산이 가능하다**고 가정한다.

| n의 크기       | 사용 가능한 최대 시간복잡도 | 연산 횟수             |
| ----------- | --------------- | ----------------- |
| n ≤ 10      | O(n!)           | 10! = 3,628,800 ✅ |
| n ≤ 20      | O(2ⁿ)           | 2²⁰ = 1,048,576 ✅ |
| n ≤ 500     | O(n³)           | 500³ = 1.25억 ⚠️   |
| n ≤ 5,000   | O(n²)           | 5,000² = 2,500만 ✅ |
| n ≤ 100,000 | O(n log n)      | 약 170만 ✅          |

### 실전 예시

```
문제: n개 중 3개를 뽑아 합이 K인 경우를 찾아라
제약조건 확인: 
(1 ≤ n ≤ 100) → n³ = 100만 → O(n³) 가능   ✅ 
(1 ≤ n ≤ 1,000) → n³ = 10억 → O(n³) 불가능 ❌ 
(1 ≤ n ≤ 10,000) → n² = 1억 → O(n²) 경계선 ⚠️
```

### 제약조건 읽는 법

|제약조건 표기|의미|확인할 것|
|---|---|---|
|1 ≤ n ≤ 100|n은 최대 100|**n 기준으로 시간복잡도 계산**|
|1 ≤ V ≤ 10⁹|V는 최대 10억|값의 범위 (개수 아님)|

---

## 구현 방법

### 1. 단일 반복문 - O(n)
```java
// 1부터 n까지 중 조건을 만족하는 수 찾기
for (int i = 1; i <= n; i++) {
    if (조건) {
        // 답 처리
    }
}
```

### 2. 이중 반복문 - O(n²)

```java
// 두 수의 조합 탐색
for (int i = 0; i < n; i++) {
    for (int j = i + 1; j < n; j++) {
        // arr[i]와 arr[j] 조합 확인
    }
}
```

### 3. 삼중 반복문 - O(n³)
```java
// 세 수의 조합 탐색
for (int i = 0; i < n; i++) {
    for (int j = i + 1; j < n; j++) {
        for (int k = j + 1; k < n; k++) {
            // arr[i], arr[j], arr[k] 조합 확인
        }
    }
}
```

---

## 완전탐색 유형

|유형|설명|시간복잡도|n 한계|
|---|---|---|---|
|선형 탐색|하나씩 확인|O(n)|10⁸|
|이중 반복|두 개 조합|O(n²)|10⁴|
|삼중 반복|세 개 조합|O(n³)|500|
|부분집합|포함/미포함|O(2ⁿ)|20|
|순열|순서 있는 나열|O(n!)|10|

---

## 문제 접근법

1. **입력 크기 확인** → 완전탐색 가능한지 판단
2. **경우의 수 정의** → 뭘 다 해볼 건지 명확히
3. **반복문 설계** → 모든 경우를 빠짐없이 탐색
4. **조건 확인** → 각 경우에서 정답 조건 체크

---

## 자주 하는 실수

- **중복 탐색**: j = 0이 아니라 j = i + 1부터 시작
- **범위 누락**: 경계값(0, n-1) 포함 여부 확인
- **조기 종료**: 답을 찾으면 break로 탈출

---

## 정리

> 💡 "일단 다 해보자" = 완전탐색  
> 💡 n이 작으면 완전탐색부터 시도  
> 💡 시간초과 나면 그때 최적화 고민