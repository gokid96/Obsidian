# 시간복잡도 (Time Complexity)

## 시간복잡도란?

알고리즘이 입력 크기(n)에 따라 얼마나 오래 걸리는지 나타내는 척도. 실제 시간(초)이 아니라 **연산 횟수의 증가율**로 표현한다.

---

## 빅오 표기법 (Big-O Notation)

| 표기         | 이름    | 예시             | 설명             |
| ---------- | ----- | -------------- | -------------- |
| O(1)       | 상수    | 배열 인덱스 접근      | 입력 크기와 무관하게 일정 |
| O(log n)   | 로그    | 이분탐색           | 반씩 줄어듦         |
| O(n)       | 선형    | 단일 반복문         | 입력에 비례         |
| O(n log n) | 선형 로그 | 정렬 (퀵소트, 머지소트) | 효율적인 정렬        |
| O(n²)      | 제곱    | 이중 반복문         | 입력의 제곱에 비례     |
| O(2ⁿ)      | 지수    | 피보나치 재귀        | 매우 느림          |

---

## 시간복잡도 계산하는 법

### 기본 규칙

1. **반복문 1개** → O(n)
2. **중첩 반복문** → O(n²), O(n³), ...
3. **반복문이 반씩 줄어듦** → O(log n)
4. **상수는 무시** → O(2n) = O(n)
5. **낮은 차수는 무시** → O(n² + n) = O(n²)

### 예시

```java
// O(1) - 상수
int x = arr[0];

// O(n) - 단일 반복문
for (int i = 0; i < n; i++) {
    // ...
}

// O(n²) - 이중 반복문
for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
        // ...
    }
}

// O(log n) - 반씩 줄어듦
while (n > 0) {
    n = n / 2;
}
```

---

## 입력 크기별 허용 시간복잡도

코딩테스트는 보통 **1초에 1억 번 연산**을 기준으로 한다.

|입력 크기 (n)|허용 시간복잡도|연산 횟수|
|---|---|---|
|n ≤ 10|O(n!)|3,628,800|
|n ≤ 20|O(2ⁿ)|1,048,576|
|n ≤ 500|O(n³)|125,000,000|
|n ≤ 2,000|O(n²)|4,000,000|
|n ≤ 100,000|O(n log n)|1,660,964|
|n ≤ 10,000,000|O(n)|10,000,000|

### 실전 팁

- n = 1,000 → O(n²) 가능
- n = 10,000 → O(n²) 위험, O(n log n) 권장
- n = 100,000 → O(n log n) 이하만 가능
- n = 1,000,000 → O(n) 이하만 가능

---

## 공간복잡도 기초

알고리즘이 사용하는 **메모리 양**을 나타낸다.

```java
// O(1) - 변수 몇 개만 사용
int sum = 0;

// O(n) - 크기 n인 배열
int[] arr = new int[n];

// O(n²) - 2차원 배열
int[][] matrix = new int[n][n];
```

### 메모리 제한

- 보통 256MB ~ 512MB
- int 배열 1억 개 ≈ 400MB
- 대부분의 문제에서 O(n) 공간이면 충분

---

## 정리

1. **문제를 보면 먼저 입력 크기(n) 확인**
2. **n에 맞는 시간복잡도 선택**
3. **그 시간복잡도 안에서 풀이법 설계**

> 💡 시간초과 나면 → 더 빠른 알고리즘 필요 💡 메모리초과 나면 → 더 적은 공간 필요