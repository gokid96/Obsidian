# 시간복잡도 (Time Complexity)

## 시간복잡도란?

알고리즘이 입력 크기(n)에 따라 얼마나 오래 걸리는지 나타내는 척도. 실제 시간(초)이 아니라 **연산 횟수의 증가율**로 표현한다.

---

## 빅오 표기법 (Big-O Notation)

**"입력이 커질 때 연산 횟수가 어떻게 증가하는가?"**를 나타낸다.

| 표기         | 이름    | 예시             | 의미                 |
| ---------- | ----- | -------------- | ------------------ |
| O(1)       | 상수    | 배열 인덱스 접근      | n이 커져도 항상 일정       |
| O(log n)   | 로그    | 이분탐색           | n이 2배 되면 1번만 더 연산  |
| O(n)       | 선형    | 단일 반복문         | n에 비례해서 증가         |
| O(n log n) | 선형 로그 | 정렬 (퀵소트, 머지소트) | 효율적인 정렬의 한계        |
| O(n²)      | 제곱    | 이중 반복문         | n이 10배 되면 100배 느려짐 |
| O(2ⁿ)      | 지수    | 부분집합 탐색        | n이 1 증가할 때마다 2배    |
| O(n!)      | 팩토리얼  | 순열 탐색          | 매우 빠르게 폭발          |

### 증가율 비교 (n = 20 기준)

```
O(1)       = 1
O(log n)   = 4
O(n)       = 20
O(n log n) = 86
O(n²)      = 400
O(2ⁿ)      = 1,048,576
O(n!)      = 2,432,902,008,176,640,000 (불가능)
```

---

## 시간복잡도 계산하는 법

### 기본 규칙

1. **반복문 1개** → O(n)
2. **중첩 반복문** → O(n²), O(n³), ...
3. **반복문이 반씩 줄어듦** → O(log n)
4. **상수는 무시** → O(2n) = O(n)
5. **낮은 차수는 무시** → O(n² + n) = O(n²)

### 예시
```java
// O(1) - 상수: 반복 없이 바로 접근
int x = arr[0];

// O(n) - 선형: n번 반복
for (int i = 0; i < n; i++) {
    // ...
}

// O(n²) - 제곱: n × n번 반복
for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
        // ...
    }
}

// O(log n) - 로그: 반씩 줄어듦
while (n > 0) {
    n = n / 2;  // 매번 절반으로
}
```

### 복합 케이스

```java
// O(n) + O(n) = O(n) - 순차 실행은 더 큰 것만
for (int i = 0; i < n; i++) { }
for (int j = 0; j < n; j++) { }

// O(n) × O(m) = O(nm) - 중첩은 곱하기
for (int i = 0; i < n; i++) {
    for (int j = 0; j < m; j++) { }
}
```

---

## 입력 크기별 허용 시간복잡도

코딩테스트는 보통 **1초에 1억 번 연산**을 기준으로 한다.

### 판단 기준표

| n의 크기          | 사용 가능한 최대 시간복잡도 | 연산 횟수       | 대표 알고리즘   |
| -------------- | --------------- | ----------- | --------- |
| n ≤ 10         | O(n!)           | 3,628,800   | 순열 완전탐색   |
| n ≤ 20         | O(2ⁿ)           | 1,048,576   | 부분집합 탐색   |
| n ≤ 500        | O(n³)           | 125,000,000 | 플로이드-워셜   |
| n ≤ 5,000      | O(n²)           | 25,000,000  | 버블/선택 정렬  |
| n ≤ 100,000    | O(n log n)      | 1,700,000   | 퀵소트, 머지소트 |
| n ≤ 10,000,000 | O(n)            | 10,000,000  | 단일 순회     |

### 실전 사고 흐름

```
문제를 읽는다
    ↓
입력 크기 n 확인
    ↓
허용 시간복잡도 파악
    ↓
그 안에서 알고리즘 선택

예시:
- n = 1,000 → O(n²) = 100만 ✅ 이중 반복문 가능
- n = 10,000 → O(n²) = 1억 ⚠️ 위험, O(n log n) 권장
- n = 100,000 → O(n²) = 100억 ❌ 불가능, O(n log n) 필수
```

---

## 공간복잡도 기초

알고리즘이 사용하는 **메모리 양**을 나타낸다.

java

```java
// O(1) - 변수 몇 개만 사용
int sum = 0;
int count = 0;

// O(n) - 크기 n인 배열
int[] arr = new int[n];

// O(n²) - 2차원 배열
int[][] matrix = new int[n][n];
```

### 메모리 제한 계산

- 보통 256MB ~ 512MB 제한
- int 1개 = 4바이트
- int 배열 1억 개 = 4억 바이트 ≈ 400MB
- **대부분의 문제에서 O(n) 공간이면 충분**

---

## 정리

### 문제 풀이 순서

1. **입력 크기(n) 확인** → 제한 시간 내 가능한 시간복잡도 파악
2. **알고리즘 선택** → 해당 시간복잡도에 맞는 방법
3. **구현** → 예상 시간복잡도대로 작성되었는지 확인

> 💡 시간초과 → 더 빠른 알고리즘 필요  
> 💡 메모리초과 → 더 적은 공간 필요  
> 💡 **먼저 n을 보고 시간복잡도 한계를 파악하는 습관**이 중요

## 실제 문제 접근 순서

**1단계: 문제 이해**
- 입력이 뭐고 출력이 뭔지
- 예제 직접 손으로 풀어보기

**2단계: 문제 유형 파악**
- 이게 탐색? 정렬? DP? 그래프? 수학?
- 비슷하게 풀어본 문제 있나?

**3단계: 시간복잡도 제한 확인**
- n 크기 보고 어떤 복잡도까지 가능한지

**4단계: 알고리즘 선택 및 구현**

|시간복잡도|n이 얼마면 1억 되나?|
|---|---|
|O(n²)|√1억 ≈ 10,000|
|O(n log n)|약 500만~1000만|
|O(n)|1억 그대로|
|O(2ⁿ)|log₂(1억) ≈ 27|
