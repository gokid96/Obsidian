## 시간복잡도

### 빅오 표기법

| 표기         | 이름   | 예시             |
| ---------- | ---- | -------------- |
| O(1)       | 상수   | 배열 인덱스 접근      |
| O(log n)   | 로그   | 이분탐색           |
| O(n)       | 선형   | 단일 반복문         |
| O(n log n) | 선형로그 | 정렬 (퀵소트, 머지소트) |
| O(n²)      | 제곱   | 이중 반복문         |
| O(2ⁿ)      | 지수   | 부분집합 탐색        |
| O(n!)      | 팩토리얼 | 순열 탐색          |

---

### 코드 패턴 → 복잡도

```java
// O(1) - 바로 접근
int x = arr[0];

// O(n) - 반복문 1개
for (int i = 0; i < n; i++) { }

// O(n²) - 중첩 반복문
for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) { }
}

// O(log n) - 반씩 줄어듦
while (n > 0) {
    n = n / 2;
}
```


**복합 케이스:**
- 순차 실행: O(n) + O(n) = O(n) → 큰 것만 남김
- 중첩 실행: O(n) × O(m) = O(nm) → 곱하기

---

### 계산 규칙

1. 상수는 무시 → O(2n) = O(n)
2. 낮은 차수 무시 → O(n² + n) = O(n²)
3. 반복문 개수와 중첩이 핵심

---

### N 크기별 허용 복잡도

**기준: 1초 = 1억 번 연산**

| N 크기          | 최대 복잡도     | 대표 알고리즘   |
| ------------- | ---------- | --------- |
| n≤ 10         | O(n!)      | 순열 완전탐색   |
| n≤ 20         | O(2ⁿ)      | 부분집합 탐색   |
| n≤ 500        | O(n³)      | 플로이드-워셜   |
| n≤ 5,000      | O(n²)      | 버블/선택 정렬  |
| n≤ 100,000    | O(n log n) | 퀵소트, 머지소트 |
| n≤ 10,000,000 | O(n)       | 단일 순회     |

---

### 실전 사고 흐름
```
문제 읽기 → N 확인 → 허용 복잡도 파악 → 알고리즘 선택
````

**예시:**

- N = 1,000 → O(n²) = 100만 ✅
- N = 10,000 → O(n²) = 1억 ⚠️ 경계선
- N = 100,000 → O(n²) = 100억 ❌ → O(n log n) 필수

---

### 공간복잡도
```java
int sum = 0;              // O(1)
int[] arr = new int[n];   // O(n)
int[][] matrix = new int[n][n];  // O(n²)
```

- 보통 256MB ~ 512MB 제한
- int 배열 1억 개 ≈ 400MB
- 대부분 O(n) 공간이면 충분
