# 수학 (Mathematics)

## 수학 문제란?

**반복문 대신 수학 공식으로 O(1) 또는 O(log n)에 답을 구하는 문제.** 시간복잡도 제한이 빡빡하거나, 규칙을 찾아 공식화해야 할 때 필요하다.

---

## 핵심 아이디어

1. 패턴이나 규칙을 찾는다
2. 수학 공식으로 일반화한다
3. 반복 없이 바로 계산한다

---

## 언제 수학적 접근이 필요한가?

### 필수인 경우

- n이 **10억 이상**인데 시간 제한이 짧을 때
- 반복문으로 시뮬레이션하면 시간초과가 명확할 때
- 문제에서 규칙성이 보일 때

### 판단 기준

|n의 크기|반복문 가능?|필요한 접근|
|---|---|---|
|n ≤ 1000만|O(n) 가능|반복문 OK|
|n ≤ 10억|O(n) 불가|수학 공식 필요|
|n ≤ 10^18|O(log n)만 가능|수학 + 분할정복|

### 실전 예시

```
문제: 달팽이가 V미터 올라가는 데 며칠?
제약조건: V ≤ 1,000,000,000 (10억)
시간제한: 0.25초

분석:
- 하루하루 시뮬레이션 → O(n) → 10억 번 → 10초 → ❌
- 수학 공식으로 계산 → O(1) → 1번 → ✅
```

---

## 자주 나오는 유형

### 1. 등차수열의 합

java

```java
// 1 + 2 + 3 + ... + n
long sum = (long) n * (n + 1) / 2;

// a부터 b까지의 합
long sum = (long) (a + b) * (b - a + 1) / 2;
```

### 2. 나머지 연산 (모듈러)

java

```java
// 큰 수의 나머지
(a + b) % m = ((a % m) + (b % m)) % m
(a * b) % m = ((a % m) * (b % m)) % m

// 주의: 뺄셈은 음수 가능
(a - b) % m = ((a % m) - (b % m) + m) % m
```

### 3. 최대공약수 / 최소공배수

java

```java
// 유클리드 호제법 - O(log n)
int gcd(int a, int b) {
    if (b == 0) return a;
    return gcd(b, a % b);
}

// 최소공배수
int lcm(int a, int b) {
    return a / gcd(a, b) * b;  // 오버플로우 방지
}
```

### 4. 올림 나눗셈

java

```java
// a를 b로 나눈 올림
int ceil = (a + b - 1) / b;

// 또는
int ceil = (int) Math.ceil((double) a / b);
```

### 5. 거듭제곱 (분할정복)

java

````java
// a^n을 O(log n)에 계산
long power(long a, long n, long mod) {
    if (n == 0) return 1;
    if (n % 2 == 1) return a * power(a, n - 1, mod) % mod;
    long half = power(a, n / 2, mod);
    return half * half % mod;
}
```

---

## 문제 유형별 접근

| 유형 | 키워드 | 접근법 |
|-----|-------|-------|
| 합 계산 | "1부터 n까지 합" | 등차수열 공식 |
| 나머지 | "10^9+7로 나눈" | 모듈러 연산 |
| 약수/배수 | "공약수", "공배수" | GCD/LCM |
| 올림/내림 | "최소 며칠", "최소 개수" | 올림 나눗셈 |
| 큰 거듭제곱 | "a^n", "n ≤ 10^18" | 분할정복 거듭제곱 |

---

## 문제 접근법

1. **시간복잡도 확인** → 반복문 불가능하면 수학 의심
2. **예제 손으로 풀기** → 패턴이나 규칙 찾기
3. **공식 유도** → 일반화된 수식 만들기
4. **엣지 케이스 확인** → 0, 1, 최댓값 등 테스트

---

## 자주 하는 실수

- **오버플로우**: int 범위 초과 시 long 사용
- **0으로 나누기**: 분모가 0인 경우 예외 처리
- **올림 계산 실수**: (a + b - 1) / b 공식 활용
- **음수 나머지**: 모듈러 연산 시 + m 해주기

---

## 대표 문제: 달팽이는 올라가고 싶다
```
낮에 A 올라가고, 밤에 B 미끄러짐
정상(V)에 도달하면 미끄러지지 않음
며칠 걸리는가?
````

### 풀이

java

````java
// 핵심: 마지막 날 낮에 도착하면 안 미끄러짐
// (V - A)까지만 (A - B)씩 가면 됨

int days = (V - A) / (A - B) + 1;
if ((V - A) % (A - B) != 0) days++;
```

### 왜 이렇게?
```
V = 5, A = 2, B = 1일 때:

시뮬레이션:
1일차: 0 → 2 → 1
2일차: 1 → 3 → 2
3일차: 2 → 4 → 3
4일차: 3 → 5 (도착!) → 정답: 4일

공식:
(V - A) = 3  ← 마지막 날 전까지 도달해야 할 높이
(A - B) = 1  ← 하루 순증가량
3 / 1 + 1 = 4일 ✅
````

---

## 정리

> 💡 n이 10억 이상이면 수학 공식 의심 💡 예제를 손으로 풀며 규칙 찾기 💡 오버플로우 주의 (long 사용) 💡 반복문 없이 O(1)로 답 내기