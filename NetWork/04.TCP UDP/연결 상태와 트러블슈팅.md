
## TCP 연결 상태 (State)

```
CLOSED ──▶ SYN_SENT ──▶ ESTABLISHED ──▶ FIN_WAIT_1 ──▶ FIN_WAIT_2 ──▶ TIME_WAIT ──▶ CLOSED
               │              │
               ▼              ▼
          SYN_RECEIVED   CLOSE_WAIT ──▶ LAST_ACK ──▶ CLOSED
```

## 주요 상태

|상태|설명|발생 위치|
|---|---|---|
|LISTEN|연결 대기 중|서버|
|SYN_SENT|SYN 보내고 응답 대기|클라이언트|
|SYN_RECEIVED|SYN 받고 SYN+ACK 보냄|서버|
|ESTABLISHED|연결 완료, 데이터 전송 중|양쪽|
|FIN_WAIT_1|FIN 보내고 ACK 대기|먼저 종료하는 쪽|
|FIN_WAIT_2|ACK 받고 상대 FIN 대기|먼저 종료하는 쪽|
|TIME_WAIT|마지막 ACK 후 대기|먼저 종료하는 쪽|
|CLOSE_WAIT|FIN 받고 ACK 보냄|나중에 종료하는 쪽|
|LAST_ACK|FIN 보내고 ACK 대기|나중에 종료하는 쪽|

## TIME_WAIT 트러블슈팅

### 현상

```bash
$ ss -tan | grep TIME_WAIT | wc -l
5000   # TIME_WAIT 상태 연결이 너무 많음
```

### 원인

- 많은 단기 연결을 생성/종료하는 경우
- TIME_WAIT는 2MSL(보통 60초) 동안 유지

### 왜 TIME_WAIT가 필요한가?

1. 지연된 패킷이 새 연결에 영향 주는 것 방지
2. 마지막 ACK 손실 시 재전송 대응

### 해결 방법

```bash
# 1. tcp_tw_reuse 활성화 (클라이언트 측에서 재사용)
echo 1 > /proc/sys/net/ipv4/tcp_tw_reuse

# 2. Connection Pool 사용 (연결 재사용)
# - DB 커넥션 풀
# - HTTP Keep-Alive

# 3. 확인
ss -tan state time-wait | wc -l
```

## CLOSE_WAIT 트러블슈팅

### 현상

```bash
$ ss -tan | grep CLOSE_WAIT | wc -l
500   # CLOSE_WAIT 상태가 계속 쌓임
```

### 원인

- **애플리케이션 버그**: 상대방이 FIN 보냈는데 close() 호출 안 함
- 소켓을 제대로 닫지 않는 코드

### CLOSE_WAIT vs TIME_WAIT

|구분|CLOSE_WAIT|TIME_WAIT|
|---|---|---|
|발생 위치|FIN 받은 쪽|FIN 먼저 보낸 쪽|
|원인|애플리케이션 문제|정상 동작|
|해결|코드 수정 필요|커널 튜닝 가능|

### 해결 방법

```java
// 잘못된 코드
Socket socket = new Socket("host", 80);
// ... 사용 후 close() 호출 안 함

// 올바른 코드
try (Socket socket = new Socket("host", 80)) {
    // ... 사용
} // 자동으로 close()
```

## 디버깅 명령어

```bash
# 특정 포트 연결 상태 확인
ss -tan | grep :80
ss -tan | grep :443

# 상태별 집계
ss -tan | awk '{print $1}' | sort | uniq -c

# 특정 상태만 필터링
ss -tan state time-wait
ss -tan state close-wait
ss -tan state established
```

## 연결 문제 시 체크포인트

1. ESTABLISHED 수가 비정상적으로 적은가?
2. TIME_WAIT가 과도하게 쌓이는가?
3. CLOSE_WAIT가 계속 증가하는가?