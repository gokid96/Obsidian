네, 백엔드 구현 내용을 보완하겠습니다.

---

## 낙관적 락 (Optimistic Locking) 적용

> 동일한 워크스페이스 내 여러 멤버가 같은 게시글을 동시에 수정할 때 발생하는 데이터 충돌 문제를 해결하기 위해 JPA의 `@Version`을 활용한 낙관적 락을 적용함.

---

### 백엔드 구현

#### 1. Post 엔티티에 @Version 추가

```java
// Post.java
@Entity
public class Post {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long postId;

    @Version
    private Long version;  // 낙관적 락을 위한 버전 필드
    
    // ...
}
```

#### 2. DTO에 version 필드 추가


```java
// PostUpdateRequestDTO.java
@Data
public class PostUpdateRequestDTO {
    private String title;
    private String content;
    private Long version;  // 클라이언트가 보내는 version
}

// PostResponseDTO.java
@Data
@Builder
public class PostResponseDTO {
    private Long id;
    private String title;
    private String content;
    private Long version;  // 응답에 version 포함
    // ...
    
    public static PostResponseDTO from(Post post) {
        return PostResponseDTO.builder()
                .id(post.getPostId())
                .title(post.getTitle())
                .content(post.getContent())
                .version(post.getVersion())
                // ...
                .build();
    }
}
```

#### 3. PostService에서 version 검증 및 저장

```java
// PostService.java
@Transactional
public PostResponseDTO updatePost(Long userId, Long workspaceId, Long postId, PostUpdateRequestDTO request) {
    WorkspaceMember member = getMemberOrThrow(userId, workspaceId);
    checkWritePermission(member);

    Post post = postRepository.findByPostIdAndWorkspaceWorkspaceId(postId, workspaceId)
            .orElseThrow(() -> new IllegalArgumentException("게시글을 찾을 수 없습니다."));

    // version 검증 (클라이언트 version과 DB version 비교)
    if (request.getVersion() != null && !request.getVersion().equals(post.getVersion())) {
        throw new ObjectOptimisticLockingFailureException(Post.class, postId);
    }

    if (request.getTitle() != null) post.updateTitle(request.getTitle());
    if (request.getContent() != null) post.updateContent(request.getContent());

    // saveAndFlush로 즉시 DB 반영 → version 증가된 값 반환
    Post savedPost = postRepository.saveAndFlush(post);
    return PostResponseDTO.from(savedPost);
}
```

> **주의:** `save()` 대신 `saveAndFlush()` 사용
> 
> - `save()`: 트랜잭션 종료 시 더티 체킹으로 DB 반영 → 응답 시점에 version 미반영
> - `saveAndFlush()`: 즉시 DB 반영 → 응답에 증가된 version 포함

#### 4. GlobalExceptionHandler에 충돌 예외 처리 추가

```java
// GlobalExceptionHandler.java
@ExceptionHandler(ObjectOptimisticLockingFailureException.class)
public ResponseEntity<Map<String, Object>> handleOptimisticLockException(
        ObjectOptimisticLockingFailureException e) {
    log.warn("Optimistic lock conflict: {}", e.getMessage());
    return createErrorResponse(HttpStatus.CONFLICT, "다른 곳에서 수정되었습니다.");
}

// Hibernate 내부 예외 처리 (TransactionSystemException 래핑되는 경우)
@ExceptionHandler(TransactionSystemException.class)
public ResponseEntity<Map<String, Object>> handleTransactionException(TransactionSystemException e) {
    Throwable cause = e.getRootCause();
    if (cause instanceof OptimisticLockException || 
        cause instanceof StaleObjectStateException) {
        return createErrorResponse(HttpStatus.CONFLICT, "다른 곳에서 수정되었습니다.");
    }
    return createErrorResponse(HttpStatus.INTERNAL_SERVER_ERROR, "서버 오류가 발생했습니다.");
}
```

#### 5. 기존 데이터 version 초기화 (마이그레이션)

```sql
-- version이 NULL인 기존 데이터 초기화
UPDATE post SET version = 0 WHERE version IS NULL;
```

---

### 동작 원리

````sql
-- JPA가 생성하는 UPDATE 쿼리
UPDATE post 
SET title = ?, content = ?, version = 2 
WHERE post_id = 1 AND version = 1
```

- 저장 성공 시: version 자동 증가
- 다른 멤버가 먼저 수정했다면: version 불일치 → 409 Conflict

---

### 충돌 시나리오
```
시간  멤버 A                  멤버 B                  DB version
─────────────────────────────────────────────────────────────────
0초   게시글 조회 (v:1)       게시글 조회 (v:1)       1
2초   "AAA" 저장 →            -                       2 (성공)
3초   -                       "BBB" 저장 →            2 (실패, 409)
      -                       충돌 모달 표시          -
      -                       [최신 버전 불러오기]    -
      -                       또는 [내 변경사항 유지] -
````

---

### 프론트엔드 충돌 처리 (vi 에디터 방식)

|선택|동작|version 업데이트|
|---|---|---|
|**최신 버전 불러오기**|서버 내용으로 교체 (보기 모드)|❌ (다시 수정 시 또 충돌)|
|**내 변경사항 유지**|최신 version으로 내 내용 저장|✅ (락 획득)|

---

### 낙관적 락 vs 비관적 락

|구분|낙관적 락|비관적 락|
|---|---|---|
|락 시점|저장 시|조회 시|
|충돌 처리|예외 + 재시도|대기 (블로킹)|
|성능|좋음|DB 락 오버헤드|
|적합한 경우|충돌 빈도 낮음|충돌 빈도 높음|

→ 노트 앱은 같은 게시글 동시 편집 확률이 낮으므로 **낙관적 락이 적합**