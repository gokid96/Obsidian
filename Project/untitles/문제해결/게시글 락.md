## 낙관적 락 (Optimistic Locking) 적용

> 동일한 워크스페이스 내 여러 멤버가 같은 게시글을 동시에 수정할 때 
> 발생하는 데이터 충돌 문제를 해결하기 위해 JPA의 `@Version`을 활용한 낙관적 락을 적용함.

---

### 백엔드 구현
#### 1. Post 엔티티에 @Version 추가


```java
// Post.java
@Entity
public class Post {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long postId;

    @Version
    private Long version;  // 낙관적 락을 위한 버전 필드
    
    // ...
}
```

#### 2. GlobalExceptionHandler에 충돌 예외 처리 추가
```java
// GlobalExceptionHandler.java
@ExceptionHandler(ObjectOptimisticLockingFailureException.class)
public ResponseEntity<Map<String, Object>> handleOptimisticLockException(
        ObjectOptimisticLockingFailureException e) {
    log.warn("Optimistic lock conflict: {}", e.getMessage());
    return createErrorResponse(HttpStatus.CONFLICT, "다른 곳에서 수정되었습니다.");
}
```

---

### 동작 원리

sql

```sql
-- JPA가 생성하는 UPDATE 쿼리
UPDATE post 
SET title = ?, content = ?, version = 2 
WHERE post_id = 1 AND version = 1
```

- 저장 성공 시: version 자동 증가
- 다른 멤버가 먼저 수정했다면: version 불일치 → 409 Conflict

---

### 충돌 시나리오
```
시간  멤버 A                  멤버 B                  DB version
─────────────────────────────────────────────────────────────────
0초   게시글 조회 (v:1)       게시글 조회 (v:1)       1
2초   "AAA" 저장 →            -                       2 (성공)
3초   -                       "BBB" 저장 →            2 (실패, 409)
      -                       최신 데이터 재조회       -
      -                       "수정 충돌" 알림        -
````
---

### 낙관적 락 vs 비관적 락

| 구분     | 낙관적 락    | 비관적 락     |
| ------ | -------- | --------- |
| 락 시점   | 저장 시     | 조회 시      |
| 충돌 처리  | 예외 + 재시도 | 대기 (블로킹)  |
| 성능     | 좋음       | DB 락 오버헤드 |
| 적합한 경우 | 충돌 빈도 낮음 | 충돌 빈도 높음  |

→ 노트 앱은 같은 게시글 동시 편집 확률이 낮으므로 **낙관적 락이 적합**