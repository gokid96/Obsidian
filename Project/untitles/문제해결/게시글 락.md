## 낙관적 락 (Optimistic Locking) 적용

### 개요

동일한 게시글을 여러 탭/디바이스에서 동시에 수정할 때 발생하는 데이터 충돌 문제를 해결하기 위해 JPA의 `@Version`을 활용한 낙관적 락을 적용함.

---

### 백엔드 구현

#### 1. Post 엔티티에 @Version 추가

```java
// Post.java
@Entity
public class Post {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long postId;

    @Version
    private Long version;  // 낙관적 락을 위한 버전 필드
    
    // ...
}
```

#### 2. GlobalExceptionHandler에 충돌 예외 처리 추가

```java
// GlobalExceptionHandler.java
@ExceptionHandler(ObjectOptimisticLockingFailureException.class)
public ResponseEntity<Map<String, Object>> handleOptimisticLockException(
        ObjectOptimisticLockingFailureException e) {
    log.warn("Optimistic lock conflict: {}", e.getMessage());
    return createErrorResponse(HttpStatus.CONFLICT, "다른 곳에서 수정되었습니다.");
}
```

---

### 동작 원리
```
1. 게시글 조회 시 version 값 함께 조회 (예: version = 1)
2. 수정 저장 시 JPA가 자동으로 WHERE version = 1 조건 추가
3. 저장 성공 시 version 자동 증가 (version = 2)
4. 다른 곳에서 먼저 수정했다면 version 불일치 → 0 rows updated → 예외 발생
````

````sql
-- JPA가 생성하는 UPDATE 쿼리
UPDATE post 
SET title = ?, content = ?, version = 2 
WHERE post_id = 1 AND version = 1
```

---

### 충돌 시나리오
```
시간  탭 1                    탭 2                    DB version
─────────────────────────────────────────────────────────────────
0초   게시글 조회 (v:1)       게시글 조회 (v:1)       1
2초   "AAA" 저장 →            -                       2 (성공)
3초   -                       "BBB" 저장 →            2 (실패, 409)
      -                       최신 데이터 재조회       -
      -                       토스트 알림 표시        -
````

---

### 낙관적 락 vs 비관적 락

|구분|낙관적 락|비관적 락|
|---|---|---|
|락 시점|저장 시|조회 시|
|충돌 처리|예외 + 재시도|대기 (블로킹)|
|성능|좋음|DB 락 오버헤드|
|적합한 경우|충돌 빈도 낮음|충돌 빈도 높음|

→ 노트 앱은 같은 게시글 동시 편집 확률이 낮으므로 **낙관적 락이 적합**