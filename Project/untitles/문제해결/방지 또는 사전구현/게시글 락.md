# 낙관적 락(Optimistic Lock)을 활용한 동시 수정 충돌 해결

##  개요

**문제 상황**: 동일 문서를 여러 탭/기기에서 동시에 수정할 때 데이터 유실 발생

---
##  문제 정의
### 상황
 여러 사용자가 동일한 문서를 열고 수정하는 경우가 발생한다.
### 문제점
일반적인 PUT 요청으로 저장 시, **마지막에 저장한 내용만 반영**되어 이전 수정 내용이 덮어씌워지는 **Lost Update** 문제가 발생한다.

```
[시나리오]
1. 사용자 A가 문서(version=1)를 열어 "내용 A" 작성 중
2. 사용자 B가 다른 탭에서 같은 문서(version=1)를 열어 "내용 B" 작성 후 저장 → version=2
3. 사용자 A가 첫 번째 탭에서 "내용 A" 저장 (version=1 기준)
4. 결과: "내용 B"가 유실됨 (Lost Update)
```
### 해결 방안 비교

| 방식        | 장점                    | 단점                 |
| --------- | --------------------- | ------------------ |
| **비관적 락** | 충돌 자체를 방지             | 락 대기 시간 발생, 동시성 저하 |
| **낙관적 락** | 동시성 유지, 충돌이 드문 경우 효율적 | 충돌 시 재시도 로직 필요     |
→ 문서 편집 서비스는 **동시 수정이 드물고**, 충돌 시 **사용자 선택**이 중요하므로 **낙관적 락** 채택

---
## 구현

### 1. Entity - @Version 필드 추가
```java

@Entity
@Table(name = "post")
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AllArgsConstructor(access = AccessLevel.PRIVATE)
@Builder
public class Post {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "post_id")
    private Long postId;

    @Version  // JPA 낙관적 락 핵심
    private Long version;

    @Column(nullable = false, length = 200)
    private String title;

    @Column(nullable = false, columnDefinition = "MEDIUMTEXT")
    private String content;

    @Column(name = "created_at", nullable = false, updatable = false)
    @CreationTimestamp
    private LocalDateTime createdAt;

    @Column(name = "updated_at", nullable = false)
    @UpdateTimestamp
    private LocalDateTime updatedAt;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private Users author;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "folder_id")
    private Folder folder;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "workspace_id", nullable = false)
    private Workspace workspace;

    public void updateTitle(String title) {
        this.title = title;
    }

    public void updateContent(String content) {
        this.content = content;
    }
}
```

  

**@Version 동작 원리**:
- JPA가 자동으로 버전을 관리하며, 저장 시 version이 1씩 증가
- UPDATE 쿼리 실행 시 `WHERE version = ?` 조건이 자동 추가됨
- 조회 시점의 version과 저장 시점의 version이 다르면 `OptimisticLockException` 발생

  

### 2. DTO - Version 필드 포함
```java
@Getter
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class PostUpdateRequestDTO {
    @Size(max = 200)
    private String title;
    @Size(max = 50000)
    private String content;
    private Long version;  // 클라이언트가 보유한 version
}
```

  

### 3. Service - 충돌 감지 로직

  

```java

@Service
@RequiredArgsConstructor
public class PostService {
    private final PostRepository postRepository;
    private final FolderRepository folderRepository;
    private final UserRepository userRepository;
    private final WorkspaceRepository workspaceRepository;
    private final WorkspaceMemberRepository workspaceMemberRepository;
  
    /**
     * 게시글 수정 - 낙관적 락 적용
     */
    public PostResponseDTO updatePost(Long userId, Long workspaceId,
                                       Long postId, PostUpdateRequestDTO request) {
        // 1. 권한 검증
        WorkspaceMember member = getMemberOrThrow(userId, workspaceId);
        checkWritePermission(member);
        
        // 2. 게시글 조회
        Post post = postRepository.findByPostIdAndWorkspaceWorkspaceId(postId, workspaceId)
                .orElseThrow(() -> new IllegalArgumentException("게시글을 찾을 수 없습니다."));

        // 3. 클라이언트 version과 DB version 비교
        if (request.getVersion() != null && !request.getVersion().equals(post.getVersion())) {
            throw new OptimisticLockException("다른 곳에서 수정되었습니다.");
        }
  
        // 4. 수정 적용
        if (request.getTitle() != null) {
            post.updateTitle(request.getTitle());
        }
        if (request.getContent() != null) {
            post.updateContent(request.getContent());
        }

        // 5. 저장 (saveAndFlush로 즉시 반영하여 version 증가 확인)
        return PostResponseDTO.from(postRepository.saveAndFlush(post));
    }

    private WorkspaceMember getMemberOrThrow(Long userId, Long workspaceId) {
        Workspace workspace = workspaceRepository.findById(workspaceId)
                .orElseThrow(() -> new IllegalArgumentException("워크스페이스를 찾을 수 없습니다."));
        Users user = userRepository.findById(userId)
                .orElseThrow(() -> new IllegalArgumentException("사용자를 찾을 수 없습니다."));

        return workspaceMemberRepository.findByWorkspaceAndUser(workspace, user)
                .orElseThrow(() -> new IllegalArgumentException("워크스페이스 접근 권한이 없습니다."));
    }

    private void checkWritePermission(WorkspaceMember member) {
        if (member.getRole() == WorkspaceRole.VIEWER) {
            throw new IllegalArgumentException("쓰기 권한이 없습니다.");
        }
    }
}
```

  

**핵심 포인트**:
- 클라이언트가 보낸 `version`과 현재 DB의 `version`을 명시적으로 비교
- 불일치 시 `OptimisticLockException`을 던져 409 Conflict 응답 유도
- `saveAndFlush()`로 즉시 DB에 반영하여 version 증가를 보장

### 4. Global Exception Handler - 409 Conflict 응답

```java

@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler {
    /**
     * 낙관적 락 충돌 → 409 Conflict
     */
    @ExceptionHandler({
            OptimisticLockException.class,
            ObjectOptimisticLockingFailureException.class,
            StaleObjectStateException.class
    })

    public ResponseEntity<Map<String, Object>> handleOptimisticLockException(Exception e) {
        log.warn("Optimistic lock conflict: {}", e.getMessage());
        return createErrorResponse(HttpStatus.CONFLICT, "다른 곳에서 수정되었습니다.");

}
    /**
     * 트랜잭션 내부에서 발생한 낙관적 락 예외 처리
     * - @Transactional 메서드 내에서 발생한 OptimisticLockException은
     *   TransactionSystemException으로 래핑되어 전파됨
     */
    @ExceptionHandler(TransactionSystemException.class)
    public ResponseEntity<Map<String, Object>> handleTransactionException(TransactionSystemException e) {
        Throwable cause = e.getRootCause();
        if (cause instanceof OptimisticLockException ||
                cause instanceof StaleObjectStateException) {
            log.warn("Optimistic lock conflict in transaction: {}", cause.getMessage());
            return createErrorResponse(HttpStatus.CONFLICT, "다른 곳에서 수정되었습니다.");
        }
        log.error("Transaction error: ", e);
        return createErrorResponse(HttpStatus.INTERNAL_SERVER_ERROR, "서버 오류가 발생했습니다.");
    }

    private ResponseEntity<Map<String, Object>> createErrorResponse(HttpStatus status, String message) {
        Map<String, Object> response = new HashMap<>();
        response.put("status", "error");
        response.put("code", status.value());
        response.put("message", message);
        return ResponseEntity.status(status).body(response);
    }
}
```

**예외 처리 포인트**:

- `OptimisticLockException`: JPA 표준 예외
- `ObjectOptimisticLockingFailureException`: Spring Data JPA 예외
- `StaleObjectStateException`: Hibernate 예외
- `TransactionSystemException`: 트랜잭션 커밋 시점에 래핑된 예외
### 5. Controller

```java
@RestController
@RequestMapping("/api/v1/workspaces/{workspaceId}/posts")
@RequiredArgsConstructor
public class PostController {
    private final PostService postService;
    @PutMapping("/{postId}")
    public ResponseEntity<PostResponseDTO> updatePost(
            @AuthenticationPrincipal CustomUserDetails userDetails,
            @PathVariable Long workspaceId,
            @PathVariable Long postId,
            @RequestBody @Valid PostUpdateRequestDTO request) {
        return ResponseEntity.ok(
            postService.updatePost(userDetails.getUserId(), workspaceId, postId, request)
        );
    }
}
```
---
## 동작 흐름
```
┌──────────────┐         ┌──────────────┐         ┌──────────────┐
│   Client A   │         │    Server    │         │   Client B   │
└──────┬───────┘         └──────┬───────┘         └──────┬───────┘
       │                        │                        │
       │  GET /posts/1          │                        │
       │ ─────────────────────► │                        │
       │  {version: 1, ...}     │                        │
       │ ◄───────────────────── │                        │
       │                        │   GET /posts/1         │
       │                        │ ◄──────────────────────│
       │                        │   {version: 1, ...}    │
       │                        │ ──────────────────────►│
       │                        │                        │
       │                        │  PUT {version: 1, ..}  │
       │                        │ ◄──────────────────────│
       │                        │                        │
       │                        │  [version 비교: 1 == 1]│
       │                        │  [저장 성공]           │
       │                        │  [version → 2]         │
       │                        │                        │
       │                        │  ✅ 200 OK             │
       │                        │  {version: 2, ...}     │
       │                        │ ──────────────────────►│
       │                        │                        │
       │ PUT {version: 1, ...}  │                        │
       │ ─────────────────────► │                        │
       │                        │                        │
       │  [version 비교: 1 != 2]│                        │
       │  [충돌 감지!]          │                        │
       │                        │                        │
       │  ❌ 409 Conflict       │                        │
       │  "다른 곳에서 수정됨"  │                        │
       │ ◄───────────────────── │                        │
```

  

---

##  결과

### Before
- 마지막 저장 내용만 반영 (Lost Update)
- 사용자가 작업 내용 유실을 인지하지 못함
- 데이터 정합성 보장 불가
### After

- 충돌 즉시 감지 및 **409 Conflict** 응답
- 클라이언트에서 충돌 상황을 인지하고 적절한 처리 가능
- 데이터 유실 방지

---

  

## 핵심 학습 포인트
  

1. **JPA @Version**
   - 엔티티에 `@Version` 필드 추가만으로 낙관적 락 구현 가능
   - UPDATE 쿼리에 `WHERE version = ?` 조건이 자동 추가됨

1. **명시적 Version 비교**
   - `@Version`만으로는 JPA 영속성 컨텍스트 내에서만 동작
   - REST API에서는 클라이언트가 보낸 version을 명시적으로 비교해야 함

1. **예외 계층 이해**
   - `OptimisticLockException` → `TransactionSystemException`으로 래핑되는 경우 존재
   - 여러 예외 타입을 모두 핸들링해야 누락 없이 처리 가능

1. **HTTP 상태 코드**
   - **409 Conflict**: 리소스 충돌을 나타내는 표준 상태 코드
   - 클라이언트가 충돌 상황을 명확히 인지하고 재시도 로직 구현 가능

4. **saveAndFlush() 사용**
   - 즉시 DB에 반영하여 version 증가를 보장
   - 응답에 최신 version을 포함시켜 클라이언트에 전달

---
##  관련 파일

```
untitles-api/src/main/java/com/untitles/
├── domain/post/
│   ├── entity/Post.java                    # @Version 필드 정의
│   ├── dto/request/PostUpdateRequestDTO.java  # version 포함
│   ├── service/PostService.java            # version 비교 로직
│   └── controller/PostController.java
└── global/exception/
    └── GlobalExceptionHandler.java         # 409 Conflict 응답 처리
```