## 캐시 무효화란?

캐시된 데이터가 원본과 달라졌을 때, 캐시를 갱신하거나 삭제하는 것

"컴퓨터 과학에서 어려운 두 가지: 캐시 무효화, 네이밍" — Phil Karlton

---

## 왜 어려운가?

```
[원본 DB]  ──── 데이터 변경 ────→  어떻게 캐시에 알리지?
                                         │
[캐시]     ──── 오래된 데이터 ────→  언제까지 들고 있지?
```

**문제 상황들**

- DB는 바뀌었는데 캐시는 옛날 데이터
- 캐시 갱신하는 사이에 또 DB가 바뀜
- 여러 서버의 캐시가 각각 다른 데이터

---

## 무효화 전략

### 1. TTL (Time To Live)

**가장 간단한 방법**: 일정 시간 후 자동 만료

```java
// Redis 예시 (Jedis)
jedis.setex("user:123", 3600, userData);  // 1시간 후 만료

// RedisTemplate
redisTemplate.opsForValue().set("user:123", userData, Duration.ofHours(1));
```

**동작 방식**

```
1. 캐시 저장 (TTL 1시간)
2. 1시간 동안 캐시 사용
3. 만료 후 다음 요청에서 DB 조회 → 캐시 갱신
```

|장점|단점|
|---|---|
|구현 간단|TTL 동안 불일치 가능|
|자동 정리|적절한 TTL 설정 어려움|

**TTL 설정 기준**

| 데이터 유형           | 권장 TTL  |
| ---------------- | ------- |
| 거의 안 바뀜 (설정, 코드) | 24시간 이상 |
| 가끔 바뀜 (프로필, 상품)  | 1~24시간  |
| 자주 바뀜 (재고, 좋아요)  | 1~5분    |
| 실시간 (주식, 채팅)     | 캐시 안 함  |

---

### 2. Write-Through

**쓰기 시 캐시와 DB 동시 갱신**

```java
@Service
@RequiredArgsConstructor
public class UserService {
    private final UserRepository userRepository;
    private final RedisTemplate<String, User> redisTemplate;
    
    @Transactional
    public void updateUser(String userId, UserData data) {
        // 1. DB 저장
        User user = userRepository.findById(userId).orElseThrow();
        user.update(data);
        userRepository.save(user);
        
        // 2. 캐시도 즉시 갱신
        redisTemplate.opsForValue().set("user:" + userId, user, Duration.ofHours(1));
    }
}
```

**동작 방식**

```
쓰기 요청
    │
    ├──→ DB 저장
    │
    └──→ 캐시 갱신
    │
   응답
```

| 장점        | 단점             |
| --------- | -------------- |
| 항상 일관성 유지 | 쓰기 느림 (두 번 저장) |
| 구현 직관적    | 캐시 장애 시 쓰기 실패  |


---

### 3. Write-Invalidate (Cache-Aside)

**쓰기 시 캐시 삭제, 다음 읽기에서 갱신**

```java
@Service
@RequiredArgsConstructor
public class UserService {
    private final UserRepository userRepository;
    private final RedisTemplate<String, User> redisTemplate;
    
    // 쓰기
    @Transactional
    public void updateUser(String userId, UserData data) {
        // 1. DB 저장
        User user = userRepository.findById(userId).orElseThrow();
        user.update(data);
        userRepository.save(user);
        
        // 2. 캐시 삭제 (갱신 아님!)
        redisTemplate.delete("user:" + userId);
    }
    
    // 읽기
    public User getUser(String userId) {
        String key = "user:" + userId;
        
        // 1. 캐시 확인
        User cached = redisTemplate.opsForValue().get(key);
        if (cached != null) {
            return cached;
        }
        
        // 2. 캐시 미스 → DB 조회
        User user = userRepository.findById(userId).orElseThrow();
        
        // 3. 캐시에 저장
        redisTemplate.opsForValue().set(key, user, Duration.ofHours(1));
        
        return user;
    }
}
```

**동작 방식**

```
쓰기 요청 → DB 저장 → 캐시 삭제 → 응답

다음 읽기 요청 → 캐시 미스 → DB 조회 → 캐시 저장 → 응답
```

| 장점            | 단점               |
| ------------- | ---------------- |
| 쓰기 빠름         | 삭제 직후 읽기 시 DB 부하 |
| 불필요한 캐시 갱신 방지 | 캐시 스탬피드 위험       |

**가장 많이 쓰이는 패턴**

---

### 4. Write-Behind (Write-Back)

**캐시에 먼저 쓰고, 나중에 DB 반영**

```java
@Service
@RequiredArgsConstructor
public class UserService {
    private final RedisTemplate<String, User> redisTemplate;
    private final RabbitTemplate rabbitTemplate;
    
    // 쓰기: 캐시에만 저장
    public void updateUser(String userId, UserData data) {
        User user = User.from(data);
        redisTemplate.opsForValue().set("user:" + userId, user);
        
        // 큐에 추가 (나중에 DB 반영)
        rabbitTemplate.convertAndSend("sync-to-db", new SyncMessage(userId, data));
    }
}

// 백그라운드 워커
@Component
@RequiredArgsConstructor
public class DbSyncWorker {
    private final UserRepository userRepository;
    
    @RabbitListener(queues = "sync-to-db")
    public void syncToDb(SyncMessage message) {
        User user = userRepository.findById(message.getUserId()).orElseThrow();
        user.update(message.getData());
        userRepository.save(user);
    }
}
```

**동작 방식**

```
쓰기 요청 → 캐시 저장 → 응답 (빠름!)
                │
                └→ 큐 → 백그라운드에서 DB 저장
```

| 장점       | 단점             |
| -------- | -------------- |
| 쓰기 매우 빠름 | 캐시 장애 시 데이터 유실 |
| DB 부하 감소 | 구현 복잡          |

**사용 예**: 좋아요 수, 조회수 (유실되어도 치명적이지 않은 데이터)

---

### 5. 이벤트 기반 무효화

**DB 변경 이벤트를 감지해서 캐시 갱신**

```java
@Service
@RequiredArgsConstructor
public class UserService {
    private final UserRepository userRepository;
    private final ApplicationEventPublisher eventPublisher;
    
    // DB 변경 이벤트 발행
    @Transactional
    public void updateUser(String userId, UserData data) {
        User user = userRepository.findById(userId).orElseThrow();
        user.update(data);
        userRepository.save(user);
        
        // 이벤트 발행
        eventPublisher.publishEvent(new UserUpdatedEvent(userId));
    }
}

// 이벤트 구독 → 캐시 무효화
@Component
@RequiredArgsConstructor
public class CacheInvalidationHandler {
    private final RedisTemplate<String, Object> redisTemplate;
    
    @EventListener
    public void handleUserUpdated(UserUpdatedEvent event) {
        String userId = event.getUserId();
        
        redisTemplate.delete("user:" + userId);
        
        // 연관 캐시도 무효화
        redisTemplate.delete("user-profile:" + userId);
        redisTemplate.delete("user-posts:" + userId);
    }
}
```

**CDC (Change Data Capture) 활용**

```
[DB] → [Debezium] → [Kafka] → [캐시 무효화 서비스]
```

|장점|단점|
|---|---|
|연관 캐시 일괄 무효화|인프라 복잡|
|서비스 간 결합도 낮음|이벤트 유실 가능성|

---

## 캐시 스탬피드 (Cache Stampede)

### 문제 상황

캐시 만료 시 동시 요청이 몰려 DB 폭주

```
캐시 만료
    │
    ├─ 요청1 → 캐시 미스 → DB 조회
    ├─ 요청2 → 캐시 미스 → DB 조회
    ├─ 요청3 → 캐시 미스 → DB 조회
    └─ ... (수백 개 동시 요청)
    
    → DB 과부하!
```

### 해결 방법

**1. 락 (Mutex)**

```java
@Service
@RequiredArgsConstructor
public class UserService {
    private final UserRepository userRepository;
    private final RedisTemplate<String, User> redisTemplate;
    private final RedissonClient redissonClient;
    
    public User getUser(String userId) {
        String key = "user:" + userId;
        
        User cached = redisTemplate.opsForValue().get(key);
        if (cached != null) {
            return cached;
        }
        
        // 락 획득 시도
        RLock lock = redissonClient.getLock("lock:" + key);
        try {
            if (lock.tryLock(5, 10, TimeUnit.SECONDS)) {
                try {
                    // 다시 캐시 확인 (다른 스레드가 이미 갱신했을 수 있음)
                    cached = redisTemplate.opsForValue().get(key);
                    if (cached != null) {
                        return cached;
                    }
                    
                    // DB 조회 및 캐시 저장
                    User user = userRepository.findById(userId).orElseThrow();
                    redisTemplate.opsForValue().set(key, user, Duration.ofHours(1));
                    return user;
                } finally {
                    lock.unlock();
                }
            } else {
                // 락 획득 실패 → 잠시 대기 후 재시도
                Thread.sleep(100);
                return getUser(userId);
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RuntimeException(e);
        }
    }
}
```

**2. 백그라운드 갱신**

```java
@Service
@RequiredArgsConstructor
public class UserService {
    private final UserRepository userRepository;
    private final RedisTemplate<String, User> redisTemplate;
    private final ExecutorService executor = Executors.newCachedThreadPool();
    
    public User getUser(String userId) {
        String key = "user:" + userId;
        
        User cached = redisTemplate.opsForValue().get(key);
        Long ttl = redisTemplate.getExpire(key, TimeUnit.SECONDS);
        
        // TTL이 5분 미만이면 백그라운드에서 미리 갱신
        if (cached != null && ttl != null && ttl < 300) {
            executor.submit(() -> refreshCache(userId));
        }
        
        if (cached != null) {
            return cached;
        }
        
        // 캐시 미스
        User user = userRepository.findById(userId).orElseThrow();
        redisTemplate.opsForValue().set(key, user, Duration.ofHours(1));
        return user;
    }
    
    private void refreshCache(String userId) {
        User user = userRepository.findById(userId).orElse(null);
        if (user != null) {
            redisTemplate.opsForValue().set("user:" + userId, user, Duration.ofHours(1));
        }
    }
}
```

**3. 확률적 갱신 (Probabilistic Early Expiration)**

```java
// TTL이 가까워질수록 갱신 확률 증가
private boolean shouldRefresh(long ttl, long maxTtl) {
    double remaining = (double) ttl / maxTtl;
    double probability = 1 - remaining;  // 남은 시간 적을수록 확률 높음
    return Math.random() < probability * 0.1;  // 최대 10% 확률
}
```

---

## 일관성 문제와 해결

### 문제: DB 갱신 후 캐시 삭제 실패

```
1. DB 저장 성공
2. 캐시 삭제 실패 (네트워크 오류)
3. 캐시에 오래된 데이터 남음
```

### 해결 1: 재시도

```java
@Service
@RequiredArgsConstructor
public class UserService {
    private final UserRepository userRepository;
    private final RedisTemplate<String, User> redisTemplate;
    
    @Transactional
    public void updateUser(String userId, UserData data) {
        User user = userRepository.findById(userId).orElseThrow();
        user.update(data);
        userRepository.save(user);
        
        // 재시도 로직
        for (int i = 0; i < 3; i++) {
            try {
                redisTemplate.delete("user:" + userId);
                break;
            } catch (Exception e) {
                try {
                    Thread.sleep(100 * (i + 1));
                } catch (InterruptedException ie) {
                    Thread.currentThread().interrupt();
                }
            }
        }
    }
}
```

### 해결 2: 이벤트 + 재처리 큐

```java
@Service
@RequiredArgsConstructor
public class UserService {
    private final UserRepository userRepository;
    private final RabbitTemplate rabbitTemplate;
    
    @Transactional
    public void updateUser(String userId, UserData data) {
        User user = userRepository.findById(userId).orElseThrow();
        user.update(data);
        userRepository.save(user);
        
        // 무효화 이벤트를 큐에 저장 (실패해도 재처리됨)
        rabbitTemplate.convertAndSend("invalidate-cache", 
            new CacheInvalidateMessage("user:" + userId, 3));
    }
}
```

### 해결 3: 짧은 TTL 병행

```java
// 캐시 삭제가 실패해도 TTL로 결국 만료됨
redisTemplate.opsForValue().set("user:" + userId, user, Duration.ofMinutes(5));
```

---

## 전략 선택 가이드

|상황|추천 전략|
|---|---|
|일관성 중요 (결제, 재고)|Write-Through 또는 캐시 안 씀|
|읽기 많고 쓰기 적음|Write-Invalidate (Cache-Aside)|
|쓰기 많음 (좋아요, 조회수)|Write-Behind|
|연관 데이터 많음|이벤트 기반 무효화|
|간단하게|TTL만 설정|

---

## 핵심 요약

| 전략               | 쓰기 시 동작         | 일관성 | 성능    |
| ---------------- | --------------- | --- | ----- |
| TTL              | 아무것도 안 함        | 낮음  | 좋음    |
| Write-Through    | 캐시 + DB 동시 갱신   | 높음  | 보통    |
| Write-Invalidate | 캐시 삭제           | 중간  | 좋음    |
| Write-Behind     | 캐시만 갱신, DB는 나중에 | 낮음  | 매우 좋음 |
| 이벤트 기반           | 이벤트로 무효화        | 중간  | 좋음    |

**정답은 없다** → 데이터 특성에 따라 전략 선택
