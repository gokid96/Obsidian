## 로드 밸런싱이란?

여러 서버에 트래픽을 분산시켜 부하를 나누는 기술

---

## 왜 필요한가?

### 단일 서버의 한계

```
[클라이언트] ──────→ [단일 서버]
                         │
                    용량 초과 시 장애
```

### 로드 밸런싱 적용

```
                    ┌─→ [서버 1]
[클라이언트] → [LB] ├─→ [서버 2]
                    └─→ [서버 3]
```

**효과**
- 처리량 증가
- 가용성 향상 (서버 장애 시 다른 서버로 분산)
- 수평 확장 가능

---

## L4 vs L7 로드 밸런서

### L4 로드 밸런서 (Transport Layer)

IP + Port 기반 분산

```
[클라이언트] → [L4 LB] → [서버]
              (IP:Port만 확인)
```

**특징**
- 빠름 (패킷 내용 안 봄)
- 단순한 분산만 가능
- TCP/UDP 레벨

**사용 사례**: 단순 트래픽 분산, 고성능 필요 시

### L7 로드 밸런서 (Application Layer)

HTTP 헤더, URL, 쿠키 기반 분산

```
[클라이언트] → [L7 LB] → [서버]
              (HTTP 내용 분석)
```

**특징**
- 세밀한 라우팅 가능
- URL 경로별 분산
- 헤더/쿠키 기반 분산
- SSL 종료 가능

**사용 사례**: API 게이트웨이, 마이크로서비스

### 비교

| 항목 | L4 | L7 |
|------|----|----|
| 레이어 | Transport | Application |
| 기준 | IP, Port | URL, Header, Cookie |
| 속도 | 빠름 | 상대적으로 느림 |
| 기능 | 단순 | 풍부 |
| SSL 처리 | 불가 | 가능 |

---

## 분산 알고리즘

### 1. Round Robin

순서대로 돌아가며 분배

```
요청 1 → 서버 A
요청 2 → 서버 B
요청 3 → 서버 C
요청 4 → 서버 A  (다시 처음부터)
```

| 장점 | 단점 |
|------|------|
| 구현 간단 | 서버 성능 차이 무시 |
| 균등 분배 | 요청 처리 시간 무시 |

**적합**: 서버 스펙이 동일하고 요청 처리 시간이 비슷할 때

### 2. Weighted Round Robin

서버별 가중치 부여

```
서버 A (가중치 3): 요청 1, 2, 3
서버 B (가중치 1): 요청 4
서버 C (가중치 2): 요청 5, 6
```

| 장점 | 단점 |
|------|------|
| 서버 성능 반영 | 실시간 부하 미반영 |

**적합**: 서버 스펙이 다를 때

### 3. Least Connections

현재 연결 수가 가장 적은 서버로

```
서버 A: 10개 연결 중
서버 B: 3개 연결 중  ← 선택
서버 C: 7개 연결 중
```

| 장점 | 단점 |
|------|------|
| 실시간 부하 반영 | 연결 수 추적 비용 |
| 장기 연결에 적합 | 서버 성능 차이 미반영 |

**적합**: WebSocket, 장기 연결 서비스

### 4. Weighted Least Connections

연결 수 + 가중치 조합

```
점수 = 현재 연결 수 / 가중치
점수가 낮은 서버 선택
```

### 5. IP Hash

클라이언트 IP 기반 해시로 서버 결정

```
hash(클라이언트 IP) % 서버 수 = 서버 인덱스
```

| 장점 | 단점 |
|------|------|
| 세션 유지 | 부하 불균형 가능 |
| Sticky Session | 서버 추가/제거 시 재분배 |

**적합**: 세션 기반 애플리케이션

### 6. Least Response Time

응답 시간이 가장 빠른 서버로

```
서버 A: 평균 50ms
서버 B: 평균 30ms  ← 선택
서버 C: 평균 45ms
```

| 장점 | 단점 |
|------|------|
| 성능 기반 분배 | 측정 오버헤드 |

---

## Health Check

### 필요성

장애 서버로 트래픽이 가면 안 됨

### 방식

**1. TCP Health Check**
```
LB → 서버 3000 포트 연결 시도
연결 성공 = Healthy
연결 실패 = Unhealthy
```

**2. HTTP Health Check**
```
LB → GET /health
200 OK = Healthy
그 외 = Unhealthy
```

**3. Health Check 엔드포인트 예시**

```java
// 단순 버전
@RestController
public class HealthController {
    
    @GetMapping("/health")
    public ResponseEntity<Map<String, String>> health() {
        return ResponseEntity.ok(Map.of("status", "ok"));
    }
}

// 상세 버전 (Spring Boot Actuator 스타일)
@RestController
@RequiredArgsConstructor
public class HealthController {
    private final DataSource dataSource;
    private final RedisTemplate<String, String> redisTemplate;
    
    @GetMapping("/health")
    public ResponseEntity<Map<String, Object>> health() {
        boolean dbStatus = checkDatabase();
        boolean redisStatus = checkRedis();
        
        Map<String, Object> response = new HashMap<>();
        response.put("db", dbStatus ? "ok" : "fail");
        response.put("redis", redisStatus ? "ok" : "fail");
        
        if (dbStatus && redisStatus) {
            response.put("status", "healthy");
            return ResponseEntity.ok(response);
        } else {
            response.put("status", "unhealthy");
            return ResponseEntity.status(503).body(response);
        }
    }
    
    private boolean checkDatabase() {
        try (Connection conn = dataSource.getConnection()) {
            return conn.isValid(5);
        } catch (SQLException e) {
            return false;
        }
    }
    
    private boolean checkRedis() {
        try {
            return "PONG".equals(redisTemplate.getConnectionFactory()
                .getConnection().ping());
        } catch (Exception e) {
            return false;
        }
    }
}
```

### 설정 항목

| 항목 | 설명 | 예시 |
|------|------|------|
| Interval | 체크 주기 | 10초 |
| Timeout | 응답 대기 시간 | 5초 |
| Unhealthy Threshold | 연속 실패 횟수 | 3회 |
| Healthy Threshold | 복구 확인 횟수 | 2회 |

---

## 세션 유지 (Session Persistence)

### 문제 상황

```
요청 1 → 서버 A (로그인, 세션 생성)
요청 2 → 서버 B (세션 없음, 로그인 풀림)
```

### 해결 방법

**1. Sticky Session (Session Affinity)**

같은 클라이언트는 같은 서버로

```
쿠키: SERVERID=server-a
→ 항상 서버 A로 라우팅
```

단점: 서버 장애 시 세션 유실

**2. Session Clustering**

세션을 공유 저장소에 저장

```
[서버 A] ──┐
[서버 B] ──┼─→ [Redis (세션 저장)]
[서버 C] ──┘
```

```java
// Spring Session + Redis 설정
@Configuration
@EnableRedisHttpSession
public class SessionConfig {
    
    @Bean
    public LettuceConnectionFactory connectionFactory() {
        return new LettuceConnectionFactory();
    }
}
```

**3. Stateless 설계**

JWT 등으로 서버에 세션 저장 안 함

```
토큰에 사용자 정보 포함
→ 어느 서버로 가도 인증 가능
```

---

## 주요 로드 밸런서

### 소프트웨어

| 이름 | 특징 |
|------|------|
| Nginx | L7, 리버스 프록시, 웹서버 겸용 |
| HAProxy | L4/L7, 고성능, 설정 유연 |
| Envoy | L7, 서비스 메시, gRPC 지원 |

### 클라우드 서비스

| 서비스 | 제공사 | 레벨 |
|--------|--------|------|
| ALB | AWS | L7 |
| NLB | AWS | L4 |
| Cloud Load Balancing | GCP | L4/L7 |

---

## 설정 예시

### Nginx

```nginx
upstream backend {
    least_conn;  # 알고리즘
    server 10.0.0.1:8080 weight=3;
    server 10.0.0.2:8080 weight=1;
    server 10.0.0.3:8080 backup;  # 백업 서버
}

server {
    listen 80;
    
    location / {
        proxy_pass http://backend;
        proxy_connect_timeout 5s;
        proxy_read_timeout 60s;
    }
    
    location /health {
        return 200 'ok';
    }
}
```

### HAProxy

```
frontend http_front
    bind *:80
    default_backend http_back

backend http_back
    balance roundrobin
    option httpchk GET /health
    server server1 10.0.0.1:8080 check weight 3
    server server2 10.0.0.2:8080 check weight 1
    server server3 10.0.0.3:8080 check backup
```

---

## 알고리즘 선택 가이드

| 상황                | 추천 알고리즘              |
| ----------------- | -------------------- |
| 서버 스펙 동일, 요청 균일   | Round Robin          |
| 서버 스펙 다름          | Weighted Round Robin |
| 장기 연결 (WebSocket) | Least Connections    |
| 세션 유지 필요          | IP Hash              |
| 성능 기반 최적화         | Least Response Time  |

---

## 핵심 요약

1. **L4**: IP/Port 기반, 빠름, 단순
2. **L7**: HTTP 기반, 세밀한 라우팅, 기능 풍부
3. **알고리즘**: 상황에 맞게 선택 (Round Robin, Least Connections, IP Hash 등)
4. **Health Check**: 장애 서버 자동 제외 필수
5. **세션 유지**: Sticky Session, Session Clustering, Stateless 중 선택
