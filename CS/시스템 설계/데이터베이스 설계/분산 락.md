## 분산 락이란?

여러 서버/프로세스에서 동시에 같은 자원에 접근하는 것을 방지하는 동기화 메커니즘

---

## 왜 필요한가?

### 문제: 동시성 이슈

```
[서버 1] 재고 조회: 10개
[서버 2] 재고 조회: 10개
[서버 1] 재고 차감: 10 - 1 = 9
[서버 2] 재고 차감: 10 - 1 = 9  (잘못된 결과)

→ 실제로 2개 판매, 재고는 9개 (8개여야 함)
```

### 분산 락 적용

```
[서버 1] 락 획득 → 재고 조회: 10개 → 차감: 9개 → 락 해제
[서버 2] 락 대기..........................→ 락 획득 → 재고 조회: 9개 → 차감: 8개 → 락 해제
```

---

## Redis 기반 분산 락

### 기본 구현 (SETNX)

```java
@Component
@RequiredArgsConstructor
public class RedisLock {
    private final RedisTemplate<String, String> redisTemplate;
    
    public String acquire(String key, long ttlMs) {
        String token = UUID.randomUUID().toString();
        String lockKey = "lock:" + key;
        
        Boolean result = redisTemplate.opsForValue()
            .setIfAbsent(lockKey, token, Duration.ofMillis(ttlMs));
        
        return Boolean.TRUE.equals(result) ? token : null;
    }
    
    public boolean release(String key, String token) {
        String lockKey = "lock:" + key;
        
        // Lua 스크립트로 원자적 실행 (본인 락만 해제)
        String script = 
            "if redis.call('get', KEYS[1]) == ARGV[1] then " +
            "  return redis.call('del', KEYS[1]) " +
            "else " +
            "  return 0 " +
            "end";
        
        DefaultRedisScript<Long> redisScript = new DefaultRedisScript<>(script, Long.class);
        Long result = redisTemplate.execute(redisScript, 
            Collections.singletonList(lockKey), token);
        
        return result != null && result == 1;
    }
}
```

### 사용 예시

```java
@Service
@RequiredArgsConstructor
public class StockService {
    private final RedisLock redisLock;
    private final StockRepository stockRepository;
    
    public void decreaseStock(String productId, int quantity) {
        String lockKey = "stock:" + productId;
        String token = redisLock.acquire(lockKey, 5000);
        
        if (token == null) {
            throw new LockAcquisitionException("락 획득 실패");
        }
        
        try {
            Stock stock = stockRepository.findById(productId).orElseThrow();
            
            if (stock.getQuantity() < quantity) {
                throw new InsufficientStockException("재고 부족");
            }
            
            stock.decrease(quantity);
            stockRepository.save(stock);
            
        } finally {
            redisLock.release(lockKey, token);
        }
    }
}
```

---

## Redisson 라이브러리 사용

### 의존성

```xml
<dependency>
    <groupId>org.redisson</groupId>
    <artifactId>redisson-spring-boot-starter</artifactId>
    <version>3.23.0</version>
</dependency>
```

### 설정

```yaml
spring:
  redis:
    host: localhost
    port: 6379
```

### 사용

```java
@Service
@RequiredArgsConstructor
public class StockService {
    private final RedissonClient redissonClient;
    private final StockRepository stockRepository;
    
    public void decreaseStock(String productId, int quantity) {
        RLock lock = redissonClient.getLock("lock:stock:" + productId);
        
        try {
            // 10초 동안 락 획득 시도, 획득 후 5초 유지
            boolean acquired = lock.tryLock(10, 5, TimeUnit.SECONDS);
            
            if (!acquired) {
                throw new LockAcquisitionException("락 획득 실패");
            }
            
            try {
                Stock stock = stockRepository.findById(productId).orElseThrow();
                
                if (stock.getQuantity() < quantity) {
                    throw new InsufficientStockException("재고 부족");
                }
                
                stock.decrease(quantity);
                stockRepository.save(stock);
                
            } finally {
                lock.unlock();
            }
            
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RuntimeException(e);
        }
    }
}
```

### AOP로 락 처리

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface DistributedLock {
    String key();
    long waitTime() default 5000;
    long leaseTime() default 3000;
}

@Aspect
@Component
@RequiredArgsConstructor
public class DistributedLockAspect {
    private final RedissonClient redissonClient;
    
    @Around("@annotation(distributedLock)")
    public Object around(ProceedingJoinPoint joinPoint, DistributedLock distributedLock) throws Throwable {
        String key = parseKey(distributedLock.key(), joinPoint);
        RLock lock = redissonClient.getLock("lock:" + key);
        
        try {
            boolean acquired = lock.tryLock(
                distributedLock.waitTime(), 
                distributedLock.leaseTime(), 
                TimeUnit.MILLISECONDS);
            
            if (!acquired) {
                throw new LockAcquisitionException("락 획득 실패: " + key);
            }
            
            return joinPoint.proceed();
            
        } finally {
            if (lock.isHeldByCurrentThread()) {
                lock.unlock();
            }
        }
    }
    
    private String parseKey(String keyExpression, ProceedingJoinPoint joinPoint) {
        // SpEL 파싱 로직
        // ...
    }
}

// 사용
@Service
public class CouponService {
    
    @DistributedLock(key = "'coupon:' + #couponId")
    public void issueCoupon(String userId, String couponId) {
        // 락이 자동으로 관리됨
    }
}
```

---

## DB 기반 분산 락

### 방식 1: SELECT FOR UPDATE

```java
@Repository
public interface ProductRepository extends JpaRepository<Product, String> {
    
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query("SELECT p FROM Product p WHERE p.id = :id")
    Optional<Product> findByIdWithLock(@Param("id") String id);
}

@Service
@RequiredArgsConstructor
public class StockService {
    private final ProductRepository productRepository;
    
    @Transactional
    public void decreaseStock(String productId, int quantity) {
        // 락 획득
        Product product = productRepository.findByIdWithLock(productId)
            .orElseThrow(() -> new ProductNotFoundException(productId));
        
        if (product.getStock() < quantity) {
            throw new InsufficientStockException("재고 부족");
        }
        
        product.decreaseStock(quantity);
        productRepository.save(product);
    }
}
```

### 방식 2: 락 테이블 사용

```sql
CREATE TABLE distributed_locks (
  lock_key VARCHAR(255) PRIMARY KEY,
  owner VARCHAR(255) NOT NULL,
  expires_at TIMESTAMP NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

```java
@Repository
public interface DistributedLockRepository extends JpaRepository<DistributedLockEntity, String> {
    
    @Modifying
    @Query("DELETE FROM DistributedLockEntity d WHERE d.expiresAt < :now")
    void deleteExpiredLocks(@Param("now") LocalDateTime now);
}

@Component
@RequiredArgsConstructor
public class DbLock {
    private final DistributedLockRepository lockRepository;
    
    @Transactional
    public boolean acquire(String key, String owner, int ttlSeconds) {
        LocalDateTime expiresAt = LocalDateTime.now().plusSeconds(ttlSeconds);
        
        // 만료된 락 정리
        lockRepository.deleteExpiredLocks(LocalDateTime.now());
        
        try {
            DistributedLockEntity lock = new DistributedLockEntity(key, owner, expiresAt);
            lockRepository.save(lock);
            return true;
        } catch (DataIntegrityViolationException e) {
            // 중복 키 에러 = 이미 락 존재
            return false;
        }
    }
    
    @Transactional
    public boolean release(String key, String owner) {
        int deleted = lockRepository.deleteByKeyAndOwner(key, owner);
        return deleted > 0;
    }
}
```

---

## ZooKeeper 기반 분산 락

강한 일관성이 필요할 때 사용

### Curator 라이브러리

```xml
<dependency>
    <groupId>org.apache.curator</groupId>
    <artifactId>curator-recipes</artifactId>
    <version>5.5.0</version>
</dependency>
```

```java
@Configuration
public class ZookeeperConfig {
    
    @Bean
    public CuratorFramework curatorFramework() {
        CuratorFramework client = CuratorFrameworkFactory.newClient(
            "localhost:2181",
            new ExponentialBackoffRetry(1000, 3));
        client.start();
        return client;
    }
}

@Service
@RequiredArgsConstructor
public class StockService {
    private final CuratorFramework curatorFramework;
    private final StockRepository stockRepository;
    
    public void decreaseStock(String productId, int quantity) {
        InterProcessMutex lock = new InterProcessMutex(
            curatorFramework, "/locks/stock/" + productId);
        
        try {
            if (lock.acquire(10, TimeUnit.SECONDS)) {
                try {
                    Stock stock = stockRepository.findById(productId).orElseThrow();
                    
                    if (stock.getQuantity() < quantity) {
                        throw new InsufficientStockException("재고 부족");
                    }
                    
                    stock.decrease(quantity);
                    stockRepository.save(stock);
                    
                } finally {
                    lock.release();
                }
            } else {
                throw new LockAcquisitionException("락 획득 실패");
            }
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}
```

---

## 락 비교

| 방식 | 장점 | 단점 | 적합한 상황 |
|------|------|------|-------------|
| Redis (단일) | 빠름, 간단 | 단일 장애점 | 속도 중요, 약간의 실패 허용 |
| Redlock | 고가용성 | 복잡, 논란 있음 | 중요한 작업, 다중 Redis 환경 |
| DB | 트랜잭션과 통합 | 느림 | DB 작업과 함께 사용 |
| ZooKeeper | 강한 일관성 | 운영 복잡 | 정확성 필수 |

---

## 주의 사항

### 1. TTL 설정

락에 반드시 만료 시간 설정 (데드락 방지)

```java
// 나쁜 예: TTL 없음
redisTemplate.opsForValue().setIfAbsent(lockKey, token);

// 좋은 예: TTL 설정
redisTemplate.opsForValue().setIfAbsent(lockKey, token, Duration.ofSeconds(10));
```

### 2. 락 갱신 (Lock Extension)

장시간 작업 시 락 만료 방지

```java
@Service
@RequiredArgsConstructor
public class LongRunningTaskService {
    private final RedissonClient redissonClient;
    
    public void doLongWork(String taskId) {
        RLock lock = redissonClient.getLock("lock:task:" + taskId);
        
        try {
            // Redisson은 자동으로 락을 갱신 (watchdog)
            lock.lock();
            
            // 장시간 작업 수행
            performLongRunningTask();
            
        } finally {
            lock.unlock();
        }
    }
}
```

### 3. Fencing Token

락 만료 후 이전 홀더가 작업 완료하는 문제 방지

```java
@Service
@RequiredArgsConstructor
public class FencingTokenService {
    private final RedisTemplate<String, String> redisTemplate;
    
    public long acquireWithFencingToken(String key) {
        // 락 획득 시 증가하는 토큰 발급
        Long fencingToken = redisTemplate.opsForValue()
            .increment("lock:fencing:" + key);
        return fencingToken;
    }
}

// 외부 시스템은 토큰이 더 큰 요청만 처리
public void processWithFencing(Request request) {
    if (request.getFencingToken() > currentToken) {
        processRequest(request);
        currentToken = request.getFencingToken();
    }
}
```

---

## 실전 예시

### 선착순 쿠폰 발급

```java
@Service
@RequiredArgsConstructor
public class CouponService {
    private final RedissonClient redissonClient;
    private final CouponRepository couponRepository;
    private final UserCouponRepository userCouponRepository;
    
    public void issueCoupon(String userId, String couponId) {
        RLock lock = redissonClient.getLock("lock:coupon:" + couponId);
        
        try {
            if (!lock.tryLock(5, 3, TimeUnit.SECONDS)) {
                throw new RuntimeException("잠시 후 다시 시도해주세요");
            }
            
            try {
                Coupon coupon = couponRepository.findById(couponId).orElseThrow();
                
                if (coupon.getRemaining() <= 0) {
                    throw new CouponExhaustedException("쿠폰이 모두 소진되었습니다");
                }
                
                userCouponRepository.save(new UserCoupon(userId, couponId));
                coupon.decrease();
                couponRepository.save(coupon);
                
            } finally {
                lock.unlock();
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RuntimeException(e);
        }
    }
}
```

### 중복 결제 방지

```java
@Service
@RequiredArgsConstructor
public class PaymentService {
    private final RedissonClient redissonClient;
    private final OrderRepository orderRepository;
    private final PaymentGateway paymentGateway;
    
    public void processPayment(String orderId, BigDecimal amount) {
        RLock lock = redissonClient.getLock("lock:payment:" + orderId);
        
        try {
            if (!lock.tryLock(5, 30, TimeUnit.SECONDS)) {
                throw new RuntimeException("결제가 이미 진행 중입니다");
            }
            
            try {
                Order order = orderRepository.findById(orderId).orElseThrow();
                
                if (order.getPaymentStatus() == PaymentStatus.COMPLETED) {
                    throw new AlreadyPaidException("이미 결제된 주문입니다");
                }
                
                paymentGateway.charge(amount);
                order.setPaymentStatus(PaymentStatus.COMPLETED);
                orderRepository.save(order);
                
            } catch (Exception e) {
                Order order = orderRepository.findById(orderId).orElseThrow();
                order.setPaymentStatus(PaymentStatus.FAILED);
                orderRepository.save(order);
                throw e;
            } finally {
                lock.unlock();
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RuntimeException(e);
        }
    }
}
```

---

## 핵심 요약

1. **목적**: 분산 환경에서 동시성 제어
2. **Redis**: 빠르고 간단, 대부분의 경우 적합
3. **Redisson**: Redis 기반 고급 기능 (자동 갱신, 재진입 등)
4. **DB**: 트랜잭션과 함께 사용, FOR UPDATE 또는 락 테이블
5. **주의**: TTL 필수, 갱신 로직, Fencing Token 고려
