연관된 엔티티를 조회할때, 쿼리가 예상보다 훨씬 많이 나가는 현상.

#### 예시
```java
@Entity
public class Team{
	@Id @GeneratedValue
	private Long id;
	
	@OneToMany(mappedBy= "team")
	private List<Member> members;
	
}
```

```java
List<Team> teams = teamRepository.findAll();// 쿼리 1번, members를 프록시 객체로 갖고있음

for (Team team : teams) {
	team.getMembers().size(); //팀마다 쿼리 1번씩 추가 , 이때 실제로 members를 조회하는 쿼리를 날림 
 }
```
#### 팀이 10개면?

- findAll() -> 1번
- 각팀의 members조회 ->10번
- 총 11번 (1+N)
---
#### 발생이유
JPA기본전략이 **지연로딩(LAZY)**라서, 연관 엔티티를 실제로 사용할 때 그제서야 쿼리를 날림.

---
### 해결방법

#### 1. Fetch Join
```java
@Query("SELECT t FROM Team t JOIN FETCH t.members")
List<Team> findAllWithMembers();
```
한번에 쿼리로 연관 데이터 까지 가져옴

---
#### 2. @EntityGraph
```java
// EntityGraph 방식 (Fetch Join 똑같은 결과)
@EntityGraph(attributePaths = {"members"}) 
List<Team> findAll();
```

### 3. Batch Size
```yaml
spring:
  jpa:
    properties:
      hibernate:
        default_batch_fetch_size: 100
```

IN 쿼리로 묶어서 가져옴. N번 → 1~2번으로 줄어듦.
```java
List<Team> teams = teamRepository.findAll(); // 쿼리 1번 
	for (Team team : teams) { 
		team.getMembers().size(); // 여기서 쿼리 나감 
	}
```

## Batch Size 동작 방식

`batch_size = 100` 이면:

**팀이 50개일 때**
```sql
SELECT * FROM team;  -- 1번
SELECT * FROM member WHERE team_id IN (1, 2, 3, ... 50);  -- 1번
```
총 2번.

**팀이 150개일 때**
```sql
SELECT * FROM team;  -- 1번
SELECT * FROM member WHERE team_id IN (1, 2, 3, ... 100);  -- 1번
SELECT * FROM member WHERE team_id IN (101, 102, ... 150);  -- 1번
``````
총 3번.


### 정리

| 용어  | 의미                                  |
| --- | ----------------------------------- |
| N+1 | 1번 조회 후 연관 데이터 N번 추가 조회             |
| 원인  | 지연 로딩(LAZY) + 반복문에서 접근              |
| 해결  | Fetch Join, EntityGraph, Batch Size |
보통 **Batch Size**를 글로벌로 깔아두고, 필요한 곳에서 **Fetch Join** 쓰는 조합이 많음

Fetch Join이 가장 확실 그러나 페이징이랑 같이 쓰면 문제 생길 수 있어서 상황 봐가면서 써야함 