엔티티를 관리하는 임시 저장소. JPA가 DB랑 애플리케이션 사이에서 엔티티를 캐싱하고 관리하는 공간

---
### 엔티티 생명주기

| 상태             | 설명                        |
| -------------- | ------------------------- |
| 비영속 (new)      | 그냥 new로 만든 객체. JPA랑 관계 없음 |
| 영속 (managed)   | 영속성 컨텍스트에 저장된 상태          |
| 준영속 (detached) | 영속성 컨텍스트에서 분리된 상태         |
| 삭제 (removed)   | 삭제 예정 상태                  |

```java
Member member = new Member(); // 비영속

em.persist(member); // 영속
em.detach(member); // 준영속
em.remove(member); // tkrwp
```
---


  

![1769498700551_image.png](https://claude.ai/api/4ade778d-ab57-4851-a857-717eae0f9f90/files/44936573-daf9-41bb-b554-3162bc539cdb/preview)

동시성 제어에 대해 알려줘

오후 4:25

동시성 제어(Concurrency Control)는 데이터베이스에서 여러 트랜잭션이 동시에 실행될 때 데이터의 일관성과 무결성을 보장하기 위한 기법입니다.

## 왜 필요한가?

여러 트랜잭션이 동시에 같은 데이터에 접근하면 다음과 같은 문제가 발생할 수 있습니다:

**Lost Update (갱신 손실)**: 두 트랜잭션이 동시에 같은 데이터를 수정할 때, 한 트랜잭션의 변경이 덮어씌워지는 현상

**Dirty Read (오손 읽기)**: 커밋되지 않은 데이터를 다른 트랜잭션이 읽는 현상

**Non-repeatable Read (비반복 읽기)**: 같은 트랜잭션 내에서 같은 데이터를 두 번 읽었을 때 값이 다른 현상

**Phantom Read (팬텀 읽기)**: 같은 조건으로 조회했는데 결과 행의 개수가 달라지는 현상

## 주요 기법

**1. 락(Lock) 기반**

- **공유 락(Shared Lock)**: 읽기 작업용, 여러 트랜잭션이 동시에 획득 가능
- **배타 락(Exclusive Lock)**: 쓰기 작업용, 하나의 트랜잭션만 획득 가능
- **2PL(Two-Phase Locking)**: 락 획득 단계와 해제 단계를 분리하여 직렬 가능성 보장

**2. 타임스탬프 기반**

- 각 트랜잭션에 타임스탬프를 부여하고, 이 순서대로 실행된 것처럼 결과를 보장

**3. MVCC (Multi-Version Concurrency Control)**

- 데이터의 여러 버전을 유지하여 읽기와 쓰기가 서로 차단하지 않도록 함
- PostgreSQL, MySQL InnoDB 등 대부분의 현대 DBMS가 사용

**4. 낙관적 동시성 제어**

- 충돌이 드물다고 가정하고, 커밋 시점에 충돌 여부를 검사하여 문제가 있으면 롤백

더 깊이 알고 싶은 부분이 있으면 말씀해 주세요.

음 JPA에는 낙관 비관락 이런것도있어서 어떤 카테고리별로 나눠숴 공부해야하나 모르겠음

오후 4:25

좋은 고민이에요. 동시성 제어를 공부할 때 계층별로 나눠서 정리하면 훨씬 명확해집니다.

## 계층별 정리

**1. DB 레벨 (이론/기초)**

- 트랜잭션 ACID
- 격리 수준 (Read Uncommitted → Serializable)
- Lock의 종류 (Shared/Exclusive)
- MVCC 개념
- 2PL, 타임스탬프 기반 등

**2. DB 레벨 (실무/구현)**

- MySQL, PostgreSQL 등 각 DBMS가 실제로 어떻게 구현하는지
- 예: MySQL InnoDB는 MVCC + 락 조합 사용

**3. 애플리케이션 레벨 (JPA/ORM)**

- **낙관적 락**: `@Version` 사용, 커밋 시점에 충돌 감지
- **비관적 락**: `LockModeType.PESSIMISTIC_WRITE` 등, DB 락을 직접 사용
- 이건 결국 DB 락을 애플리케이션에서 어떻게 제어하느냐의 문제

**4. 애플리케이션 레벨 (분산 환경)**

- Redis 분산 락, Redisson
- Zookeeper 등

## 공부 순서 제안

```
DB 이론 (격리수준, MVCC, Lock)
        ↓
사용하는 DBMS가 실제로 어떻게 동작하는지
        ↓
JPA 낙관적/비관적 락 (위 개념이 있어야 이해됨)
        ↓
분산 락 (필요시)
```

JPA의 낙관적/비관적 락은 결국 DB 개념 위에 얹어진 추상화예요. DB 레벨 개념을 먼저 잡으면 JPA가 왜 그렇게 동작하는지 자연스럽게 이해됩니다.

어느 부분부터 정리해볼까요?

보통 어떻게 공부하지?

동시성제어라는 카테고리안에 너가 말한 계층별로 나눠서 정리하나?

오후 4:27

사람마다 다르긴 한데, 제가 보기에 두 가지 방식이 있어요.

## 방식 1: 동시성 제어라는 주제로 묶기

```
동시성 제어
├── DB 이론
├── DBMS 구현
├── JPA 락
└── 분산 락
```

장점은 하나의 맥락에서 깊이 있게 파고들 수 있다는 것. 단점은 양이 많아지고, 실제로 DB/JPA/분산시스템은 다른 맥락에서도 계속 등장한다는 점이에요.

## 방식 2: 각 카테고리 안에 배치 (더 일반적)

```
Database
├── 트랜잭션
├── 격리 수준
├── Lock & MVCC     ← 여기
└── 인덱스, 정규화 등

JPA
├── 영속성 컨텍스트
├── 연관관계
├── 낙관적/비관적 락  ← 여기
└── N+1 등

분산 시스템 / Redis
├── 캐싱
├── 분산 락          ← 여기
└── ...
```

이게 더 흔한 방식이에요. 면접 준비나 실무에서도 "DB 질문", "JPA 질문" 이런 식으로 나뉘니까요.

## 제 생각

굳이 하나로 묶으려고 하기보다, **각 카테고리에서 정리하되 서로 연결된다는 걸 인지**하는 정도면 충분해요. 예를 들어 JPA 비관적 락 정리할 때 "이건 결국 DB의 SELECT FOR UPDATE다"라고 한 줄 메모해두는 식으로요.

지금 노트 구조 보니까 Database 카테고리가 있으니, 거기에 동시성 제어(Lock, MVCC) 넣고, JPA는 따로 만들어서 락 내용 넣는 게 자연스러울 것 같아요.

격리 수준은 뭐지?

오후 4:28

격리 수준(Isolation Level)은 동시에 실행되는 트랜잭션들이 서로 얼마나 영향을 주고받을 수 있는지를 정의한 것이에요.

## 왜 필요한가?

완벽한 격리(Serializable)를 하면 안전하지만 성능이 떨어지고, 격리를 느슨하게 하면 성능은 좋지만 데이터 정합성 문제가 생길 수 있어요. 그래서 상황에 맞게 선택할 수 있도록 단계를 나눠둔 거예요.

## 4가지 격리 수준 (낮음 → 높음)

|격리 수준|Dirty Read|Non-repeatable Read|Phantom Read|
|---|---|---|---|
|Read Uncommitted|O|O|O|
|Read Committed|X|O|O|
|Repeatable Read|X|X|O|
|Serializable|X|X|X|

**Read Uncommitted**: 커밋 안 된 데이터도 읽음. 거의 안 씀.

**Read Committed**: 커밋된 데이터만 읽음. Oracle 기본값. 같은 쿼리를 두 번 날리면 결과가 달라질 수 있음.

**Repeatable Read**: 트랜잭션 시작 시점의 스냅샷을 읽음. MySQL InnoDB 기본값. 같은 쿼리는 같은 결과 보장.

**Serializable**: 완전 직렬 실행처럼 동작. 가장 안전하지만 성능 비용 큼.

## 실무에서는

대부분 DBMS 기본값(Read Committed 또는 Repeatable Read)을 그대로 쓰고, 특정 상황에서만 락을 걸거나 격리 수준을 조정해요. 그래서 기본값이 뭔지, 각 수준에서 어떤 문제가 생길 수 있는지 아는 게 중요합니다.

백엔드 개발자가 이런것도 알아야하나

오후 4:28

네, 알아야 해요. 다만 DBA 수준으로 깊게는 아니고요.

## 왜 알아야 하나

실무에서 이런 상황이 생겨요:

- 동시에 주문이 들어왔는데 재고가 마이너스가 됨
- 두 명이 동시에 같은 쿠폰을 사용함
- 정산 로직에서 금액이 안 맞음

이런 문제가 터졌을 때 "동시성 문제인가?", "격리 수준 때문인가?", "락을 걸어야 하나?" 이런 판단을 백엔드 개발자가 해야 해요. 모르면 원인 파악 자체가 안 됩니다.

## 어느 정도까지?

**알아야 하는 것**

- 격리 수준 4가지와 각각 어떤 문제가 생길 수 있는지
- 사용하는 DB의 기본 격리 수준 (MySQL은 Repeatable Read 등)
- 낙관적/비관적 락 개념과 언제 쓰는지
- `SELECT FOR UPDATE`가 뭔지

**깊게 안 파도 되는 것**

- MVCC 내부 구현 (Undo 로그 구조 등)
- 락 에스컬레이션 세부 동작
- 데드락 탐지 알고리즘

면접에서도 자주 나오고, 실무에서 버그 터지면 결국 이 개념으로 돌아와요. 기초 정도는 확실히 잡아두는 게 좋습니다.

DBA 수준은 어디까지인데? 지금 거의 DBA 수준 아니야?

오후 4:29

아니요, 지금 얘기한 건 백엔드 개발자 기본 소양 수준이에요.

## 백엔드 개발자 수준 (지금 얘기한 것)

- 격리 수준 4가지 개념
- 락 종류와 언제 쓰는지
- MVCC가 뭔지 대략적으로
- JPA 락 사용법

## DBA 수준

**성능 튜닝**

- 실행 계획 분석하고 쿼리 최적화
- 인덱스 설계 및 통계 정보 관리
- 락 경합 모니터링하고 병목 찾기

**내부 구조**

- InnoDB 버퍼 풀, 리두 로그, 언두 로그 구조
- 페이지 단위 저장 방식
- 체크포인트, 리커버리 메커니즘

**운영**

- 레플리케이션 구성 (Master-Slave, 클러스터)
- 백업/복구 전략
- 파티셔닝, 샤딩 설계
- 장애 대응

**모니터링**

- slow query 분석
- 락 대기 현황 추적
- 커넥션 풀 튜닝

DBA는 "DB가 왜 느린지", "어떻게 하면 안 죽는지"를 책임지는 사람이에요. 지금 공부하는 건 그냥 "내 코드가 동시성 문제 안 일으키게 하려면 뭘 알아야 하나" 정도입니다.

![1769499018831_image.png](https://claude.ai/api/4ade778d-ab57-4851-a857-717eae0f9f90/files/75596911-0ed0-4e33-8bc4-5db6e6cf9b7d/preview)

방식 2로 정리할게 해당 사진에서 추가해야하나?

오후 4:30

트랜잭션 안에 넣으면 될 것 같아요.

## 제안

```
05.트랜잭션
├── ACID
├── 격리 수준
└── Lock & MVCC (동시성 제어)
```

격리 수준이나 락은 결국 트랜잭션의 특성(Isolation)을 어떻게 구현하느냐의 문제라서, 트랜잭션 하위에 두는 게 자연스러워요.

굳이 "동시성 제어"라는 별도 항목을 만들기보다, 트랜잭션 정리하면서 같이 다루는 게 흐름상 낫습니다.

너가 기재해주면 내가 쓰는게 공부가 잘되려나

오후 4:32

직접 쓰는 게 훨씬 나아요.

제가 정리해주면 "읽고 끝"이 되기 쉬운데, 직접 쓰면서 "이게 뭐였지?", "이 순서가 맞나?" 고민하는 과정이 진짜 공부거든요.

대신 제가 도울 수 있는 건:

- 헷갈릴 때 질문 받기
- 정리한 거 검토해주기
- 빠진 부분 있는지 확인

이 정도가 효과적일 것 같아요. 일단 트랜잭션 항목 정리해보고, 막히면 물어봐주세요.

아예 모르는데 뭘 적어

오후 4:32

그러면 제가 핵심만 짧게 설명할게요. 듣고 이해되는 부분만 본인 말로 정리하면 돼요.

## 트랜잭션

하나의 작업 단위. "다 되거나, 다 안 되거나"를 보장함.

예: 계좌이체 = 출금 + 입금. 둘 중 하나만 되면 안 되니까 하나로 묶음.

## ACID

트랜잭션이 지켜야 할 4가지 성질.

- **Atomicity**: 전부 성공 or 전부 실패
- **Consistency**: 실행 전후로 데이터 정합성 유지
- **Isolation**: 트랜잭션끼리 서로 간섭 안 함
- **Durability**: 커밋되면 영구 저장

## 격리 수준

Isolation을 얼마나 엄격하게 할지 정한 것. 4단계 있음. 높을수록 안전하지만 느림.

## Lock & MVCC

격리를 실제로 구현하는 방법. 락은 막는 것, MVCC는 버전 나눠서 읽는 것.

---

이 정도 흐름만 잡고, 각 항목 하나씩 파보면 돼요. 어디부터 정리해볼래요?

ㅂ하나의 작업 단위. 전부 성공하거나 전부 실패해야 함 --- 예시:계좌이체 철수 -> 영희에게 10만원 보내기 `sql UPDATE account SET balance = balance - 100000 WHERE name = '철수'; UPDATE account SET balance = balance + 100000 WHERE name = '영희';` 첫 번째만 실행되고 서버 터지면? 철수 돈만 사라짐 -> 둘 다 성공하거나, 둘 다 취소해야 함 -> 이걸 트랜잭션으로 묶음 `sql BEGIN; UPDATE account SET balance = balance - 100000 WHERE name = '철수'; UPDATE account SET balance = balance + 100000 WHERE name = '영희'; COMMIT;` 중간에 문제 생기면 ROLLBACK으로 전부 취소 --- ### ACID 트랜잭션이 지켜야 할 4가지 속성 |속성|의미| |---|---| |**A**tomicity (원자성)|전부 성공 or 전부 실패| |**C**onsistency (일관성)|트랜잭션 전후로 DB가 유효한 상태 유지| |**I**solation (격리성)|트랜잭션끼리 서로 간섭 안 함| |**D**urability (지속성)|커밋되면 영구 저장 (서버 꺼져도 유지)| ### COMMIT / ROLLBACK - **COMMIT**: 변경사항 확정 저장 - **ROLLBACK**: 변경사항 취소, 트랜잭션 시작 전으로 되돌림 `sql BEGIN; DELETE FROM user WHERE id = 1; -- 어 잘못했다 ROLLBACK; -- 삭제 취소됨` --- ### 정리 | 용어 | 의미 | | -------- | ------------------ | | 트랜잭션 | 하나의 작업 단위 | | COMMIT | 확정 | | ROLLBACK | 취소 | | ACID | 원자성, 일관성, 격리성, 지속성 |

다 있나

더 보기

오후 4:33

잘 정리했어요. 핵심은 다 있어요.

한 가지만 추가하면 좋을 것 같은 게, 격리성(Isolation) 부분이에요. 지금은 "트랜잭션끼리 서로 간섭 안 함"으로 끝났는데, 이게 아까 얘기한 격리 수준으로 이어지거든요.

---

### 격리 수준 (Isolation Level)

격리성을 얼마나 엄격하게 지킬지 정한 단계.

|수준|설명|
|---|---|
|Read Uncommitted|커밋 안 된 것도 읽음 (거의 안 씀)|
|Read Committed|커밋된 것만 읽음 (Oracle 기본)|
|Repeatable Read|트랜잭션 시작 시점 기준으로 읽음 (MySQL 기본)|
|Serializable|완전 직렬 실행처럼 동작 (가장 느림)|

높을수록 안전하지만 성능 비용 있음.

---

이거 추가하면 트랜잭션 → ACID → 격리 수준까지 흐름이 연결돼요.

Lock & MVCC는 "격리 수준을 어떻게 구현하는가"라서, 나중에 덧붙여도 되고요.

그냥 이렇게만 추가하면 된다고? 하나의 작업 단위. 전부 성공하거나 전부 실패해야 함 --- 예시:계좌이체 철수 -> 영희에게 10만원 보내기 `sql UPDATE account SET balance = balance - 100000 WHERE name = '철수'; UPDATE account SET balance = balance + 100000 WHERE name = '영희';` 첫 번째만 실행되고 서버 터지면? 철수 돈만 사라짐 -> 둘 다 성공하거나, 둘 다 취소해야 함 -> 이걸 트랜잭션으로 묶음 `sql BEGIN; UPDATE account SET balance = balance - 100000 WHERE name = '철수'; UPDATE account SET balance = balance + 100000 WHERE name = '영희'; COMMIT;` 중간에 문제 생기면 ROLLBACK으로 전부 취소 --- ### ACID 트랜잭션이 지켜야 할 4가지 속성 |속성|의미| |---|---| |**A**tomicity (원자성)|전부 성공 or 전부 실패| |**C**onsistency (일관성)|트랜잭션 전후로 DB가 유효한 상태 유지| |**I**solation (격리성)|트랜잭션끼리 서로 간섭 안 함| |**D**urability (지속성)|커밋되면 영구 저장 (서버 꺼져도 유지)| ### COMMIT / ROLLBACK - **COMMIT**: 변경사항 확정 저장 - **ROLLBACK**: 변경사항 취소, 트랜잭션 시작 전으로 되돌림 `sql BEGIN; DELETE FROM user WHERE id = 1; -- 어 잘못했다 ROLLBACK; -- 삭제 취소됨` --- ### 격리 수준 (Isolation Level) 격리성을 얼마나 엄격하게 지킬지 정한 단계. |수준|설명| |---|---| |Read Uncommitted|커밋 안 된 것도 읽음 (거의 안 씀)| |Read Committed|커밋된 것만 읽음 (Oracle 기본)| |Repeatable Read|트랜잭션 시작 시점 기준으로 읽음 (MySQL 기본)| |Serializable|완전 직렬 실행처럼 동작 (가장 느림)| 높을수록 안전하지만 성능 비용 있음. ### 정리 | 용어 | 의미 | | -------- | ------------------ | | 트랜잭션 | 하나의 작업 단위 | | COMMIT | 확정 | | ROLLBACK | 취소 | | ACID | 원자성, 일관성, 격리성, 지속성 |

더 보기

오후 4:34

네, 이 정도면 트랜잭션 기본 정리는 충분해요.

나중에 추가할 수 있는 것들:

- 각 격리 수준에서 발생할 수 있는 문제 (Dirty Read, Phantom Read 등)
- Lock & MVCC (격리 수준을 구현하는 방법)

근데 이건 지금 당장 안 넣어도 돼요. 필요할 때 붙이면 됩니다.

지금 정리한 거로 트랜잭션 기초는 잡힌 거예요.

| Read Uncommitted | 커밋 안 된 것도 읽음 (거의 안 씀) | | ---------------- | ----------------------------- | | Read Committed | 커밋된 것만 읽음 (Oracle 기본) | | Repeatable Read | 트랜잭션 시작 시점 기준으로 읽음 (MySQL 기본) | | Serializable | 완전 직렬 실행처럼 동작 (가장 느림) |

이런건 내가 선택할수있어? 어떻게 ? 그런걸 하나도 모르는데

오후 4:34

선택할 수 있어요. 근데 보통은 안 건드려요.

## 어떻게 설정하나

**DB 전체 기본값 설정**

sql

```sql
SET GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ;
```

**현재 세션만 변경**

sql

```sql
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
```

**Spring에서 특정 메서드만**

java

```java
@Transactional(isolation = Isolation.READ_COMMITTED)
public void something() {
    // ...
}
```

## 실무에서는

대부분 DB 기본값 그대로 씀. MySQL 쓰면 Repeatable Read, Oracle 쓰면 Read Committed.

굳이 바꾸는 경우는 특수한 상황 (정합성이 엄청 중요하거나, 반대로 성능이 급한 경우) 정도예요.

지금은 "설정할 수 있다" 정도만 알면 되고, 각 수준이 뭔지 이해하는 게 더 중요해요.

JPA ├── 영속성 컨텍스트 ├── 연관관계 ├── 낙관적/비관적 락 ← 여기 └── N+1 등

그럼 JPA는 이것들 다 정리해줘

오후 4:36

전부 다 한 번에 정리하면 양이 너무 많아요. 하나씩 가는 게 나아요.

어떤 것부터 할까요?

1. **영속성 컨텍스트** - JPA의 핵심 개념, 이거 모르면 나머지가 안 읽힘
2. **연관관계** - @OneToMany, @ManyToOne 같은 것
3. **N+1 문제** - 면접 단골, 실무에서 자주 터짐
4. **낙관적/비관적 락** - 아까 얘기한 동시성 제어

JPA 처음이면 1번부터 하는 게 맞고, 어느 정도 써봤으면 모르는 것부터 해도 돼요.

어디서부터 할래요?

1

오후 4:36

## 영속성 컨텍스트 (Persistence Context)

엔티티를 관리하는 임시 저장소. JPA가 DB랑 애플리케이션 사이에서 엔티티를 캐싱하고 관리하는 공간이에요.

---

### 엔티티 생명주기

|상태|설명|
|---|---|
|비영속 (new)|그냥 new로 만든 객체. JPA랑 관계 없음|
|영속 (managed)|영속성 컨텍스트에 저장된 상태|
|준영속 (detached)|영속성 컨텍스트에서 분리된 상태|
|삭제 (removed)|삭제 예정 상태|

java

```java
Member member = new Member();  // 비영속

em.persist(member);  // 영속

em.detach(member);   // 준영속

em.remove(member);   // 삭제
```

---

### 영속성 컨텍스트의 이점

**1차 캐시**
- 같은 트랙잭션 내에서 같은 엔티티 조회하면 DB안 가고 캐시에서 가져옴

```java
Member a = em.find(Member.class, 1L); // DB 조회
Member b = em.find(Member.class, 1L); // 캐시에서 가져옴
```
