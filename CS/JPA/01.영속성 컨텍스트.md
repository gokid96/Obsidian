## 영속성 컨텍스트 (Persistence Context)

엔티티를 관리하는 임시 저장소. `@Transactional` 안에서 JPA가 DB와 애플리케이션 사이에서 엔티티를 캐싱하고 관리하는 공간.

---

### 엔티티 생명주기

|상태|설명|
|---|---|
|비영속 (new)|new로 만든 객체. JPA와 관계 없음|
|영속 (managed)|영속성 컨텍스트에 저장된 상태|
|준영속 (detached)|영속성 컨텍스트에서 분리된 상태|
|삭제 (removed)|삭제 예정 상태. flush/commit 시 DELETE 실행|


```java
Member member = new Member();   // 비영속
em.persist(member);             // 영속
em.detach(member);              // 준영속
em.remove(member);              // 삭제
```

|EntityManager (순수 JPA)|Spring Data JPA (JpaRepository 상속)|
|---|---|
|`em.persist(member)`|`repository.save(member)`|
|`em.find(Member.class, id)`|`repository.findById(id)`|
|`em.remove(member)`|`repository.delete(member)`|
|`em.detach(member)`|직접 쓸 일 거의 없음|
|`em.flush()`|`repository.flush()` 또는 `saveAndFlush()`|

````java
public interface MemberRepository extends JpaRepository<Member, Long> {
}
MemberRepository
    ↓ 상속
JpaRepository
    ↓ 상속
PagingAndSortingRepository
    ↓ 상속
CrudRepository
    ↓ 상속
Repository
// 런타임에 Spring이 `SimpleJpaRepository`를 구현체로 자동 생성해서 주입 그 안에서 `EntityManager` 메서드들이 호출
````


---

### 영속/준영속 판단하는 법

기본적으로 `@Transactional` 범위로 판단

|상황|상태|
|---|---|
|@Transactional 안에서 조회/persist한 엔티티|영속|
|@Transactional 끝난 후|준영속|
|new로 만든 객체|비영속|
|em.remove() 호출한 엔티티|삭제|

```java
@Transactional
public void update(Long id) {
    Member member = memberRepository.findById(id).get();  // 영속 상태
    member.setName("변경");  // 변경 감지 동작
}  // 트랜잭션 끝 → flush → commit → 준영속

// @Transactional 없는 경우
public void noTx() {
    // findById 내부에 자체 트랜잭션 있음 → 조회 시점엔 영속
    // 하지만 findById 메서드 끝나면 트랜잭션 종료 → 준영속 상태로 반환
    Member member = memberRepository.findById(1L).get();
    
    // 이 시점에서 member는 이미 준영속
    member.getTeam().getName();  // LazyInitializationException 발생!
}
```

---

### 영속성 컨텍스트의 이점

**1차 캐시**

같은 트랜잭션 내에서 같은 엔티티 조회하면 DB 안 가고 캐시에서 가져옴

```java
Member a = em.find(Member.class, 1L);  // DB 조회
Member b = em.find(Member.class, 1L);  // 캐시에서 가져옴
System.out.println(a == b);  // true (같은 객체)
```

**변경 감지 (Dirty Checking)**

영속 상태 엔티티를 수정하면 알아서 UPDATE 쿼리 날림. 따로 save() 안 해도 됨

```java
@Transactional
public void update(Long id) {
    Member member = em.find(Member.class, id);
    member.setName("변경된 이름");
    // save() 호출 안 해도 트랜잭션 커밋 시점에 자동으로 UPDATE
}
```

**쓰기 지연 (Write-behind)**

persist() 해도 바로 INSERT 안 함. 커밋할 때 모아서 한 번에 보냄

```java
em.persist(member1);  // INSERT 쿼리 아직 안 나감
em.persist(member2);  // INSERT 쿼리 아직 안 나감
// 커밋 시점에 모아서 INSERT 2개 한 번에 실행
```

---

### flush vs commit

|구분|설명|
|---|---|
|flush|영속성 컨텍스트 변경사항을 DB에 반영 (쿼리 날림). 트랜잭션은 안 끝남|
|commit|flush + 트랜잭션 확정|

**flush 자동 발생 시점**

- 트랜잭션 커밋 직전
- JPQL 쿼리 실행 직전
- 직접 `em.flush()` 호출
```java
em.persist(member);
em.flush();  // INSERT 쿼리 DB로 날아감. 하지만 아직 확정 아님

// 여기서 예외 터지면?
em.getTransaction().rollback();  // INSERT 취소됨 (롤백)
```

---

### 정리

|용어|의미|
|---|---|
|영속성 컨텍스트|엔티티 관리하는 임시 저장소 (@Transactional 범위)|
|1차 캐시|같은 엔티티 또 조회하면 DB 안 감|
|변경 감지|영속 상태 엔티티 수정하면 자동 UPDATE|
|쓰기 지연|커밋할 때 모아서 쿼리 날림|
|flush|쿼리를 DB에 보내기만 함 (확정 X)|
|commit|flush + 트랜잭션 확정|