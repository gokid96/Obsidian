## 전체 구조

```
						사용자 (10만+ 동시접속)
						         │
						         ▼
						┌─────────────────┐
						│      CDN        │ ─── HTML, JS, CSS, 이미지 캐싱
						└────────┬────────┘
						         │
						         ▼
						┌─────────────────┐
						│   로드밸런서     │ ─── Rate Limiting, DDoS 방어
						└────────┬────────┘
						         │
						    ┌────┴────┐
						    │         │
						    ▼         ▼
						┌───────┐ ┌───────┐
						│대기열 │ │ 예매  │
						│API    │ │ API   │
						└───┬───┘ └───┬───┘
						    │         │
						    └────┬────┘
						         │
						         ▼
						┌─────────────────┐
						│  Redis Cluster  │ ─── 대기열, 좌석선점, 토큰
						└────────┬────────┘
						         │
						         ▼
						┌─────────────────┐
						│     Kafka       │ ─── 예매 이벤트 발행
						└────────┬────────┘
						         │
						         ▼
						┌─────────────────┐
						│     Worker      │ ─── Kafka Consumer
						└────────┬────────┘
						         │
						         ▼
						┌─────────────────┐
						│   PostgreSQL    │ ─── 예매 데이터 영구 저장
						└─────────────────┘
```

---

## 컴포넌트별 역할

### 1. CDN

- 정적 리소스 캐싱 (HTML, JS, CSS, 이미지)
- 서버 부하 감소

### 2. 로드밸런서 (Nginx/HAProxy)

- 트래픽 분산
- Rate Limiting
- DDoS 방어

### 3. 대기열 API 서버

|엔드포인트|역할|
|---|---|
|`POST /queue/enter`|대기열 진입|
|`GET /queue/status`|순번 확인 (폴링)|

### 4. 예매 API 서버

|엔드포인트|역할|
|---|---|
|`GET /seats`|좌석 현황 조회|
|`POST /seats/select`|좌석 선점|
|`POST /payment`|결제 처리|

### 5. Redis Cluster

|키 패턴|자료구조|용도|TTL|
|---|---|---|---|
|`queue:{eventId}`|Sorted Set|대기열 (시각순 정렬)|-|
|`active:{eventId}`|Set|현재 예매 중인 사용자|-|
|`entry:{userId}:{eventId}`|String|입장 토큰|10분|
|`seat:{eventId}:{seatId}`|String|좌석 임시 선점|10분|
|`confirmed:{eventId}:{seatId}`|String|좌석 확정|없음|

### 6. 스케줄러 (1초마다 실행)

1. 현재 활성 사용자 수 확인
2. 입장 가능 인원 계산 (최대 동시 수 - 현재 활성 수)
3. 대기열에서 N명 꺼내기
4. 입장 토큰 발급

### 7. Kafka

- 토픽: `booking-completed`
- 예매 완료 이벤트 발행
- 비동기로 DB 저장 처리

### 8. Worker (Kafka Consumer)

- 예매 정보 DB 저장
- 좌석 상태 업데이트

### 9. PostgreSQL

- 예매 내역 영구 저장
- Primary + Read Replicas 구성

---

## 데이터 흐름

### 1단계: 대기열 진입

```
사용자 → 대기열 API → Redis ZSet 등록
```

- `ZADD queue:event1 {timestamp} user1`

### 2단계: 대기 중 (폴링)

```
브라우저 JS (2초마다) → 대기열 API → Redis 순번 조회
```

- `ZRANK queue:event1 user1`

### 3단계: 입장 처리

```
스케줄러 → Redis에서 N명 꺼내기 → 입장 토큰 발급
```

- `ZRANGE queue:event1 0 199`
- `ZREM queue:event1 user1`
- `SADD active:event1 user1`
- `SET entry:user1:event1 {token} EX 600`

### 4단계: 좌석 선점 (Lua 스크립트)

```
사용자 → 예매 API → Redis Lua 스크립트 (원자적)
```

```lua
local holder = redis.call('GET', seat_key)
if holder then
    return 'FAIL'
end
redis.call('SET', seat_key, user_id, 'EX', 600)
return 'OK'
```

### 5단계: 결제 + 확정

```
사용자 → 예매 API → PG사 결제 → Kafka 발행 → Worker → DB 저장
```

---

## 핵심 설계 원칙

|원칙|설명|
|---|---|
|**DB 보호**|대기열로 트래픽 제어, Redis가 1차 방어선|
|**동시성 제어**|Lua 스크립트로 원자적 좌석 선점 (중복 예매 방지)|
|**비동기 처리**|Kafka로 DB 저장 분리 (API 응답 속도 확보)|
|**자동 해제**|Redis TTL로 미결제 좌석 자동 반환|

---

## 확장 전략

|구분|평상시|티켓 오픈 시|
|---|---|---|
|API 서버|3대|30대 (Auto Scaling)|
|대기열 서버|2대|10대|
|Redis|3대 (Cluster)|6대 (Cluster)|
|DB Read Replica|2대|5대|
|Worker|5대|20대|