## 분산 락이란?

여러 서버/프로세스에서 동시에 같은 자원에 접근하는 것을 방지하는 동기화 메커니즘

---

## 왜 필요한가?

### 문제: 동시성 이슈

```
[서버 1] 재고 조회: 10개
[서버 2] 재고 조회: 10개
[서버 1] 재고 차감: 10 - 1 = 9
[서버 2] 재고 차감: 10 - 1 = 9  (잘못된 결과)

→ 실제로 2개 판매, 재고는 9개 (8개여야 함)
```

### 분산 락 적용

```
[서버 1] 락 획득 → 재고 조회: 10개 → 차감: 9개 → 락 해제
[서버 2] 락 대기..........................→ 락 획득 → 재고 조회: 9개 → 차감: 8개 → 락 해제
```

---

## Redis 기반 분산 락

### 기본 구현 (SETNX)

```typescript
class RedisLock {
  constructor(private redis: Redis) {}
  
  async acquire(key: string, ttl: number = 10000): Promise<string | null> {
    const token = crypto.randomUUID();
    const lockKey = `lock:${key}`;
    
    const result = await this.redis.set(
      lockKey,
      token,
      'PX', ttl,    // 만료 시간 (ms)
      'NX'          // 키가 없을 때만 설정
    );
    
    return result === 'OK' ? token : null;
  }
  
  async release(key: string, token: string): Promise<boolean> {
    const lockKey = `lock:${key}`;
    
    // Lua 스크립트로 원자적 실행 (본인 락만 해제)
    const script = `
      if redis.call("get", KEYS[1]) == ARGV[1] then
        return redis.call("del", KEYS[1])
      else
        return 0
      end
    `;
    
    const result = await this.redis.eval(script, 1, lockKey, token);
    return result === 1;
  }
}
```

### 사용 예시

```typescript
const lock = new RedisLock(redisClient);

async function decreaseStock(productId: string, quantity: number) {
  const lockKey = `stock:${productId}`;
  const token = await lock.acquire(lockKey, 5000);
  
  if (!token) {
    throw new Error('락 획득 실패');
  }
  
  try {
    const stock = await getStock(productId);
    if (stock < quantity) {
      throw new Error('재고 부족');
    }
    await setStock(productId, stock - quantity);
  } finally {
    await lock.release(lockKey, token);
  }
}
```

---

## Redlock 알고리즘

Redis 단일 노드 장애에 대비한 분산 락 알고리즘

### 동작 방식

```
[클라이언트]
     │
     ├─→ [Redis 1] 락 시도
     ├─→ [Redis 2] 락 시도
     ├─→ [Redis 3] 락 시도
     ├─→ [Redis 4] 락 시도
     └─→ [Redis 5] 락 시도

과반수 (3개 이상) 성공 → 락 획득 성공
```

### 구현

```typescript
class Redlock {
  constructor(private clients: Redis[], private retryCount = 3) {}
  
  async acquire(key: string, ttl: number): Promise<{ token: string; validUntil: number } | null> {
    const token = crypto.randomUUID();
    const lockKey = `lock:${key}`;
    
    for (let attempt = 0; attempt < this.retryCount; attempt++) {
      const startTime = Date.now();
      let successCount = 0;
      
      // 모든 노드에 락 시도
      const results = await Promise.all(
        this.clients.map(client => 
          client.set(lockKey, token, 'PX', ttl, 'NX')
            .then(r => r === 'OK')
            .catch(() => false)
        )
      );
      
      successCount = results.filter(r => r).length;
      
      const elapsed = Date.now() - startTime;
      const validity = ttl - elapsed - 2;  // 드리프트 보정
      
      // 과반수 성공 + 유효 시간 남음
      if (successCount >= Math.floor(this.clients.length / 2) + 1 && validity > 0) {
        return { token, validUntil: Date.now() + validity };
      }
      
      // 실패 시 모든 노드에서 해제
      await this.releaseAll(lockKey, token);
      
      // 재시도 전 랜덤 대기
      await sleep(Math.random() * 200);
    }
    
    return null;
  }
  
  private async releaseAll(lockKey: string, token: string): Promise<void> {
    const script = `
      if redis.call("get", KEYS[1]) == ARGV[1] then
        return redis.call("del", KEYS[1])
      else
        return 0
      end
    `;
    
    await Promise.all(
      this.clients.map(client => 
        client.eval(script, 1, lockKey, token).catch(() => {})
      )
    );
  }
}
```

### Redlock 라이브러리 사용

```typescript
import Redlock from 'redlock';

const redlock = new Redlock(
  [redis1, redis2, redis3],
  {
    retryCount: 3,
    retryDelay: 200,
    retryJitter: 100
  }
);

async function processOrder(orderId: string) {
  let lock;
  
  try {
    lock = await redlock.acquire([`order:${orderId}`], 5000);
    
    // 작업 수행
    await doWork();
    
  } catch (error) {
    if (error instanceof Redlock.LockError) {
      console.log('락 획득 실패');
    }
    throw error;
  } finally {
    if (lock) {
      await lock.release();
    }
  }
}
```

---

## DB 기반 분산 락

### 방식 1: SELECT FOR UPDATE

```sql
BEGIN;
SELECT * FROM products WHERE id = 1 FOR UPDATE;
-- 다른 트랜잭션은 여기서 대기
UPDATE products SET stock = stock - 1 WHERE id = 1;
COMMIT;
```

```typescript
async function decreaseStockWithDbLock(productId: string, quantity: number) {
  await db.transaction(async (trx) => {
    // 락 획득
    const product = await trx('products')
      .where('id', productId)
      .forUpdate()
      .first();
    
    if (product.stock < quantity) {
      throw new Error('재고 부족');
    }
    
    await trx('products')
      .where('id', productId)
      .update({ stock: product.stock - quantity });
  });
}
```

### 방식 2: 락 테이블 사용

```sql
CREATE TABLE distributed_locks (
  lock_key VARCHAR(255) PRIMARY KEY,
  owner VARCHAR(255) NOT NULL,
  expires_at TIMESTAMP NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

```typescript
class DbLock {
  async acquire(key: string, owner: string, ttlSeconds: number): Promise<boolean> {
    const expiresAt = new Date(Date.now() + ttlSeconds * 1000);
    
    try {
      // 만료된 락 정리
      await db('distributed_locks')
        .where('expires_at', '<', new Date())
        .delete();
      
      // 락 시도
      await db('distributed_locks').insert({
        lock_key: key,
        owner,
        expires_at: expiresAt
      });
      
      return true;
    } catch (error) {
      // 중복 키 에러 = 이미 락 존재
      return false;
    }
  }
  
  async release(key: string, owner: string): Promise<boolean> {
    const deleted = await db('distributed_locks')
      .where({ lock_key: key, owner })
      .delete();
    
    return deleted > 0;
  }
}
```

---

## ZooKeeper 기반 분산 락

강한 일관성이 필요할 때 사용

### 동작 방식

```
/locks/my-lock
    ├── lock-0000000001  (클라이언트 A)
    ├── lock-0000000002  (클라이언트 B)
    └── lock-0000000003  (클라이언트 C)

순서:
1. 클라이언트가 Sequential Ephemeral 노드 생성
2. 자신이 가장 작은 번호면 락 획득
3. 아니면 바로 앞 번호 노드 watch
4. 앞 노드 삭제되면 락 획득 시도
```

### Curator 라이브러리 (Java)

```java
CuratorFramework client = CuratorFrameworkFactory.newClient(
    "localhost:2181",
    new ExponentialBackoffRetry(1000, 3)
);
client.start();

InterProcessMutex lock = new InterProcessMutex(client, "/locks/my-lock");

try {
    if (lock.acquire(10, TimeUnit.SECONDS)) {
        try {
            // 작업 수행
            doWork();
        } finally {
            lock.release();
        }
    }
} catch (Exception e) {
    // 에러 처리
}
```

---

## 락 비교

| 방식 | 장점 | 단점 | 적합한 상황 |
|------|------|------|-------------|
| Redis (단일) | 빠름, 간단 | 단일 장애점 | 속도 중요, 약간의 실패 허용 |
| Redlock | 고가용성 | 복잡, 논란 있음 | 중요한 작업, 다중 Redis 환경 |
| DB | 트랜잭션과 통합 | 느림 | DB 작업과 함께 사용 |
| ZooKeeper | 강한 일관성 | 운영 복잡 | 정확성 필수 |

---

## 주의 사항

### 1. TTL 설정

락에 반드시 만료 시간 설정 (데드락 방지)

```typescript
// 나쁜 예: TTL 없음
await redis.set(lockKey, token, 'NX');

// 좋은 예: TTL 설정
await redis.set(lockKey, token, 'NX', 'PX', 10000);
```

### 2. 락 갱신 (Lock Extension)

장시간 작업 시 락 만료 방지

```typescript
async function doLongWork() {
  const token = await lock.acquire(key, 10000);
  
  // 백그라운드에서 락 갱신
  const interval = setInterval(async () => {
    await lock.extend(key, token, 10000);
  }, 5000);
  
  try {
    await longRunningTask();
  } finally {
    clearInterval(interval);
    await lock.release(key, token);
  }
}
```

### 3. 재진입 (Reentrancy)

같은 클라이언트가 락을 중복 획득해야 할 때

```typescript
class ReentrantLock {
  private counts = new Map<string, number>();
  
  async acquire(key: string, owner: string): Promise<boolean> {
    const countKey = `${key}:${owner}`;
    const current = this.counts.get(countKey) || 0;
    
    if (current > 0) {
      this.counts.set(countKey, current + 1);
      return true;
    }
    
    const acquired = await this.redis.set(key, owner, 'NX', 'PX', 10000);
    if (acquired) {
      this.counts.set(countKey, 1);
      return true;
    }
    
    return false;
  }
  
  async release(key: string, owner: string): Promise<boolean> {
    const countKey = `${key}:${owner}`;
    const current = this.counts.get(countKey) || 0;
    
    if (current > 1) {
      this.counts.set(countKey, current - 1);
      return true;
    }
    
    this.counts.delete(countKey);
    return await this.releaseFromRedis(key, owner);
  }
}
```

### 4. Fencing Token

락 만료 후 이전 홀더가 작업 완료하는 문제 방지

```typescript
// 락 획득 시 증가하는 토큰 발급
const fencingToken = await redis.incr('lock:fencing:stock');

// 외부 시스템에 토큰 전달
await storageService.write(data, { fencingToken });

// 외부 시스템은 토큰이 더 큰 요청만 처리
if (request.fencingToken > currentToken) {
  processRequest(request);
  currentToken = request.fencingToken;
}
```

---

## 실전 예시

### 선착순 쿠폰 발급

```typescript
async function issueCoupon(userId: string, couponId: string) {
  const lockKey = `coupon:${couponId}`;
  const token = await lock.acquire(lockKey, 5000);
  
  if (!token) {
    throw new Error('잠시 후 다시 시도해주세요');
  }
  
  try {
    const coupon = await getCoupon(couponId);
    
    if (coupon.remaining <= 0) {
      throw new Error('쿠폰이 모두 소진되었습니다');
    }
    
    await issueCouponToUser(userId, couponId);
    await decreaseCouponCount(couponId);
    
  } finally {
    await lock.release(lockKey, token);
  }
}
```

### 중복 결제 방지

```typescript
async function processPayment(orderId: string, amount: number) {
  const lockKey = `payment:${orderId}`;
  const token = await lock.acquire(lockKey, 30000);
  
  if (!token) {
    throw new Error('결제가 이미 진행 중입니다');
  }
  
  try {
    const order = await getOrder(orderId);
    
    if (order.paymentStatus === 'COMPLETED') {
      throw new Error('이미 결제된 주문입니다');
    }
    
    await paymentGateway.charge(amount);
    await updateOrderStatus(orderId, 'COMPLETED');
    
  } catch (error) {
    await updateOrderStatus(orderId, 'FAILED');
    throw error;
  } finally {
    await lock.release(lockKey, token);
  }
}
```

---

## 핵심 요약

1. **목적**: 분산 환경에서 동시성 제어
2. **Redis**: 빠르고 간단, 대부분의 경우 적합
3. **Redlock**: Redis 클러스터 환경의 고가용성 락
4. **DB**: 트랜잭션과 함께 사용, FOR UPDATE 또는 락 테이블
5. **주의**: TTL 필수, 갱신 로직, Fencing Token 고려

---
