## 샤딩이란?

데이터를 여러 DB 서버에 수평으로 분할하여 저장하는 기법

---

## 왜 필요한가?

### 단일 DB의 한계

```
[단일 DB]
- 데이터 10억 건
- 디스크 용량 한계
- 쿼리 성능 저하
- 단일 장애점
```

### 샤딩 적용

```
[샤드 1] 데이터 A~G    (3.3억 건)
[샤드 2] 데이터 H~P    (3.3억 건)
[샤드 3] 데이터 Q~Z    (3.3억 건)

→ 각 서버 부하 분산, 병렬 처리 가능
```

---

## 파티셔닝 vs 샤딩

| 항목 | 파티셔닝 | 샤딩 |
|------|----------|------|
| 범위 | 단일 DB 내 테이블 분할 | 여러 DB 서버로 분할 |
| 목적 | 쿼리 성능, 관리 편의 | 확장성, 부하 분산 |
| 복잡도 | 낮음 | 높음 |

---

## 샤딩 전략

### 1. 범위 기반 샤딩 (Range-based)

값의 범위로 샤드 결정

```
user_id 1 ~ 1,000,000       → 샤드 1
user_id 1,000,001 ~ 2,000,000 → 샤드 2
user_id 2,000,001 ~ 3,000,000 → 샤드 3
```

**구현**

```java
@Component
public class RangeShardRouter {
    
    public String getShard(long userId) {
        if (userId <= 1_000_000) return "shard1";
        if (userId <= 2_000_000) return "shard2";
        return "shard3";
    }
}
```

| 장점 | 단점 |
|------|------|
| 범위 쿼리 효율적 | 핫스팟 가능 (최근 데이터에 집중) |
| 구현 간단 | 데이터 불균형 |

**적합한 경우**: 시계열 데이터, 날짜 기반 조회 많을 때

---

### 2. 해시 기반 샤딩 (Hash-based)

키의 해시값으로 샤드 결정

```
hash(user_id) % 3 = 샤드 번호

hash(1) % 3 = 1  → 샤드 1
hash(2) % 3 = 2  → 샤드 2
hash(3) % 3 = 0  → 샤드 0
```

**구현**

```java
@Component
public class HashShardRouter {
    private final int shardCount;
    
    public HashShardRouter(@Value("${shard.count}") int shardCount) {
        this.shardCount = shardCount;
    }
    
    public int getShard(long userId) {
        // 일관된 해시 결과를 위해 절대값 사용
        int hash = Long.hashCode(userId);
        return Math.abs(hash) % shardCount;
    }
}
```

| 장점     | 단점             |
| ------ | -------------- |
| 균등 분배  | 범위 쿼리 비효율      |
| 핫스팟 방지 | 샤드 추가 시 재분배 필요 |

**적합한 경우**: 균등 분배 중요, 단건 조회 위주

---

### 3. 디렉토리 기반 샤딩 (Directory-based)

별도 매핑 테이블로 샤드 결정

```
[라우팅 테이블]
user_id | shard
--------|-------
1       | shard1
2       | shard3
3       | shard2
```

**구현**

```java
@Service
@RequiredArgsConstructor
public class DirectoryShardRouter {
    private final ShardRoutingRepository routingRepository;
    
    public String getShard(long userId) {
        return routingRepository.findById(userId)
            .map(ShardRouting::getShardName)
            .orElseThrow(() -> new ShardNotFoundException(userId));
    }
    
    public String assignShard(long userId) {
        // 가장 여유로운 샤드에 할당
        String shard = findLeastLoadedShard();
        routingRepository.save(new ShardRouting(userId, shard));
        return shard;
    }
    
    private String findLeastLoadedShard() {
        // 샤드별 데이터 수 조회 후 가장 적은 샤드 반환
        return routingRepository.findLeastLoadedShard();
    }
}
```

| 장점 | 단점 |
|------|------|
| 유연한 분배 | 라우팅 테이블 관리 필요 |
| 재분배 쉬움 | 단일 장애점 가능 |

---

### 4. Consistent Hashing

샤드 추가/제거 시 최소한의 데이터만 재분배

```
       0
       │
    ┌──┴──┐
   30    350
    │     │
샤드A   샤드C
    │     │
   120   280
    │     │
 샤드B     │

hash(key) → 링에서 시계 방향으로 첫 번째 샤드
```

**구현**

```java
@Component
public class ConsistentHashRouter {
    private final TreeMap<Long, String> ring = new TreeMap<>();
    private final int virtualNodes;
    
    public ConsistentHashRouter(@Value("${shard.virtual-nodes:100}") int virtualNodes) {
        this.virtualNodes = virtualNodes;
    }
    
    public void addNode(String node) {
        for (int i = 0; i < virtualNodes; i++) {
            long hash = hash(node + ":" + i);
            ring.put(hash, node);
        }
    }
    
    public void removeNode(String node) {
        for (int i = 0; i < virtualNodes; i++) {
            long hash = hash(node + ":" + i);
            ring.remove(hash);
        }
    }
    
    public String getNode(String key) {
        if (ring.isEmpty()) {
            throw new IllegalStateException("No nodes in ring");
        }
        
        long hash = hash(key);
        
        // 시계 방향으로 첫 번째 노드 찾기
        Map.Entry<Long, String> entry = ring.ceilingEntry(hash);
        if (entry == null) {
            entry = ring.firstEntry();
        }
        
        return entry.getValue();
    }
    
    private long hash(String key) {
        try {
            MessageDigest md = MessageDigest.getInstance("MD5");
            byte[] digest = md.digest(key.getBytes());
            return ByteBuffer.wrap(digest).getLong();
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException(e);
        }
    }
}
```

| 장점 | 단점 |
|------|------|
| 재분배 최소화 | 구현 복잡 |
| 노드 추가/제거 용이 | 불균형 가능 (가상 노드로 완화) |

---

## 샤드 키 선택

### 좋은 샤드 키 조건

1. **높은 카디널리티**: 다양한 값 (좋음: user_id, 나쁨: 성별)
2. **균등 분배**: 특정 값에 치우치지 않음
3. **자주 사용**: 대부분 쿼리에서 사용하는 키

### 예시

| 도메인 | 좋은 샤드 키 | 나쁜 샤드 키 |
|--------|--------------|--------------|
| SNS | user_id | 생성일 (최근에 집중) |
| 이커머스 | customer_id | 상품 카테고리 |
| 채팅 | room_id | 메시지 타입 |
| 로그 | timestamp (범위) | 로그 레벨 |

---

## Cross-Shard 문제

### 문제: 여러 샤드에 걸친 조회

```sql
-- user_id로 샤딩했는데, 이메일로 조회해야 함
SELECT * FROM users WHERE email = 'test@example.com';
-- 어느 샤드에 있는지 모름
```

### 해결: 글로벌 인덱스 테이블

```java
@Entity
@Table(name = "user_email_index")
public class UserEmailIndex {
    @Id
    private String email;
    private Long userId;
    private String shardName;
}

@Service
@RequiredArgsConstructor
public class UserService {
    private final UserEmailIndexRepository indexRepository;
    private final ShardDataSourceRouter dataSourceRouter;
    
    public User findByEmail(String email) {
        // 글로벌 인덱스에서 샤드 찾기
        UserEmailIndex index = indexRepository.findById(email)
            .orElseThrow(() -> new UserNotFoundException(email));
        
        // 해당 샤드에서 조회
        DataSource shard = dataSourceRouter.getDataSource(index.getShardName());
        return queryUser(shard, index.getUserId());
    }
}
```

### 해결: Scatter-Gather

모든 샤드에 쿼리 후 결과 병합

```java
@Service
@RequiredArgsConstructor
public class UserSearchService {
    private final List<DataSource> shards;
    private final ExecutorService executor;
    
    public List<User> searchUsers(String query) {
        // 모든 샤드에 병렬 쿼리
        List<CompletableFuture<List<User>>> futures = shards.stream()
            .map(shard -> CompletableFuture.supplyAsync(
                () -> queryUsers(shard, query), executor))
            .collect(Collectors.toList());
        
        // 결과 병합
        return futures.stream()
            .map(CompletableFuture::join)
            .flatMap(List::stream)
            .collect(Collectors.toList());
    }
}
```

---

## Join 문제

### 문제: 다른 샤드 간 Join 불가

### 해결: 비정규화

자주 필요한 데이터를 복사

```java
@Entity
public class Order {
    @Id
    private Long id;
    private Long userId;
    private Long productId;
    
    // 비정규화된 데이터
    private String productName;
    private BigDecimal productPrice;
}
```

### 해결: 애플리케이션 레벨 Join

```java
@Service
@RequiredArgsConstructor
public class OrderService {
    private final OrderRepository orderRepository;
    private final ProductService productService;
    
    public OrderWithProduct getOrderWithProduct(Long orderId) {
        // 1. 주문 조회 (주문 샤드)
        Order order = orderRepository.findById(orderId).orElseThrow();
        
        // 2. 상품 조회 (상품 샤드)
        Product product = productService.findById(order.getProductId());
        
        // 3. 애플리케이션에서 결합
        return new OrderWithProduct(order, product);
    }
}
```

---

## 실전 구성

### 다중 DataSource 설정

```java
@Configuration
public class ShardDataSourceConfig {
    
    @Bean
    @ConfigurationProperties("spring.datasource.shard1")
    public DataSource shard1DataSource() {
        return DataSourceBuilder.create().build();
    }
    
    @Bean
    @ConfigurationProperties("spring.datasource.shard2")
    public DataSource shard2DataSource() {
        return DataSourceBuilder.create().build();
    }
    
    @Bean
    @ConfigurationProperties("spring.datasource.shard3")
    public DataSource shard3DataSource() {
        return DataSourceBuilder.create().build();
    }
    
    @Bean
    public DataSource routingDataSource(
            @Qualifier("shard1DataSource") DataSource shard1,
            @Qualifier("shard2DataSource") DataSource shard2,
            @Qualifier("shard3DataSource") DataSource shard3) {
        
        Map<Object, Object> targetDataSources = new HashMap<>();
        targetDataSources.put("shard1", shard1);
        targetDataSources.put("shard2", shard2);
        targetDataSources.put("shard3", shard3);
        
        ShardRoutingDataSource routingDataSource = new ShardRoutingDataSource();
        routingDataSource.setTargetDataSources(targetDataSources);
        routingDataSource.setDefaultTargetDataSource(shard1);
        
        return routingDataSource;
    }
}

public class ShardRoutingDataSource extends AbstractRoutingDataSource {
    
    @Override
    protected Object determineCurrentLookupKey() {
        return ShardContextHolder.getCurrentShard();
    }
}

public class ShardContextHolder {
    private static final ThreadLocal<String> currentShard = new ThreadLocal<>();
    
    public static void setCurrentShard(String shard) {
        currentShard.set(shard);
    }
    
    public static String getCurrentShard() {
        return currentShard.get();
    }
    
    public static void clear() {
        currentShard.remove();
    }
}
```

### 사용

```java
@Service
@RequiredArgsConstructor
public class UserService {
    private final HashShardRouter shardRouter;
    private final UserRepository userRepository;
    
    public User findById(long userId) {
        int shardIndex = shardRouter.getShard(userId);
        ShardContextHolder.setCurrentShard("shard" + shardIndex);
        
        try {
            return userRepository.findById(userId).orElseThrow();
        } finally {
            ShardContextHolder.clear();
        }
    }
}
```

---

## 샤딩 vs 복제 (Replication)

| 항목 | 샤딩 | 복제 |
|------|------|------|
| 목적 | 쓰기 확장, 용량 확장 | 읽기 확장, 고가용성 |
| 데이터 | 분할 저장 | 전체 복사 |
| 복잡도 | 높음 | 낮음 |

**조합 사용**

```
[샤드 1] ─ Primary ─ Replica
[샤드 2] ─ Primary ─ Replica
[샤드 3] ─ Primary ─ Replica
```

---

## 언제 샤딩을 하는가?

### 샤딩 전에 먼저 시도할 것

1. 쿼리 최적화
2. 인덱스 추가
3. 읽기 복제본 (Read Replica)
4. 캐싱
5. 수직 확장 (스펙 업그레이드)

### 샤딩 고려 시점

- 단일 DB 용량 한계 도달
- 쓰기 부하가 복제로 해결 안 됨
- 쿼리 성능이 인덱스로 해결 안 됨

---

## 핵심 요약

1. **샤딩 = 수평 분할**: 여러 DB 서버에 데이터 분산
2. **전략**: 범위 기반, 해시 기반, 디렉토리 기반, Consistent Hashing
3. **샤드 키**: 카디널리티 높고, 균등 분배되는 키 선택
4. **문제점**: Cross-shard 쿼리, Join, 트랜잭션
5. **마지막 수단**: 다른 최적화 먼저 시도 후 적용
