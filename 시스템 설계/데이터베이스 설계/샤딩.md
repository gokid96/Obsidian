## 샤딩이란?

데이터를 여러 DB 서버에 수평으로 분할하여 저장하는 기법

---

## 왜 필요한가?

### 단일 DB의 한계

```
[단일 DB]
- 데이터 10억 건
- 디스크 용량 한계
- 쿼리 성능 저하
- 단일 장애점
```

### 샤딩 적용

```
[샤드 1] 데이터 A~G    (3.3억 건)
[샤드 2] 데이터 H~P    (3.3억 건)
[샤드 3] 데이터 Q~Z    (3.3억 건)

→ 각 서버 부하 분산, 병렬 처리 가능
```

---

## 파티셔닝 vs 샤딩

| 항목 | 파티셔닝 | 샤딩 |
|------|----------|------|
| 범위 | 단일 DB 내 테이블 분할 | 여러 DB 서버로 분할 |
| 목적 | 쿼리 성능, 관리 편의 | 확장성, 부하 분산 |
| 복잡도 | 낮음 | 높음 |

---

## 샤딩 전략

### 1. 범위 기반 샤딩 (Range-based)

값의 범위로 샤드 결정

```
user_id 1 ~ 1,000,000       → 샤드 1
user_id 1,000,001 ~ 2,000,000 → 샤드 2
user_id 2,000,001 ~ 3,000,000 → 샤드 3
```

**구현**

```typescript
function getShard(userId: number): string {
  if (userId <= 1_000_000) return 'shard1';
  if (userId <= 2_000_000) return 'shard2';
  return 'shard3';
}
```

| 장점 | 단점 |
|------|------|
| 범위 쿼리 효율적 | 핫스팟 가능 (최근 데이터에 집중) |
| 구현 간단 | 데이터 불균형 |

**적합한 경우**: 시계열 데이터, 날짜 기반 조회 많을 때

---

### 2. 해시 기반 샤딩 (Hash-based)

키의 해시값으로 샤드 결정

```
hash(user_id) % 3 = 샤드 번호

hash(1) % 3 = 1  → 샤드 1
hash(2) % 3 = 2  → 샤드 2
hash(3) % 3 = 0  → 샤드 0
```

**구현**

```typescript
import { createHash } from 'crypto';

function getShard(userId: number, shardCount: number): number {
  const hash = createHash('md5')
    .update(userId.toString())
    .digest('hex');
  const hashNum = parseInt(hash.substring(0, 8), 16);
  return hashNum % shardCount;
}
```

| 장점 | 단점 |
|------|------|
| 균등 분배 | 범위 쿼리 비효율 |
| 핫스팟 방지 | 샤드 추가 시 재분배 필요 |

**적합한 경우**: 균등 분배 중요, 단건 조회 위주

---

### 3. 디렉토리 기반 샤딩 (Directory-based)

별도 매핑 테이블로 샤드 결정

```
[라우팅 테이블]
user_id | shard
--------|-------
1       | shard1
2       | shard3
3       | shard2
```

**구현**

```typescript
class ShardRouter {
  constructor(private routingDb: Database) {}
  
  async getShard(userId: number): Promise<string> {
    const result = await this.routingDb.query(
      'SELECT shard FROM routing WHERE user_id = ?',
      [userId]
    );
    return result.shard;
  }
  
  async assignShard(userId: number): Promise<string> {
    const shard = await this.getLeastLoadedShard();
    await this.routingDb.query(
      'INSERT INTO routing (user_id, shard) VALUES (?, ?)',
      [userId, shard]
    );
    return shard;
  }
}
```

| 장점 | 단점 |
|------|------|
| 유연한 분배 | 라우팅 테이블 관리 필요 |
| 재분배 쉬움 | 단일 장애점 가능 |

---

### 4. Consistent Hashing

샤드 추가/제거 시 최소한의 데이터만 재분배

```
       0
       │
    ┌──┴──┐
   30    350
    │     │
샤드A   샤드C
    │     │
   120   280
    │     │
 샤드B   │

hash(key) → 링에서 시계 방향으로 첫 번째 샤드
```

**동작**

```
hash("user1") = 50  → 샤드B (120 방향)
hash("user2") = 200 → 샤드C (280 방향)

샤드D(150) 추가 시:
- user1(50)은 여전히 샤드B
- 120~150 범위만 샤드D로 이동
```

| 장점 | 단점 |
|------|------|
| 재분배 최소화 | 구현 복잡 |
| 노드 추가/제거 용이 | 불균형 가능 (가상 노드로 완화) |

---

## 샤드 키 선택

### 좋은 샤드 키 조건

1. **높은 카디널리티**: 다양한 값 (좋음: user_id, 나쁨: 성별)
2. **균등 분배**: 특정 값에 치우치지 않음
3. **자주 사용**: 대부분 쿼리에서 사용하는 키

### 예시

| 도메인  | 좋은 샤드 키        | 나쁜 샤드 키      |
| ---- | -------------- | ------------ |
| SNS  | user_id        | 생성일 (최근에 집중) |
| 이커머스 | customer_id    | 상품 카테고리      |
| 채팅   | room_id        | 메시지 타입       |
| 로그   | timestamp (범위) | 로그 레벨        |

---

## Cross-Shard 문제

### 문제: 여러 샤드에 걸친 조회

```sql
-- user_id로 샤딩했는데, 이메일로 조회해야 함
SELECT * FROM users WHERE email = 'test@example.com';
-- 어느 샤드에 있는지 모름
```

### 해결: 글로벌 인덱스 테이블

```
[글로벌 인덱스]
email             | user_id | shard
------------------|---------|-------
test@example.com  | 12345   | shard2
```

### 해결: Scatter-Gather

모든 샤드에 쿼리 후 결과 병합

```typescript
async function searchUsers(query: string) {
  const results = await Promise.all(
    shards.map(shard => shard.query(query))
  );
  return results.flat();
}
```

---

## Join 문제

### 문제: 다른 샤드 간 Join 불가

### 해결: 비정규화

자주 필요한 데이터를 복사

```typescript
// orders 테이블에 product 정보 포함
{
  order_id: 1,
  product_name: '상품명',     // 복사
  product_price: 10000        // 복사
}
```

### 해결: 애플리케이션 레벨 Join

```typescript
async function getOrderWithProduct(orderId: number) {
  const order = await orderShard.findById(orderId);
  const product = await productShard.findById(order.product_id);
  return { ...order, product };
}
```

---

## 실전 구성

```typescript
class ShardManager {
  private shards: Map<number, Database> = new Map();
  
  getShardForUser(userId: number): Database {
    const shardIndex = userId % this.shards.size;
    return this.shards.get(shardIndex)!;
  }
  
  async queryAllShards<T>(query: string): Promise<T[]> {
    const results = await Promise.all(
      Array.from(this.shards.values()).map(shard => shard.query<T>(query))
    );
    return results.flat();
  }
}
```

---

## 샤딩 vs 복제 (Replication)

| 항목 | 샤딩 | 복제 |
|------|------|------|
| 목적 | 쓰기 확장, 용량 확장 | 읽기 확장, 고가용성 |
| 데이터 | 분할 저장 | 전체 복사 |
| 복잡도 | 높음 | 낮음 |

**조합 사용**

```
[샤드 1] ─ Primary ─ Replica
[샤드 2] ─ Primary ─ Replica
[샤드 3] ─ Primary ─ Replica
```

---

## 언제 샤딩을 하는가?

### 샤딩 전에 먼저 시도할 것

1. 쿼리 최적화
2. 인덱스 추가
3. 읽기 복제본 (Read Replica)
4. 캐싱
5. 수직 확장 (스펙 업그레이드)

### 샤딩 고려 시점

- 단일 DB 용량 한계 도달
- 쓰기 부하가 복제로 해결 안 됨
- 쿼리 성능이 인덱스로 해결 안 됨

---

## 핵심 요약

1. **샤딩 = 수평 분할**: 여러 DB 서버에 데이터 분산
2. **전략**: 범위 기반, 해시 기반, 디렉토리 기반, Consistent Hashing
3. **샤드 키**: 카디널리티 높고, 균등 분배되는 키 선택
4. **문제점**: Cross-shard 쿼리, Join, 트랜잭션
5. **마지막 수단**: 다른 최적화 먼저 시도 후 적용

---
