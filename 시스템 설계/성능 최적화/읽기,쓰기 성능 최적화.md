### 읽기/쓰기 비율에 따른 전략
대부분의 서비스는 읽기가 훨씬 많음

| 서비스        | 읽기:쓰기 비율 | 전략                 |
| ---------- | -------- | ------------------ |
| **뉴스,블로그** | 99:1     | 읽기 최적화 집중 (캐싱,CDN) |
| **SNS**    | 80:20    | 읽기 중심 + 쓰기 비동기처리   |
| **채팅,게임**  | 50:50    | 둘다 중요, CQRS 고려     |
| **로그수집**   | 10:90    | 쓰기 최적화 집중 (배치,샤딩)  |

서비스 비율 먼저 파악하고 최적화 방향 결정

---

# 읽기 성능

### 프론트엔드

- 브라우저 캐싱 (Cache-Control, ETag)
- CDN으로 정적 리소스 배포
- 이미지 lazy loading
- 무한 스크롤 / 페이지네이션
- 코드 스플리팅
- 데이터 프리페칭
- 로컬 스토리지 / IndexedDB 캐싱
- Virtual scroll
### 네트워크 (프론트 ↔ 백엔드)

- CDN 활용
- HTTP/2, HTTP/3 멀티플렉싱
- 응답 압축 (gzip, brotli)
- Keep-alive 연결
- DNS 프리페칭
- 캐시 헤더 설정
### 백엔드

- 인메모리 캐시 (Redis, Memcached)
- 응답 캐싱
- Connection pooling
- 비동기 / 논블로킹 I/O
- 페이지네이션 / 커서 기반 조회
- GraphQL
- Read replica 라우팅
- 결과 압축
### 네트워크 (백엔드 ↔ DB)

- Connection pooling
- Prepared statement 캐싱
- 결과셋 스트리밍
- 지리적으로 가까운 replica 라우팅
### 데이터베이스

- 적절한 인덱스 설계
- 커버링 인덱스
- 쿼리 실행 계획 분석 (EXPLAIN)
- SELECT 필요한 컬럼만
- N+1 문제 해결
- Read replica
- 파티셔닝
- 쿼리 캐시
- Materialized View
### 스토리지

- SSD 사용
- 순차 읽기 유도
- RAID 구성
- OS 페이지 캐시 활용
- 파일 시스템 블록 크기 최적화

---
# 쓰기 성능

### 프론트엔드

- Debounce / Throttle
- Optimistic UI
- 오프라인 큐잉
- 폼 데이터 로컬 임시 저장
- 배치 요청
### 네트워크 (프론트 ↔ 백엔드)

- 요청 배치로 라운드트립 감소
- 페이로드 압축
- 재시도 및 백오프 전략
- WebSocket으로 실시간 통신
### 백엔드

- 메시지 큐 (Kafka, RabbitMQ)
- 배치 처리
- Write-behind 캐싱
- 이벤트 기반 아키텍처
- 샤딩
- 트랜잭션 최소화
- CQRS 패턴
### 네트워크 (백엔드 ↔ DB)

- Connection pooling
- 배치 쿼리 전송
- 비동기 복제
- 네트워크 타임아웃 튜닝
### 데이터베이스

- 과도한 인덱스 제거
- Bulk insert / Batch update
- 트랜잭션 짧게 유지
- 락 경합 최소화
- 파티셔닝
- 비동기 복제
- WAL 튜닝
- 정규화/비정규화 균형
### 스토리지

- 순차 쓰기 유도 (LSM Tree)
- Write buffer
- 저널링 모드 조정
- I/O 스케줄러 튜닝
- fsync 최소화

---


## 요약

| 구분     | 핵심 전략                                 |
| ------ | ------------------------------------- |
| **읽기** | Web(CDN), App(캐싱), DB(복제/인덱싱) 계층별 최적화 |
| **쓰기** | App(비동기 큐), DB(샤딩/배치 처리) 부하 분산        |


>  최적화 전 **병목 지점 파악**이 먼저, 
>  **읽기/쓰기 트레이드오프** 고려 필수