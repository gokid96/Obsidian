Service Discovery는 **MSA 환경에서 서비스의 위치(IP, 포트)를 자동으로 찾아주는 메커니즘**이다. Eureka, Consul, Kubernetes DNS 등으로 구현한다.

---

## 문제 상황

```java
// 주문 서비스 → 재고 서비스 호출
restTemplate.post("http://192.168.0.10:8080/inventory/deduct", order);
```

MSA에서는 서비스 인스턴스가 동적으로 변한다:
```
재고 서비스 스케일 아웃
  - 192.168.0.10:8080 (기존)
  - 192.168.0.11:8080 (신규)
  - 192.168.0.12:8080 (신규)

재고 서비스 장애로 재시작
  - 192.168.0.10:8080 → 192.168.0.55:8080 (IP 변경)
```

**IP 하드코딩하면 망한다.**

---

## 해결: Service Discovery

서비스가 자신의 위치를 **등록**하고, 호출하는 쪽은 이름으로 **조회**한다.
```
┌─────────────────────────────────────────────────────────────┐
│                    Service Registry                         │
│                  (Eureka, Consul 등)                        │
│                                                             │
│   inventory-service:                                        │
│     - 192.168.0.10:8080                                    │
│     - 192.168.0.11:8080                                    │
│     - 192.168.0.12:8080                                    │
└─────────────────────────────────────────────────────────────┘
        ▲                               │
        │ 1. 등록                        │ 2. 조회
        │                               ▼
┌───────────────┐               ┌───────────────┐
│ Inventory     │               │ Order         │
│ Service       │               │ Service       │
└───────────────┘               └───────────────┘
```

---

## 동작 흐름
```
1. 서비스 시작 시 Registry에 등록
   inventory-service → "나 192.168.0.10:8080 이야"

2. 주기적으로 heartbeat 전송
   inventory-service → Registry (30초마다 "나 살아있어")

3. 호출 시 Registry에서 조회
   order-service → "inventory-service 어디야?"
   Registry → "192.168.0.10, 192.168.0.11, 192.168.0.12"

4. 서비스 종료 시 등록 해제
   inventory-service 종료 → Registry에서 제거
````

---

## 구현체 비교: Eureka vs Consul

|항목|Eureka|Consul|
|---|---|---|
|만든 곳|Netflix|HashiCorp|
|주 용도|Service Discovery 전용|Service Discovery + Config + Health Check|
|Health Check|클라이언트가 heartbeat 전송|Consul이 직접 서비스 체크|
|언어|Java (Spring 생태계)|Go (언어 무관)|
|추가 기능|없음|Key-Value 저장소, DNS 인터페이스|

---

## 코드 예시: Eureka

### Eureka Server (Registry)

```java
@SpringBootApplication
@EnableEurekaServer
public class EurekaServerApplication {
    public static void main(String[] args) {
        SpringApplication.run(EurekaServerApplication.class, args);
    }
}
```

```yaml
# application.yml
server:
  port: 8761

eureka:
  client:
    registerWithEureka: false  # 자기 자신은 등록 안 함
    fetchRegistry: false
```

### 서비스 등록 (Eureka Client)

```java
@SpringBootApplication
@EnableEurekaClient
public class InventoryServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(InventoryServiceApplication.class, args);
    }
}
```

```yaml
# application.yml
spring:
  application:
    name: inventory-service  # 이 이름으로 등록됨

eureka:
  client:
    serviceUrl:
      defaultZone: http://localhost:8761/eureka/
```

### 서비스 호출

```java
@Service
public class OrderService {
    
    @Autowired
    private RestTemplate restTemplate;
    
    public void deductInventory(Order order) {
        // IP 대신 서비스 이름으로 호출
        restTemplate.post("http://inventory-service/deduct", order);
    }
}

@Configuration
public class RestTemplateConfig {
    
    @Bean
    @LoadBalanced  // 서비스 이름 → IP 변환 + 로드밸런싱
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}
```

---

## 코드 예시: Consul

### 서비스 등록

```yaml
# application.yml
spring:
  application:
    name: inventory-service
  cloud:
    consul:
      host: localhost
      port: 8500
      discovery:
        service-name: inventory-service
        health-check-path: /actuator/health
        health-check-interval: 10s
```

### 서비스 호출

```java
@Service
public class OrderService {
    
    @Autowired
    @LoadBalanced
    private RestTemplate restTemplate;
    
    public void deductInventory(Order order) {
        // Eureka랑 동일하게 서비스 이름으로 호출
        restTemplate.post("http://inventory-service/deduct", order);
    }
}
```

### Health Check 방식 차이
```
Eureka: 서비스 → Registry (heartbeat 전송)
Consul: Consul → 서비스 (직접 /actuator/health 호출)
```

---

## Client-Side vs Server-Side Discovery

### Client-Side Discovery (Eureka, Consul 방식)
```
클라이언트가 직접 Registry 조회 → 로드밸런싱도 클라이언트가

Order Service → Registry 조회 → IP 목록 받음 → 직접 선택해서 호출
```

### Server-Side Discovery (Kubernetes 방식)
```
로드밸런서가 중간에서 처리

Order Service → 로드밸런서/DNS → 알아서 라우팅
````

|방식|장점|단점|
|---|---|---|
|**Client-Side**|로드밸런서 병목 없음|클라이언트 복잡|
|**Server-Side**|클라이언트 단순|로드밸런서 병목 가능|

---

## Kubernetes 환경에서는

Kubernetes는 **자체 Service Discovery**를 제공한다:

```yaml
# Kubernetes Service
apiVersion: v1
kind: Service
metadata:
  name: inventory-service
spec:
  selector:
    app: inventory
  ports:
    - port: 8080
```

```java
// 그냥 서비스 이름으로 호출하면 됨
restTemplate.post("http://inventory-service:8080/deduct", order);
```

Kubernetes DNS가 알아서 IP 변환 + 로드밸런싱 해줌.
→ **Eureka, Consul 없이도 됨**

---

## Health Check

Registry는 죽은 서비스를 목록에서 제거해야 한다:
```
inventory-service (192.168.0.10) → heartbeat 전송 중단
                                         ↓
                                   30초 대기
                                         ↓
                               Registry에서 제거
                                         ↓
                    Order Service가 조회하면 목록에 없음
````

```yaml
# Eureka 설정
eureka:
  instance:
    leaseRenewalIntervalInSeconds: 10     # heartbeat 주기
    leaseExpirationDurationInSeconds: 30  # 이 시간 동안 heartbeat 없으면 제거
```

---

## 언제 뭘 쓰나

| 상황                      | 선택                    |
| ----------------------- | --------------------- |
| Spring Cloud 생태계        | Eureka                |
| 멀티 언어 환경 (Go, Python 등) | Consul                |
| Config 서버도 필요           | Consul (Key-Value 내장) |
| Kubernetes 환경           | 둘 다 안 써도 됨 (K8s DNS)  |

---

## 장단점

|장점|단점|
|---|---|
|IP 하드코딩 불필요|Registry 장애 시 문제|
|동적 스케일링 대응|설정 복잡도 증가|
|자동 장애 감지|네트워크 오버헤드 (heartbeat)|

---

## 관련 개념

- [[01. Microservices Architecture (기본 개념)]]
- [[02. API Gateway (진입점 관리)]]
- [[Circuit Breaker Pattern]]
- [[Load Balancing]]

---

## Tags

#ServiceDiscovery #MSA #Eureka #Consul #Kubernetes #로드밸런싱