
Database per Service는 **각 마이크로서비스가 자신만의 독립된 DB를 가지는 패턴**이다. MSA의 핵심 원칙 중 하나로, 서비스 간 데이터 독립성을 보장한다.

---

## 왜 필요한가?

### Shared Database (안티패턴)

```
┌─────────────┐  ┌─────────────┐  ┌─────────────┐
│ Order       │  │ Inventory   │  │ User        │
│ Service     │  │ Service     │  │ Service     │
└──────┬──────┘  └──────┬──────┘  └──────┬──────┘
       │                │                │
       └────────────────┼────────────────┘
                        ▼
              ┌─────────────────┐
              │   하나의 DB      │
              │                 │
              │ - orders        │
              │ - inventory     │
              │ - users         │
              └─────────────────┘
```

**문제점:**

- 한 서비스가 다른 서비스 테이블 직접 접근 → 강결합
- 스키마 변경 시 다른 서비스에 영향
- 특정 서비스 트래픽 증가 → DB 전체 부하
- 서비스별 독립 배포 불가능

---

## 해결: Database per Service

```
┌─────────────┐  ┌─────────────┐  ┌─────────────┐
│ Order       │  │ Inventory   │  │ User        │
│ Service     │  │ Service     │  │ Service     │
└──────┬──────┘  └──────┬──────┘  └──────┬──────┘
       │                │                │
       ▼                ▼                ▼
┌─────────────┐  ┌─────────────┐  ┌─────────────┐
│ Order DB    │  │ Inventory DB│  │ User DB     │
│             │  │             │  │             │
│ - orders    │  │ - products  │  │ - users     │
│ - order_items│ │ - stock     │  │ - addresses │
└─────────────┘  └─────────────┘  └─────────────┘
```

---

## 다른 서비스 데이터가 필요하면?

### 1. API 호출

```java
@Service
public class OrderService {
    
    @Autowired
    private UserServiceClient userClient;  // Feign Client
    
    public Order createOrder(Long userId, OrderRequest request) {
        // User DB 직접 접근 ❌
        // User Service API 호출 ✅
        User user = userClient.getUser(userId);
        
        Order order = new Order(user.getName(), request.getItems());
        return orderRepository.save(order);
    }
}
```

### 2. 이벤트로 데이터 동기화

````java
// User Service: 유저 생성 시 이벤트 발행
@Transactional
public void createUser(UserRequest request) {
    User user = userRepository.save(new User(request));
    outboxRepository.save(new UserCreatedEvent(user));
}

// Order Service: 이벤트 수신하여 로컬에 저장
@KafkaListener(topics = "user-events")
public void handleUserCreated(UserCreatedEvent event) {
    // 필요한 정보만 로컬 DB에 저장
    orderUserRepository.save(new OrderUser(event.getUserId(), event.getName()));
}
```
```
User Service                     Order Service
     │                                │
     │  UserCreatedEvent              │
     ├───────────────────────────────▶│
     │                                │
     │                                ▼
     │                     ┌─────────────────┐
     │                     │ Order DB        │
     │                     │ - order_users   │ ← 필요한 정보만 복제
     │                     └─────────────────┘
````

---

## 조인이 필요하면?

**못 함.** 다른 DB라서.

### 해결 방법

|방법|설명|예시|
|---|---|---|
|API 조합|각 서비스 호출 후 애플리케이션에서 조합|API Gateway, BFF|
|데이터 복제|필요한 데이터 로컬에 동기화|이벤트 기반|
|CQRS|읽기 전용 통합 DB 구성|조회용 별도 서비스|

```java
// API Gateway에서 조합
public OrderDetailResponse getOrderDetail(Long orderId) {
    Order order = orderService.getOrder(orderId);
    User user = userService.getUser(order.getUserId());
    List<Product> products = inventoryService.getProducts(order.getProductIds());
    
    return new OrderDetailResponse(order, user, products);  // 조합
}
```

---

## 트랜잭션은?

**분산 트랜잭션 불가.** 다른 DB라서.

```java
// 이거 안 됨
@Transactional
public void createOrder(OrderRequest request) {
    orderRepository.save(order);           // Order DB
    inventoryRepository.deduct(productId); // Inventory DB ← 다른 DB라 롤백 안 됨
}
```

### 해결: Saga 패턴
```
Order Service          Inventory Service          Payment Service
     │                        │                         │
     │ 1. 주문 생성            │                         │
     ├───────────────────────▶│                         │
     │                        │ 2. 재고 차감             │
     │                        ├────────────────────────▶│
     │                        │                         │ 3. 결제
     │                        │                         │
     │                   실패 시 보상 트랜잭션             │
     │◀───────────────────────┼─────────────────────────┤
```

---

## 장단점

| 장점 | 단점 |
|------|------|
| 서비스 독립성 | 조인 불가 |
| 독립 배포 가능 | 분산 트랜잭션 복잡 |
| 서비스별 DB 최적화 가능 | 데이터 일관성 관리 어려움 |
| 장애 격리 | 운영 복잡도 증가 |

---

## Polyglot Persistence

서비스마다 **다른 종류의 DB**를 쓸 수 있음:
```
Order Service     → MySQL (관계형, 트랜잭션)
Product Service   → MongoDB (유연한 스키마)
Search Service    → Elasticsearch (검색 최적화)
Session Service   → Redis (빠른 읽기/쓰기)
````

---

## 관련 개념

- [[01. Microservices Architecture (기본 개념)]]
- [[01. Saga Pattern (분산 트랜잭션 기본)]]
- [[02. CQRS (읽기,쓰기 분리)]]
- [[03. Outbox Pattern (해결책)]]

---

## Tags

#DatabasePerService #MSA #데이터관리 #분산시스템 #PolyglotPersistence