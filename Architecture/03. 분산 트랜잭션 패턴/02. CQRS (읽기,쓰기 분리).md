CQRS는 **명령(Command)과 조회(Query)를 분리하는 패턴**이다.
읽기가 많고 조회 성능 최적화가 필요할 때 사용한다.

---

## 구조

```
          Client
             │
   ┌─────────┴─────────┐
   ▼                   ▼
┌────────┐        ┌────────┐
│Command │        │ Query  │
│ (쓰기) │        │ (읽기) │
└───┬────┘        └───┬────┘
    ▼                 ▼
┌────────┐        ┌────────┐
│Write DB│ ─동기화→│Read DB │
│(정규화) │        │(비정규화)│
└────────┘        └────────┘
```

**일반 방식:** 조회 시 여러 테이블 조인 → 느림
**CQRS:** 쓰기 시점에 미리 조인해서 Read DB 저장 → 조회는 가져오기만 → 빠름

---

## 구현 단계

**1단계: 코드만 분리**
- CommandService / QueryService 분리
- 같은 DB, 같은 테이블
- 구조 정리 + 확장 준비

**2단계: 테이블 분리**
- orders (쓰기, 정규화) / order_summaries (읽기, 비정규화)
- 조회 성능 최적화 시작

**3단계: DB 분리**
- Write DB (MySQL) / Read DB (Redis, Elasticsearch)
- Kafka로 동기화

보통 1단계로 시작 → 병목 생기면 2단계 → 그래도 안 되면 3단계

---

## 동기화 방식

**이벤트 기반 (비동기)**
```
Write DB 저장 → Kafka → Read DB 업데이트
```

**같은 트랜잭션 (동기)**
```java
@Transactional
public void createOrder() {
    orderRepository.save(order);
    orderSummaryRepository.save(summary);
}
```

---

## 언제 쓰나?

| 적합 | 부적합 |
|------|--------|
| 읽기 90%, 쓰기 10% | 단순 CRUD |
| 조회 성능 중요 | |
| 복잡한 도메인 | |

---

## 장단점

| 장점 | 단점 |
|------|------|
| 읽기/쓰기 각각 최적화 | 복잡도 증가 |
| 조회 성능 향상 | 동기화 관리 필요 |

---

## 관련 개념

- [[03. Event Sourcing (이력 저장)]]
- [[01. Saga Pattern (분산 트랜잭션 기본)]]

---

## Tags

#CQRS #읽기쓰기분리 #성능최적화
