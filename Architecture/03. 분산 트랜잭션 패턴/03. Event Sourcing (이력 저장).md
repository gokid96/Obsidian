Event Sourcing은 **현재 상태 대신 상태 변경 이벤트를 저장하는 패턴**
모든 변경 내역을 보존해야 할 때 사용 (금융 거래, 감사 로그, 시점 복원)

---

## 일반 방식 vs Event Sourcing

```
일반 방식:
┌─────────┐
│ balance │ = 500원 (현재 상태만)
└─────────┘

Event Sourcing:
┌──────────────────────────┐
│ Created    → 0원         │
│ Deposited  → +1000원     │
│ Withdrawn  → -500원      │
│ ────────────────────     │
│ 현재 상태  → 500원        │
└──────────────────────────┘
```

현재 잔액 = 이벤트를 순서대로 재생하면 나옴.

---

## 코드 예시

```java
// 상태 변경 대신 이벤트 저장
public void withdraw(String accountId, int amount) {
    eventStore.append(accountId, new MoneyWithdrawn(accountId, amount));
}

// 현재 상태 조회 (이벤트 재생)
public Account getAccount(String accountId) {
    List<Event> events = eventStore.getEvents(accountId);
    Account account = new Account();
    for (Event e : events) {
        account.apply(e);
    }
    return account;
}
```

---

## Snapshot

이벤트가 많으면 매번 재생하기 느림 → 중간중간 스냅샷 저장

```
이벤트 1~1000 → Snapshot (balance: 50000)
이벤트 1001~현재 → 여기부터만 재생
```

---

## CQRS와 함께

Event Sourcing만 쓰면 조회 시 이벤트 재생 필요 → 느림

```
Event Sourcing (Write) + CQRS (Read)

쓰기: 이벤트 저장 → Kafka 발행
읽기: Read DB에서 바로 조회 → 빠름
```

---

## 언제 쓰나?

| 적합 | 부적합 |
|------|--------|
| 변경 이력 추적 필수 (금융, 의료) | 단순 CRUD |
| 감사 로그 필요 | |
| 시점 복원/버그 재현 | |

---

## 장단점

| 장점 | 단점 |
|------|------|
| 완벽한 변경 이력 | 복잡도 증가 |
| 시점 복원 가능 | 조회 성능 (CQRS로 보완) |
| 버그 재현 가능 | 이벤트 스키마 변경 어려움 |

---

## 관련 개념

- [[02. CQRS (읽기,쓰기 분리)]]
- [[01. Event-Driven Architecture (기본 개념)]]

---

## Tags

#EventSourcing #이벤트저장 #감사로그 #이력관리
