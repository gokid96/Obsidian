Database per Service는 **각 마이크로서비스가 자신만의 독립된 DB를 가지는 패턴**
MSA 핵심 원칙 중 하나.

---

## Shared DB vs Database per Service

```
Shared DB (안티패턴):
┌─────────┐ ┌─────────┐ ┌─────────┐
│ Order   │ │Inventory│ │  User   │
└────┬────┘ └────┬────┘ └────┬────┘
     └───────────┼───────────┘
                 ▼
          ┌──────────┐
          │ 하나의 DB │  ← 강결합, 스키마 변경 시 영향
          └──────────┘

Database per Service:
┌─────────┐ ┌─────────┐ ┌─────────┐
│ Order   │ │Inventory│ │  User   │
└────┬────┘ └────┬────┘ └────┬────┘
     ▼           ▼           ▼
┌────────┐ ┌─────────┐ ┌────────┐
│Order DB│ │Inventory│ │User DB │  ← 독립적
└────────┘ │   DB    │ └────────┘
           └─────────┘
```

---

## 다른 서비스 데이터가 필요하면?

**1. API 호출**
```java
User user = userClient.getUser(userId);  // Feign Client
```

**2. 이벤트로 데이터 동기화**
```java
// User Service → 이벤트 발행
// Order Service → 이벤트 수신 → 필요한 정보만 로컬 저장
```

---

## 조인이 필요하면?

**못 함.** 다른 DB라서.

| 해결 방법 | 설명 |
|----------|------|
| API 조합 | 각 서비스 호출 후 조합 |
| 데이터 복제 | 필요한 데이터만 이벤트로 동기화 |
| CQRS | 읽기 전용 통합 DB |

---

## 트랜잭션은?

**분산 트랜잭션 불가.** 다른 DB라서.

→ **Saga 패턴**으로 해결

---

## Polyglot Persistence

서비스마다 다른 종류의 DB 사용 가능:
```
Order Service   → MySQL
Search Service  → Elasticsearch
Session Service → Redis
```

---

## 장단점

| 장점 | 단점 |
|------|------|
| 서비스 독립성 | 조인 불가 |
| 독립 배포 | 분산 트랜잭션 복잡 |
| 장애 격리 | 데이터 일관성 관리 어려움 |

---

## 관련 개념

- [[01. Microservices Architecture (기본 개념)]]
- [[01. Saga Pattern (분산 트랜잭션 기본)]]
- [[02. CQRS (읽기,쓰기 분리)]]

---

## Tags

#DatabasePerService #MSA #데이터관리 #PolyglotPersistence
