Outbox 패턴은 **이벤트 발행을 보장하는 방법**
이벤트를 Kafka로 바로 보내지 않고, 같은 DB에 먼저 저장

---

## 핵심

```java
@Transactional
public void createOrder(Order order) {
    orderRepository.save(order);        // 1. 주문 저장
    outboxRepository.save(orderEvent);  // 2. 이벤트도 같은 DB에 저장
}
// 같은 트랜잭션 → 둘 다 성공하거나 둘 다 실패
```

---

## 구조

```
	┌─────────────────────────────────┐
	│            Database             │
	│  ┌─────────┐    ┌───────────┐   │
	│  │ Order   │    │  Outbox   │   │
	│  │ Table   │    │  Table    │   │
	│  └─────────┘    └─────┬─────┘   │
	└───────────────────────┼─────────┘
	                        │
	                 스케줄러가 읽어서
	                        ▼
	                 ┌───────────┐
	                 │   Kafka   │
	                 └───────────┘
```

---

## 스케줄러로 발행

```java
@Scheduled(fixedRate = 1000)
public void publishEvents() {
    List<Outbox> events = outboxRepository.findByStatus("PENDING");
    
    for (Outbox event : events) {
        kafkaTemplate.send(event.getTopic(), event.getPayload());
        event.setStatus("PUBLISHED");
    }
}
```

---

## Outbox 테이블

| id | event_type | payload | status | created_at |
|----|------------|---------|--------|------------|
| 1 | OrderCreated | {...} | PENDING | 2024-01-01 |
| 2 | OrderCreated | {...} | PUBLISHED | 2024-01-01 |

---

## 장단점

| 장점 | 단점 |
|------|------|
| 데이터 일관성 보장 | 스케줄러 주기만큼 지연 |
| 발행 실패해도 재시도 가능 | Outbox 테이블 관리 필요 |
| 순서 보장 | 중복 발행 가능 → 멱등성 필요 |

---

## 관련 개념

- [[02. Transactional Messaging (문제 정의)]]
- [[04. CDC (Change Data Capture) (다른 해결책)]]
- [[05. Outbox + CDC]]
- [[06. Idempotency (멱등성)]]

---

## Tags

#Outbox #EventDriven #데이터일관성
