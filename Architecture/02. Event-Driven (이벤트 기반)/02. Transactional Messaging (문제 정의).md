Transactional Messaging은 **DB 트랜잭션과 메시지 발행을 원자적으로 처리하는 방법**
둘 다 성공하거나 둘 다 실패해야 한다.

---

## 문제 상황

```java
@Transactional
public void createOrder(Order order) {
    orderRepository.save(order);      // 1. DB 저장 ✓
    kafkaTemplate.send(orderEvent);   // 2. 발행 ← 실패하면?
}
```

```
DB 저장 ✓, Kafka 발행 ✗ → 데이터 불일치
- Order DB: 주문 있음
- Kafka: 이벤트 없음 → 재고 차감 안 됨
```

---

## 해결 방법

### 1. Outbox 패턴
이벤트를 같은 DB에 저장 → 스케줄러가 Kafka로 발행

### 2. Outbox + CDC
Debezium이 Outbox 테이블 변경 감지 → 자동 발행

### 3. Transaction Log Tailing
DB 트랜잭션 로그 자체를 읽어서 발행

---

## 비교

| 방식 | 장점 | 단점 |
|------|------|------|
| Outbox + 스케줄러 | 구현 단순 | 폴링 지연 |
| Outbox + CDC | 실시간에 가까움 | 인프라 복잡 |
| Log Tailing | Outbox 불필요 | DB 종속적 |

---

## Consumer 멱등성

메시지 중복 발행 가능 → Consumer에서 멱등성 처리 필수

```java
if (processedEventRepository.exists(event.getId())) {
    return;  // 중복이면 무시
}
```

---

## 관련 개념

- [[03. Outbox Pattern (해결책)]]
- [[04. CDC (Change Data Capture) (다른 해결책)]]
- [[06. Idempotency (멱등성)]]

---

## Tags

#TransactionalMessaging #EventDriven #데이터일관성
