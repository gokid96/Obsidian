
Dead Letter Queue는 **처리 실패한 메시지를 보관하는 별도 큐**
실패한 메시지를 버리지 않고 나중에 분석/재처리할 수 있게 해줌

---

## 왜 필요한가

```
Producer → Queue → Consumer
                      ↓
                   처리 실패 (버그, 데이터 오류 등)
                      ↓
                   재시도... 재시도... 재시도...
                      ↓
                   무한 루프 
```

**DLQ 없으면:**

- 실패한 메시지가 계속 재시도 → 큐 막힘
- 또는 그냥 버림 → 데이터 유실

---

## DLQ 있으면

```
Producer → Queue → Consumer
                      ↓
                   처리 실패
                      ↓
                   재시도 3번
                      ↓
                   계속 실패
                      ↓
              Dead Letter Queue로 이동
                      ↓
              나중에 분석/재처리
```

---

## 구조

```
┌──────────┐     ┌───────────┐     ┌──────────┐
│ Producer │ ──→ │Main Queue │ ──→ │ Consumer │
└──────────┘     └─────┬─────┘     └──────────┘
                       │
                  실패 N회 후
                       ▼
                ┌─────────────┐
                │     DLQ     │ ← 실패 메시지 보관
                └─────────────┘
```

---

## 코드 예시 (Kafka)
```java
@KafkaListener(topics = "order-topic")
public void handle(OrderEvent event) {
    try {
        processOrder(event);
    } catch (Exception e) {
        // 3번 재시도 후에도 실패하면 DLQ로
        kafkaTemplate.send("order-topic.DLQ", event);
    }
}
```

**Spring Kafka 설정**
```yaml
spring:
  kafka:
    listener:
      retry:
        max-attempts: 3
    dead-letter-topic: order-topic.DLQ
```

---

## DLQ 처리 방법

|방법|설명|
|---|---|
|수동 확인|개발자가 DLQ 보고 원인 분석|
|자동 재처리|스케줄러로 주기적 재시도|
|알림|DLQ에 쌓이면 Slack/이메일 알림|

---

## 실패 원인 예시

|원인|대응|
|---|---|
|일시적 장애|재처리하면 성공|
|데이터 오류|수동 수정 후 재처리|
|버그|코드 수정 후 재처리|

---

## 장단점

|장점|단점|
|---|---|
|메시지 유실 방지|DLQ 모니터링 필요|
|디버깅 용이|재처리 로직 필요|
|메인 큐 막힘 방지||

---

## 관련 개념

- [[01. Kafka]]
- [[06. Idempotency (멱등성)]]
- [[03. Outbox Pattern (해결책)]]

---

## Tags

#DLQ #DeadLetterQueue #Kafka #메시지처리 #에러핸들링