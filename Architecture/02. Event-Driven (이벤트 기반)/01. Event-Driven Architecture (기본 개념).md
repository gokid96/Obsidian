서비스 간 **이벤트로 통신하는 방식**

---

## 기존 방식 vs Event-Driven

**기존 방식 (직접 호출)**은 order-service가 payment, notification, stock 서비스를 직접 알고 호출해야 한다.

**Event-Driven**은 order-service가 "주문 생성됨" 이벤트만 발행하면 끝이다. 누가 구독하든 신경 쓰지 않는다.

```
             ┌─────────────────┐
             │  order-service  │ ← Producer
             └────────┬────────┘
                      │ 이벤트 발행
                      ▼
┌─────────────────────────────────────────────────────┐
│                      Kafka                          │
└────────┬──────────────┬──────────────┬─────────────┘
         │              │              │
         ▼              ▼              ▼
   ┌───────────┐  ┌─────────────┐  ┌───────────┐
   │   stock   │  │notification │  │ analytics │ ← Consumer
   └───────────┘  └─────────────┘  └───────────┘
```

---

## 구현 방식 (**Spring Event** VS Kafka)

**Spring Event**는 같은 JVM 내부에서 `eventPublisher.publish()`로 동작한다. 서버가 죽으면 이벤트가 유실되므로 로깅, 통계 같은 부가 기능에 적합하다.

**Kafka**는 외부 메시지 브로커를 사용해 `kafkaTemplate.send()`로 통신한다. 이벤트 보존과 재처리가 가능하므로 결제, 재고 같은 핵심 비즈니스에 적합하다.

---

## 장단점

**장점**으로는 느슨한 결합(서비스끼리 서로 몰라도 됨), 확장 용이(새 Consumer 추가 시 기존 코드 수정 없음), 장애 격리(한 서비스가 죽어도 다른 서비스에 영향 없음), 비동기 처리(응답을 기다리지 않아 빠름)가 있다.

**단점**으로는 디버깅 어려움(이벤트 흐름 추적이 복잡함), 순서 보장 어려움(이벤트 도착 순서가 보장 안 될 수 있음), 트랜잭션 관리(분산 트랜잭션 처리를 위해 Saga 패턴 필요)가 있다.

---

## 언제 무엇을 쓸까

**동기 방식 (REST/gRPC)**은 즉시 응답이 필요하거나, 단순한 요청-응답 구조이거나, 트랜잭션 보장이 중요할 때 사용한다. 예를 들어 주문 조회, 결제 요청이 해당한다.

**비동기 방식 (Event-Driven)**은 응답을 기다리지 않아도 되거나, 한 이벤트에 여러 서비스가 반응해야 하거나, 느슨한 결합이 중요할 때 사용한다. 예를 들어 주문 생성 후 알림/재고/통계 처리, 결제 완료 후 포인트 적립이 해당한다.

**실무에서는 둘을 섞어서 사용한다.** 결과가 필요한 결제는 REST로, 비동기로 처리해도 되는 알림/통계/재고는 Kafka 이벤트로 처리한다.

```
Client → API Gateway → order-service (REST)
                            │
                            ├── payment-service (REST) ← 결과 필요
                            │
                            └── 이벤트 발행 (Kafka)
                                    ├── notification-service ← 비동기
                                    ├── analytics-service ← 비동기
                                    └── stock-service ← 비동기
```

---

## 모놀리식에서 Event-Driven을 쓰는 이유

직접 호출 방식에서는 OrderService가 모든 서비스를 알아야 하고, 기능 추가마다 수정이 필요하다.

```java
public void createOrder(Order order) {
    orderRepository.save(order);
    notificationService.send(order);
    stockService.decrease(order);
    analyticsService.log(order);
}
```

이벤트 방식에서는 OrderService가 이벤트만 발행하면 된다. 
결합도가 낮아지고, 새 Handler를 추가해도 OrderService 수정이 없으며, 
나중에 MSA로 전환할 때 `eventPublisher`를 `kafkaTemplate`으로 바꾸면 된다.

```java
public void createOrder(Order order) {
    orderRepository.save(order);
    eventPublisher.publish(new OrderCreatedEvent(order));
}
```

---

## MSA와의 관계

MSA는 서비스 분리 방식이고, Event-Driven은 서비스 간 통신 방식이다. 
둘은 필수 관계가 아니다. 
MSA가 아니어도 Event-Driven을 쓸 수 있고, MSA여도 REST로 통신할 수 있다.
