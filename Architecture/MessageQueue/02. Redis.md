# Redis

Redis는 **인메모리 데이터 저장소**다. 데이터를 디스크가 아닌 메모리에 저장해서 매우 빠르다.

---

## 주요 용도

- **캐시:** DB 조회 결과를 Redis에 저장해두고 재사용. DB 부하를 줄이고 응답 속도를 높임
- **세션 저장소:** 로그인 세션을 Redis에 저장. 여러 서버가 세션 공유 가능
- **분산 락:** 여러 서버에서 동시에 같은 작업을 못하게 잠금 처리
- **메시지 큐:** Pub/Sub 기능으로 간단한 메시지 브로커 역할
- **랭킹/리더보드:** Sorted Set으로 실시간 순위 처리

---

## 자료구조

Redis는 단순 key-value가 아니라 다양한 자료구조를 지원한다.

|타입|설명|예시|
|---|---|---|
|String|단순 값|캐시, 카운터|
|Hash|필드-값 쌍|사용자 정보|
|List|순서 있는 목록|최근 본 상품|
|Set|중복 없는 집합|태그, 좋아요 유저|
|Sorted Set|점수로 정렬된 집합|랭킹|

---

## 코드 예시

### 순수 Java (Jedis)

```java
Jedis jedis = new Jedis("localhost", 6379);

// 저장
jedis.set("user:1:name", "홍길동");

// 조회
String name = jedis.get("user:1:name");

// 만료시간 설정 (60초)
jedis.setex("session:abc123", 60, "userId:1");
```

### Spring Data Redis

```java
@Autowired
private StringRedisTemplate redisTemplate;

// 저장
redisTemplate.opsForValue().set("user:1:name", "홍길동");

// 조회
String name = redisTemplate.opsForValue().get("user:1:name");

// 만료시간 설정
redisTemplate.opsForValue().set("session:abc123", "userId:1", Duration.ofSeconds(60));
```

---

## 캐시 패턴 (Cache-Aside)

```java
public User getUser(Long userId) {
    String key = "user:" + userId;
    
    // 1. Redis에서 먼저 조회
    String cached = redisTemplate.opsForValue().get(key);
    if (cached != null) {
        return parseUser(cached);  // 캐시 히트
    }
    
    // 2. 없으면 DB 조회
    User user = userRepository.findById(userId);
    
    // 3. Redis에 저장 (다음에 빠르게 조회)
    redisTemplate.opsForValue().set(key, toJson(user), Duration.ofMinutes(10));
    
    return user;
}
```

```
┌────────┐      1. 조회      ┌───────┐
│ Client │ ───────────────→ │ Redis │
└────────┘                   └───┬───┘
     ↑                           │
     │                      캐시 히트? 
     │                           │
     │    2. 캐시 미스 시         ↓
     │         DB 조회      ┌────────┐
     └───────────────────── │   DB   │
                            └────────┘
```

---

## 대규모 예약 시스템에서의 활용

콘서트 티켓 100장인데 동시에 1만 명이 예약 버튼을 누르면? DB만으로는 동시 요청을 막기 어렵다.

```
사용자 A → 잔여 100장 확인 → 예약 성공
사용자 B → 잔여 100장 확인 → 예약 성공
...
→ 100장인데 500명이 예약됨 (오버부킹)
```

### 1. 분산 락 (Redisson)

```java
RLock lock = redissonClient.getLock("ticket:concert:123");

try {
    // 락 획득 시도 (3초 대기, 5초 후 자동 해제)
    if (lock.tryLock(3, 5, TimeUnit.SECONDS)) {
        // 한 명만 여기 들어옴
        ticketService.reserve(concertId, userId);
    }
} finally {
    lock.unlock();
}
```

### 2. 재고 감소 (원자적 연산)

```java
// DECR은 원자적 → 동시 요청해도 안전
Long remaining = redisTemplate.opsForValue().decrement("stock:concert:123");

if (remaining >= 0) {
    // 예약 진행
} else {
    // 품절
    redisTemplate.opsForValue().increment("stock:concert:123"); // 롤백
}
```

### 3. 대기열 (Sorted Set)

```java
// 대기열에 추가 (타임스탬프로 순서 보장)
redisTemplate.opsForZSet().add("queue:concert:123", userId, System.currentTimeMillis());

// 상위 100명 가져와서 처리
Set<String> top100 = redisTemplate.opsForZSet().range("queue:concert:123", 0, 99);
```

### 흐름

```
사용자 요청 → Redis 대기열 진입 → 순서대로 처리 → DB 저장
     │
     └→ 10001번째? → "대기 인원 10000명" 안내
```
## 스케줄러만 쓸 때

```
사용자 → Redis 대기열 → 스케줄러가 1초마다 폴링 → DB 저장
```

단순하고 구현 쉬움. 근데 초당 수만 건이면 스케줄러 한 대로 감당 안 됨.

## Kafka 같이 쓸 때

```
사용자 → Redis 대기열 → Kafka → 같은 Consumer 여러 대가 병렬 처리 → DB 저장
```

같은 Consumer를 10대, 20대로 늘려서 처리량을 확장할 수 있음.

---

## Kafka vs Redis

| |Kafka|Redis|
|---|---|---|
|주 목적|이벤트 스트리밍|캐시, 세션, 빠른 조회|
|데이터 보존|설정 기간 동안 보관|기본 휘발성 (영속화 옵션 있음)|
|처리 방식|메시지를 순서대로 처리|즉시 조회/저장|
|사용 예|서비스 간 비동기 통신|DB 앞단 캐시|

---

## 관련 개념

- [[01. Kafka]]
- [[캐시 전략]]
- [[분산 락]]
